<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Javascript学习笔记1 | 暮紫天地</title><meta name="robots" content="noindex"><meta name="keywords" content="前端, 设计"><meta name="author" content="Elzzach"><meta name="copyright" content="Elzzach"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="JavaScript历史概述Netscape 发明了 JavaScript 当 Netscape Navigator 崭露头角时，Nombas 开发了一个可以嵌入网页中的 CEnvi 的版本。这些早期的试验被称为 Espresso Page（浓咖啡般的页面），它们代表了第一个在万维网上使用的客户端语言。而 Nombas 丝毫没有料到它的理念将会成为万维网的一块重要基石。 当网上冲浪越来越流行时，对">
<meta property="og:type" content="article">
<meta property="og:title" content="Javascript学习笔记1">
<meta property="og:url" content="https://blog.elzzach.top/article/fbb5b1c9a9c7.html">
<meta property="og:site_name" content="暮紫天地">
<meta property="og:description" content="JavaScript历史概述Netscape 发明了 JavaScript 当 Netscape Navigator 崭露头角时，Nombas 开发了一个可以嵌入网页中的 CEnvi 的版本。这些早期的试验被称为 Espresso Page（浓咖啡般的页面），它们代表了第一个在万维网上使用的客户端语言。而 Nombas 丝毫没有料到它的理念将会成为万维网的一块重要基石。 当网上冲浪越来越流行时，对">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.elzzach.top/rgba(0,%200,%200,%200)">
<meta property="article:published_time" content="2023-12-28T09:17:32.000Z">
<meta property="article:modified_time" content="2023-12-28T09:46:14.713Z">
<meta property="article:author" content="Elzzach">
<meta property="article:tag" content="前端, 设计">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.elzzach.top/rgba(0,%200,%200,%200)"><link rel="shortcut icon" href="https://blog.elzzach.top/global-img/favicon.webp"><link rel="canonical" href="https://blog.elzzach.top/article/fbb5b1c9a9c7.html"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://npm.elemecdn.com/@fortawesome/fontawesome-free@latest/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/node-snackbar@latest/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"https://npm.elemecdn.com/ezsttcfs@latest/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"距离本文上次更新已经过去了","messageNext":"天，文章中的内容有可能已经过时。如果过时，请联系作者尝试更新为最新版。"},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":null},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#c449f5","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://npm.elemecdn.com/flickr-justified-gallery@latest/dist/fjGallery.min.js',
      css: 'https://npm.elemecdn.com/flickr-justified-gallery@latest/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Javascript学习笔记1',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-12-28 17:46:14'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" /><meta http-equiv="Cache" content="no-cache"><meta http-equiv="Pragma" content="no-cache" /><meta http-equiv="Expires" content="0" /><link rel="stylesheet" href="/ext/ez.css"><meta name="generator" content="Hexo 6.0.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.elzzach.top/global-img/avatar.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">16</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">35</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo/"><i class="fa-fw fas fa-ellipsis"></i><span> 碎碎念</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img nav-fixed nav-visible" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">暮紫天地</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo/"><i class="fa-fw fas fa-ellipsis"></i><span> 碎碎念</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Javascript学习笔记1</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-12-28T09:17:32.000Z" title="发表于 2023-12-28 17:17:32">2023-12-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-12-28T09:46:14.713Z" title="更新于 2023-12-28 17:46:14">2023-12-28</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">29.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>97分钟</span></span></div></div></div><article class="post-content" id="article-container"><h2 id="JavaScript历史概述"><a href="#JavaScript历史概述" class="headerlink" title="JavaScript历史概述"></a>JavaScript历史概述</h2><p><strong>Netscape 发明了 JavaScript</strong></p>
<p>当 Netscape Navigator 崭露头角时，Nombas 开发了一个可以嵌入网页中的 CEnvi 的版本。这些早期的试验被称为 Espresso Page（浓咖啡般的页面），它们代表了第一个在万维网上使用的客户端语言。而 Nombas 丝毫没有料到它的理念将会成为万维网的一块重要基石。</p>
<p>当网上冲浪越来越流行时，对于开发客户端脚本的需求也逐渐增大。此时，大部分因特网用户还仅仅通过 28.8 kbit&#x2F;s 的调制解调器连接到网络，即便这时网页已经不断地变得更大和更复杂。而更加加剧用户痛苦的是，仅仅为了简单的表单有效性验证，就要与服务器进行多次地往返交互。设想一下，用户填完一个表单，点击提交按钮，等待了 30 秒的处理后，看到的却是一条告诉你忘记填写一个必要的字段。</p>
<p>那时正处于技术革新最前沿的 Netscape，开始认真考虑开发一种客户端脚本语言来解决简单的处理问题。</p>
<p>当时工作于 Netscape 的 Brendan Eich，开始着手为即将在 1995 年发行的 Netscape Navigator 2.0 开发一个称之为 LiveScript 的脚本语言，当时的目的是在浏览器和服务器（本来要叫它 LiveWire）端使用它。Netscape 与 Sun 及时完成 LiveScript 实现。</p>
<p>就在 Netscape Navigator 2.0 即将正式发布前，Netscape 将其更名为 JavaScript，目的是为了利用 Java 这个因特网时髦词汇。Netscape 的赌注最终得到回报，JavaScript 从此变成了因特网的必备组件。</p>
<h2 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h2><p>编辑器：如VSCode。</p>
<p>运行：在浏览器端运行（js代码嵌入html文件中在浏览器打开或者在浏览器控制台中运行）或脱离浏览器在node.js环境中运行。</p>
<h2 id="语法基础"><a href="#语法基础" class="headerlink" title="语法基础"></a>语法基础</h2><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>命名规则同，特性：开头及后面都可以使用美元符号$。</p>
<h3 id="严格模式（特性）"><a href="#严格模式（特性）" class="headerlink" title="严格模式（特性）"></a>严格模式（特性）</h3><p>ES5新增的预处理指令，受所有现代浏览器支持，会处理掉一些ES3的不规范写法，并对不安全活动报错。</p>
<p><strong>对整个脚本启用</strong>：在脚本开头加<code>&quot;use strict&quot;;</code></p>
<p><strong>仅对某个函数启用</strong>：在函数体内开头加<code>&quot;use strict&quot;;</code></p>
<h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><p><strong>通常以分号结尾，非必需，但强烈推荐使用。</strong>分号结尾的好处有：</p>
<ol>
<li>防止省略造成的问题如输入不完整；</li>
<li>有利于开发者删除空白来压缩代码（没有分号的话删掉所有空白多半会报错）；</li>
<li>在某些情况下提升性能，因为解析器会尝试在合适位置补加分号来纠正语法错误。</li>
</ol>
<h3 id="变量声明-x2F-赋值"><a href="#变量声明-x2F-赋值" class="headerlink" title="变量声明&#x2F;赋值"></a>变量声明&#x2F;赋值</h3><h4 id="ES5变量声明"><a href="#ES5变量声明" class="headerlink" title="ES5变量声明"></a>ES5变量声明</h4><p><strong>使用前需先声明或初始化，否则报错。JavaScript为弱类型语言，声明时无需声明变量类型。</strong></p>
<p>变量声明：<code>var variableName;</code></p>
<p>变量初始化：<code>var variableName = value;</code></p>
<p>变量赋值：<code>variableName = value;</code></p>
<p><strong>可以一次性声明&#x2F;初始化多个变量，用逗号隔开即可（<code>var</code>只要写一次）。</strong></p>
<p><code>var</code>特性:</p>
<ol>
<li>作用域：var 声明的变量会成为<strong>包含它的函数</strong>的局部变量，如果函数内部声明（此时应该叫初始化）变量时省略var，那么该变量将成为全局变量，函数调用后在函数外部仍能访问该变量，但非常不推荐这样定义全局变量。</li>
<li>声明提升：<ul>
<li>var 声明的变量将被提升到其所在函数作用域（或全局作用域）的顶部，也就是说同一作用域内即使先使用了变量 a 再用 var 定义变量 a 也不会报错，因为 var 声明的变量将被提升至作用域顶部。但是，提升的是声明，如果声明同时有初始化的话那么初始化的值将不会被提升，也就是变量值将为<code>undefined</code>。</li>
<li>另外 var 还可以在同一作用域内多次重复声明同一个变量，如果多次声明时都有初始化的话变量值将取最后一次初始化时的值（这里指使用变量前声明）。</li>
</ul>
</li>
</ol>
<h4 id="ES6变量声明"><a href="#ES6变量声明" class="headerlink" title="ES6变量声明"></a>ES6变量声明</h4><p><code>let</code>特性：</p>
<ol>
<li><strong>作用域更小</strong>：<code>let</code>声明和<code>var</code>相似，但是<code>var</code>是函数作用域，而<code>let</code>作用域更小，仅限于块作用域内。</li>
<li><strong>在for循环中使用：</strong>如果在for循环中用 let 声明了循环变量，那么循环变量只会在一轮循环中有效，下一次循环的循环变量就是一个新的变量了（即每次循环实际上会重新声明循环变量，不像 var 的话从头到底都只是同一个变量，每次循环只是在修改它的值罢了）。另外 for 循环的一个特性是 <strong>for 后面的圆括号部分是后面循环体部分的父作用域，且是 for 循环外面部分的子作用域，意味着圆括号里循环变量会覆盖循环外面的同名变量，而循环体内的变量若与循环变量同名也会将循环变量覆盖掉，且不会影响循环计数</strong>。</li>
<li><strong>不允许冗余声明</strong>：<code>let</code>也不允许同一块作用域内重复声明变量。如函数的圆括号部分和函数体部分是同一个作用域，因此函数体内不能用 let 重新声明参数。</li>
<li><strong>不存在变量提升：</strong>不同于 var ，let 声明的变量是不会被提升的，在同一作用域内在未经声明使用变量后再用 let 声明变量将抛出ReferenceError。</li>
<li><strong>暂时性死区：</strong>暂时性死区是 let 不存在变量提升产生的一个现象，即块作用域中如果用 let 命令声明了某变量，但是在 let 命令执行前使用了它，那么该变量便处于暂时性死区中（即该作用域中其相应的 let 命令执行前的那段时间），无法获取和操作，但是已经在该作用域中存在，因此会覆盖掉父作用域中的同名变量，不受作用域外影响，也不会泄漏到作用域外。若尝试在变量处于暂时性死区中时使用它，那么必将抛出 ReferenceError。</li>
<li><strong>全局声明不会称为 window 对象的属性：</strong>let 不会，但是 var 在全局作用域中声明的变量将成为 window 对象的属性。</li>
</ol>
<p><code>const</code>的行为与<code>let</code>基本相似，当然它还有一些特性：</p>
<ol>
<li>声明变量时必须同时初始化。</li>
<li>初始化后值便不可再修改，否则报错。不过这条规则只针对 const 指向的变量的引用，所以如果 const 声明的是一个对象，修改对象内部的属性等是允许的。</li>
</ol>
<p>和暂时性死区有关的一个很好的题目：</p>
<p><strong>变量可见吗？</strong></p>
<p>下面这段代码的结果会是什么？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// ?</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">func</span>();</span><br></pre></td></tr></table></figure>

<p>P.S. 这个任务有一个陷阱。答案并不明显。</p>
<p>答案：error。如果把函数里的对x的声明去掉，就可以打印出1了，但是有这句的话就会出现暂时性死区。</p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p><strong>如何确定JavaScript中的数据的类型</strong>：使用<code>typeof</code>操作符来确定任意变量的数据类型，使用时可以加括号，也可以不加。<code>typeof</code>操作符返回相应数据类型名称的字符串。</p>
<p>注意，<strong>当<code>typeof</code>操作符返回结果为<code>&quot;object&quot;</code>时表示该变量为不是函数的对象或者<code>null</code>类型</strong>，因为<code>null</code>类型被认为是一个空对象指针，而函数对象会另返回一个结果<code>&quot;function&quot;</code>。</p>
<h4 id="简单数据类型（原始类型）"><a href="#简单数据类型（原始类型）" class="headerlink" title="简单数据类型（原始类型）"></a>简单数据类型（原始类型）</h4><h5 id="Undefined"><a href="#Undefined" class="headerlink" title="Undefined"></a><strong>Undefined</strong></h5><p>该类型只有一个值<code>undefined</code>，当变量被声明而未初始化时默认取此值。对未声明的变量进行 typeof 操作也会返回 undefined，实际上对未声明的变量（不包括处于暂时性死区中的变量）只能进行这么一个有效操作。另外<code>undefined</code>在条件判断中被当作 false 看待（除了未声明变量所代表的undefined，这种情况下条件表达式会报错）。</p>
<blockquote>
<p>总结：当 typeof 返回 <code>“undefined”</code>时说明该变量已被声明但未初始化或者尚未声明。</p>
</blockquote>
<h5 id="Null"><a href="#Null" class="headerlink" title="Null"></a><strong>Null</strong></h5><p>该类型只有一个值<code>null</code>，表示一个空对象指针。<code>undefined</code>是由<code>null</code>派生而来的，因此ECMA-262将这两个值定义为表面相等，即表达式<code>undefined == null</code>会返回 true。当定义了一个要保存对象的变量但当时又没有这个对象可以将其初始化时就用 null 来初始化，一来可保持 null 代表空对象指针的语义，二来可将其与 undefined 区分开来。<code>null</code>在条件判断中被当作 false 看待。</p>
<blockquote>
<p>记住表达式<code>typeof null</code>返回的是”object”。</p>
</blockquote>
<h5 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a><strong>Boolean</strong></h5><p>该类型有两个字面值 <code>true</code>和<code>false</code>，且它们并不等于 1 和 0。其他类型的值可通过Boolean（）转型函数转换为布尔值。</p>
<table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">会转换为true的值</th>
<th align="center">会转换为false的值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Undefined</td>
<td align="center">——</td>
<td align="center">undefined</td>
</tr>
<tr>
<td align="center">Number</td>
<td align="center">其他所有数字</td>
<td align="center">0、NaN</td>
</tr>
<tr>
<td align="center">String</td>
<td align="center">非空字符串</td>
<td align="center">空字符串</td>
</tr>
<tr>
<td align="center">Object</td>
<td align="center">所有对象</td>
<td align="center">null</td>
</tr>
</tbody></table>
<h5 id="Number"><a href="#Number" class="headerlink" title="Number"></a><strong>Number</strong></h5><h6 id="表示十进制数"><a href="#表示十进制数" class="headerlink" title="表示十进制数"></a><strong>表示十进制数</strong></h6><p>直接书写即可；</p>
<h6 id="表示八进制数"><a href="#表示八进制数" class="headerlink" title="表示八进制数"></a><strong>表示八进制数</strong></h6><p>加前缀0。但是严格模式下八进制字面量会报错，应将前缀改为0o；</p>
<h6 id="表示十六进制数"><a href="#表示十六进制数" class="headerlink" title="表示十六进制数"></a><strong>表示十六进制数</strong></h6><p>加前缀0x。</p>
<p>八进制数和十六进制数在数学运算中会转换为十进制数运算，且返回的结果也是十进制形式的。</p>
<h6 id="表示浮点数"><a href="#表示浮点数" class="headerlink" title="表示浮点数"></a><strong>表示浮点数</strong></h6><p>小数点后至少有一位数字（小数点后无数字会被当作整数对待），且不能为0（1.0会被当作整数1对待），整数部分可以没有数字，但是<strong>推荐加上</strong>。</p>
<h6 id="如何表示科学计数法"><a href="#如何表示科学计数法" class="headerlink" title="如何表示科学计数法"></a><strong>如何表示科学计数法</strong></h6><p>如1e4表示1乘以10的四次方。</p>
<blockquote>
<p><strong>永远不要认为两个浮点数相加就一定等于我们认为的那个值！因为浮点数运算有时存在微小的舍入错误，导致最后结果并不准确</strong>。</p>
</blockquote>
<blockquote>
<p>如在JavaScript中0.1+0.2&#x3D;0.30000000000000004，0.1+0.7&#x3D;0.7999999999999999，等等。</p>
</blockquote>
<h6 id="JavaScript能够表示的数值范围"><a href="#JavaScript能够表示的数值范围" class="headerlink" title="JavaScript能够表示的数值范围"></a><strong>JavaScript能够表示的数值范围</strong></h6><p>ECMAScript可以表示的最小数值保存在<code>Number.MIN_VALUE</code> 中，这个值在多数浏览器中是5e-324（注意这是个正数，所以严格来说这个值是ECMAScript可以表示的最小的正数，这个数乘以0.1会直接变成0）；可以表示的最大数值保存在<code>Number.MAX_VALUE</code>中，这个值在多数浏览器中是1.7976931348623157e+308（这个值乘以2会变成Infinity）。</p>
<h6 id="JavaScript不能表示的数值怎么处理"><a href="#JavaScript不能表示的数值怎么处理" class="headerlink" title="JavaScript不能表示的数值怎么处理"></a><strong>JavaScript不能表示的数值怎么处理</strong></h6><ol>
<li>如果某个计算得到的数值结果超出了JavaScript可以表示的范围，那么这个数值会被自动转换为Infinity(无穷)值。任何无法表示的负数以-Infinity(负无穷大)表示，任何无法表示的正数以Infinity(正无穷大，注意不是+Infinity）表示。Infinity值不能用于任何计算。<strong>要确定一个数值能不能被JavaScript表示(在JavaScript能表示的数值范围内)，可以使用isFinite ( )函数判断</strong>。</li>
<li>当用0除以0会返回NaN（Not a  Number，“不是数值”），其他数除以0会返回相应的Infinity。任何涉及NaN的运算操作都将返回NaN，且NaN不等于包括NaN本身在内的任何值。<strong>要确定一个值是否“不是数值”，可以用isNaN（）函数判断</strong>，该函数将数值和能转换为数值类型的值认为是数值，无法转换为数值类型的值都不是数值。</li>
</ol>
<h6 id="如何将非数值类型手动转换为数值类型"><a href="#如何将非数值类型手动转换为数值类型" class="headerlink" title="如何将非数值类型手动转换为数值类型"></a><strong>如何将非数值类型手动转换为数值类型</strong></h6><ol>
<li>Number（）转型函数，可用于全部六种数据类型。六种数据类型都有相对应的转换方式。</li>
<li>parseInt（）函数，用于将String类型转换为整数。转换规则：从字符串中的第一个非空格字符开始转换。如果第一个字符不是数值字符、加号或减号，parseInt ( )立即返回NaN。如果第一个字符是数值字符、加号或减号，则继续依次检测每个字符，直到字符串末尾（结束并返回解析结果），或碰到非数值字符（提前结束并返回前面部分的解析结果）。parseInt ()函数也能识别不同的整数格式（十进制、八进制、十六进制)，如果字符串以”0x”开头，就会被解释为十六进制整数。如果字符串以”0”开头，且紧跟着数值字符，在非严格模式下会被某些实现解释为八进制整数，虽然实际上从结果上看跟十进制没有什么区别。不过parseInt（）函数可以接收第二个参数作为解析结果的进制数，即手动指示按什么进制解析字符串。当第二个参数传入16时字符串开头的0x可以省略，但没有第二个参数的时候省略0x就有可能返回NaN。</li>
<li>parseFloat（）函数，用于将String类型转换为浮点数。其转换规则与parseInt（）函数基本相同，但第一次出现的小数点和字母e（科学计数法）是有效的（除去某些极端情况），第二次就无效了；并且该函数只能转换十进制数，没有第二个参数。如果解析结果是个整数，就按整数返回。</li>
</ol>
<blockquote>
<p>Number（）在转换字符串为数值时是从整体来看能否全部转换为数值，有一个字符不能就返回NaN；而相比之下parseInt（）和parseFloat（）与其说是将字符串转换为数字，不如说是”从字符串中解析出数字“，当然也不是字符串中的数字全部解析出来，只解析第一次出现的连续的数字。</p>
</blockquote>
<p>上面说的是JavaScript中的number原始类型，如果调用Number（）构造函数即<code>new Number()</code>并传入一个数值，就可以构造出一个Number引用类型的对象，这个对象有更多的方法。</p>
<blockquote>
<p>注意，和下面的String类型一样，原始值其实也可以直接调用这些方法，这时后台会自动调用构造函数为这个原始值创建相应的对象然后调用这些方法。</p>
</blockquote>
<h6 id="数字格式化"><a href="#数字格式化" class="headerlink" title="数字格式化"></a><strong>数字格式化</strong></h6><ol>
<li>指定数字小数点位数：Number对象的toFixed（）方法可以将数字转换为包含指定小数点位数的字符串，该方法接收一个参数，就是指定的小数位数。小数点位数少的就在后面补0，多的就四舍五入。</li>
<li>指定科学计数法中底数的小数位数：toExponential（）方法可以接收一个参数，来指定数字转换为科学计数法（字符串形式）后底数的小数位数。（会四舍五入）</li>
<li>指定数字格式化后的总位数：toPrecision（）方法接收一个参数，指定将数字格式化后的总位数。为了完成要求，它可能会将数字向上或向下舍入。比如99用1位表示会变成1e2。这个方法的本质是根据情况选择调用toFixed方法或者toExponential方法。</li>
</ol>
<h5 id="String"><a href="#String" class="headerlink" title="String"></a><strong>String</strong></h5><h6 id="表示字符串"><a href="#表示字符串" class="headerlink" title="表示字符串"></a><strong>表示字符串</strong></h6><p>字符串可以用单引号、双引号、反引号括起来，但引号一定要成对，且单双引号括起来的一般是单行字符串，如果要表示多行字符串，需要在每一行的结尾加一个反斜杠<code>\</code>。而反引号括起来的字符串可以直接是多行字符串。</p>
<h6 id="获取字符串长度"><a href="#获取字符串长度" class="headerlink" title="获取字符串长度"></a><strong>获取字符串长度</strong></h6><p>可以从字符串对象的length属性来获取字符串的长度。严格来说是字符串中16位字符的个数。双字节字符的存在会影响结果的准确性。（目前绝大多数字符包括很多特殊字符都可以计算准确，基本上只有表情符号会一个被当成两个算，比如😀😂这种）</p>
<h6 id="转换其他数据类型为字符串"><a href="#转换其他数据类型为字符串" class="headerlink" title="转换其他数据类型为字符串"></a><strong>转换其他数据类型为字符串</strong></h6><ol>
<li>toString（）方法，适用于除了null和undefined之外的四种数据类型，每种数据类型都有相应的转换规则。对数值调用该方法时还可以接收一个参数指定输出的字符串是什么进制形式的。</li>
<li>String（）转型函数，对于null和undefined将直接返回字符串’null’和’undefined’，其他类型将直接调用toString（）方法。</li>
</ol>
<h6 id="查找字符串中指定索引位置的字符"><a href="#查找字符串中指定索引位置的字符" class="headerlink" title="查找字符串中指定索引位置的字符"></a>查找字符串中指定索引位置的字符</h6><p>charAt（）方法接收一个整数参数表示字符串中的指定索引位置，并返回该位置处的字符（不考虑表情符号这种双字节字符）。</p>
<p>当字符串中存在表情符号时，字符串的length属性不再与实际长度相等，这时用索引查找字符可能会出现问题，解决办法是迭代字符串，可以得到正确的字符串长度。</p>
<p>顺带一提，字符串是可以像数组那样用中括号索引来访问指定位置的字符的，因为字符串在使用时会被转化为类数组的String对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...<span class="string">&#x27;ab😀de&#x27;</span>]<span class="comment">//可以返回包含正确的五个字符的数组</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>charCodeAt()、fromCharCode()、codePointAt()、fromCodePoint()方法都是跟码元（十六进制数）有关，没什么用处。</p>
<p>normalize()涉及字符编码规范化，也用不到。</p>
</blockquote>
<h6 id="拼接多个字符串为一个字符串"><a href="#拼接多个字符串为一个字符串" class="headerlink" title="拼接多个字符串为一个字符串"></a>拼接多个字符串为一个字符串</h6><p>concat（）方法可以接收一个或多个字符串参数，并将它们依次拼接到调用它的字符串后面，并且是非原地修改，返回值需要单独赋值才会保存下来。</p>
<p>加号运算符 + 也可以用于拼接字符串，且一般情况下比concat方法要方便。</p>
<h6 id="从字符串中切取子串"><a href="#从字符串中切取子串" class="headerlink" title="从字符串中切取子串"></a>从字符串中切取子串</h6><ol>
<li><code>slice(start, end)</code>方法，提取的子串不包括end位置的字符。</li>
<li><code>substring(start, end)</code>方法，提取的子串不包括end位置的字符。</li>
<li><code>substr(start, number)</code>方法，第二个参数表示提取出来的子串中字符的个数，也就是从start位置开始提取number个字符出来作为子串。（红宝书在此处描述有误）</li>
<li>这三个方法都不是原地修改（字符串的这些方法里似乎都不是原地修改的方法）。</li>
<li>当传入的参数有负值时，slice方法将所有负值参数当作是正索引倒过来数，并且是从-1开始，substring方法将所有负值参数当作0，substr方法则是将第一个负值参数当作正索引倒过来的负索引，第二个负值参数当作0。</li>
<li>这三种方法对于不传入第二个参数的处理方法都是直接切到字符串末尾；如果一个参数都不传，那就直接返回整个字符串。</li>
<li>如果传入的两个参数从左到右代表的字符串切片的方向是从右向左的话，slice方法将返回空字符串，而substring方法将比较两个参数，以较小的参数为起点，较大的参数为终点来切片且不包含终点。substr方法由于第二个参数表示的是字符数量，不存在切片方向反向的问题。</li>
</ol>
<h6 id="根据指定分割符将字符串分割为若干部分"><a href="#根据指定分割符将字符串分割为若干部分" class="headerlink" title="根据指定分割符将字符串分割为若干部分"></a>根据指定分割符将字符串分割为若干部分</h6><p><code>split(str)</code>方法接收一个字符串参数，以该参数为分割符将字符串分割为若干部分，并返回由这些元素组成的数组。参数可以是一个字符或多个字符的字符串。</p>
<h6 id="在字符串中定位子字符串"><a href="#在字符串中定位子字符串" class="headerlink" title="在字符串中定位子字符串"></a>在字符串中定位子字符串</h6><ol>
<li>indexOf（）方法接收一个字符&#x2F;字符串参数，从调用它的字符串开头开始向后寻找给定的字符&#x2F;字符串，并返回找到的结果的第一个字符的索引位置，如果没找到则返回-1。还可以接收第二个参数，指定搜索开始的起始位置。</li>
<li>lastIndexOf（）方法接收一个字符&#x2F;字符串参数，从调用它的字符串末尾开始向前寻找给定的字符&#x2F;字符串，并返回找到的结果的第一个字符（是第一个字符！不是最后一个！）的索引位置，如果没找到则返回-1。还可以接收第二个参数，指定搜索开始的起始位置。</li>
<li>includes()、startsWith()、endsWith()方法分别判断字符串中是否包含、开头是否为、结尾是否为参数字符串。</li>
</ol>
<blockquote>
<p>顺带一提，如果给lastIndexOf（）方法传入空字符串的话，返回值和查看length属性的结果是一样的。</p>
</blockquote>
<h6 id="删除字符串前后的所有空白符（中间的空白符不受影响）"><a href="#删除字符串前后的所有空白符（中间的空白符不受影响）" class="headerlink" title="删除字符串前后的所有空白符（中间的空白符不受影响）"></a>删除字符串前后的所有空白符（中间的空白符不受影响）</h6><p>trim（）方法返回一个调用者字符串删除了开头位置和结尾位置的所有空白符后的副本。</p>
<p>trimLeft()和 trimRight()方法分别用于删除字符串开始和末尾的空格符。trimStart() 和 trimEnd()方法同理。</p>
<h6 id="复制字符串并拼接"><a href="#复制字符串并拼接" class="headerlink" title="复制字符串并拼接"></a>复制字符串并拼接</h6><p>repeat（）方法接收一个参数，表示将字符串复制成多少份（比如 3 就是复制两份加上原来的那个）并拼接在一起返回。这个方法不是原地修改。</p>
<h6 id="在字符串左侧或右侧填充字符"><a href="#在字符串左侧或右侧填充字符" class="headerlink" title="在字符串左侧或右侧填充字符"></a>在字符串左侧或右侧填充字符</h6><p>padStart()和 padEnd()方法接收两个参数，第一个参数是指定长度，第二个参数是填充字符，默认为空格。如果调用者字符串小于指定长度，则在相应一边填充指定字符，直至满足长度条件。</p>
<p>可选的第二个参数并不限于一个字符。如果提供了多个字符的字符串，则会将其拼接并截断以匹配指定长度。此外，如果长度小于或等于字符串长度，则会返回原字符串。</p>
<h6 id="字符串解构"><a href="#字符串解构" class="headerlink" title="字符串解构"></a>字符串解构</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...string]<span class="comment">//可以将字符串分割为字符数组</span></span><br></pre></td></tr></table></figure>

<h6 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h6><p>toLowerCase（）方法将字符串中的字母全部转换为小写；</p>
<p>toUpperCase（）方法将字符串中的字母全部转换为大写。</p>
<h6 id="比较两个字符串"><a href="#比较两个字符串" class="headerlink" title="比较两个字符串"></a>比较两个字符串</h6><p>localeCompare()方法比较两个字符串，返回如下3个值中的一个：</p>
<ul>
<li>如果按照字母表顺序，调用者字符串应该排在字符串参数前头，则返回负值。(通常是-1，具体还要看与实际值相关的实现。)</li>
<li>如果调用者字符串与字符串参数相等，则返回0。</li>
<li>如果按照字母表顺序，调用者字符串应该排在字符串参数后头，则返回正值。(通常是 1，具体还要看与实际值相关的实现。)</li>
</ul>
<blockquote>
<p>注意，比较是两个字符串按字符顺序逐个进行比较的，一旦比较出大小则不再往下比较。</p>
</blockquote>
<h4 id="复杂数据类型（引用类型）"><a href="#复杂数据类型（引用类型）" class="headerlink" title="复杂数据类型（引用类型）"></a>复杂数据类型（引用类型）</h4><h5 id="Object"><a href="#Object" class="headerlink" title="Object"></a><strong>Object</strong></h5><p>以下介绍一些每个对象都具有的属性和方法：</p>
<h6 id="查看当前对象是哪个构造函数创建的"><a href="#查看当前对象是哪个构造函数创建的" class="headerlink" title="查看当前对象是哪个构造函数创建的"></a>查看当前对象是哪个构造函数创建的</h6><p>constructor: 用于创建当前对象的函数。</p>
<h6 id="判断当前对象实例-不是原型-上是否存在给定的属性"><a href="#判断当前对象实例-不是原型-上是否存在给定的属性" class="headerlink" title="判断当前对象实例(不是原型)上是否存在给定的属性"></a>判断当前对象实例(不是原型)上是否存在给定的属性</h6><p>hasOwnProperty(propertyName): 要检查的属性名必须是字符串(如o.hasOwnProperty ( “name”))或符号。</p>
<h6 id="判断当前对象是否为另一个对象的原型"><a href="#判断当前对象是否为另一个对象的原型" class="headerlink" title="判断当前对象是否为另一个对象的原型"></a>判断当前对象是否为另一个对象的原型</h6><p>isPrototypeOf(object):用于判断当前对象是否为另一个对象的原型。</p>
<h6 id="判断给定的属性是否可以使用for-in语句枚举"><a href="#判断给定的属性是否可以使用for-in语句枚举" class="headerlink" title="判断给定的属性是否可以使用for-in语句枚举"></a>判断给定的属性是否可以使用for-in语句枚举</h6><p>propertyIsEnumerable(propertyName): 与hasOwnProperty ()一样，属性名必须是字符串。</p>
<h6 id="返回对象的字符串表示"><a href="#返回对象的字符串表示" class="headerlink" title="返回对象的字符串表示"></a>返回对象的字符串表示</h6><p>toLocaleString ( ): 返回对象的字符串表示，该字符串反映对象所在的本地化执行环境。</p>
<p>toString ( ): 返回对象的字符串表示。</p>
<h6 id="返回对象对应的字符串、数值或布尔值表示"><a href="#返回对象对应的字符串、数值或布尔值表示" class="headerlink" title="返回对象对应的字符串、数值或布尔值表示"></a>返回对象对应的字符串、数值或布尔值表示</h6><p>valueOf( ): 返回对象对应的字符串、数值或布尔值表示。通常与toString()的返回值相同。</p>
<h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><h4 id="一元操作符"><a href="#一元操作符" class="headerlink" title="一元操作符"></a>一元操作符</h4><ol>
<li>递增操作符和递减操作符</li>
<li>一元加和一元减（正负数）</li>
</ol>
<h4 id="布尔操作符"><a href="#布尔操作符" class="headerlink" title="布尔操作符"></a>布尔操作符</h4><ol>
<li>逻辑非：！</li>
<li>逻辑与：&amp;&amp;</li>
<li>逻辑或：||</li>
</ol>
<p>会短路！</p>
<h4 id="乘性操作符"><a href="#乘性操作符" class="headerlink" title="乘性操作符"></a>乘性操作符</h4><ol>
<li>乘法操作符*</li>
<li>除法操作符&#x2F;</li>
<li>取模操作符%（模，即余数）</li>
</ol>
<h4 id="指数操作符"><a href="#指数操作符" class="headerlink" title="指数操作符"></a>指数操作符</h4><p>ES7新增操作符（**），兼容性不是太好，建议还是用Math.pow(底数，幂)代替。</p>
<p>另外还有指数赋值操作符 **&#x3D;。</p>
<h4 id="加性操作符"><a href="#加性操作符" class="headerlink" title="加性操作符"></a>加性操作符</h4><ol>
<li>加法操作符 +</li>
<li>减法操作符 -</li>
</ol>
<h4 id="关系操作符"><a href="#关系操作符" class="headerlink" title="关系操作符"></a>关系操作符</h4><ol>
<li>大于号 &gt;（大于等于 &gt;&#x3D;）</li>
<li>小于号 &lt;（小于等于 &lt;&#x3D;）</li>
</ol>
<blockquote>
<p>在用关系操作符比较两个字符串时比较的是字符的编码大小。</p>
</blockquote>
<h4 id="相等操作符"><a href="#相等操作符" class="headerlink" title="相等操作符"></a>相等操作符</h4><ol>
<li>等于（&#x3D;&#x3D;）和不等于（!&#x3D;），在比较之前会进行转换</li>
<li>全等（&#x3D; &#x3D; &#x3D;）和不全等（!&#x3D;&#x3D;），在比较之前不会进行转换</li>
</ol>
<h4 id="条件操作符"><a href="#条件操作符" class="headerlink" title="条件操作符"></a>条件操作符</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> = expression ? true_value : false_value;</span><br></pre></td></tr></table></figure>

<h4 id="空值合并操作符"><a href="#空值合并操作符" class="headerlink" title="空值合并操作符"></a>空值合并操作符</h4><p><strong>语法</strong>：<code>a ?? b</code></p>
<p>如果a是已定义值（非undefined或null），那么该表达式将返回a的值，否则返回b的值（即使b也是未定义的值：undefined或null）。</p>
<p>可以用条件操作符来实现这个语法：</p>
<p><code>result = (a !== null &amp;&amp; a !== undefined) ? a : b</code></p>
<p>可以扩展该语法，返回第一个已定义的值：<code>a ?? b ?? c ?? d ...</code>。</p>
<p><strong>比较</strong>：</p>
<p><strong>注意</strong>：JavaScript禁止将 ?? 运算符与 &amp;&amp;和||操作符一起使用，除非使用括号指定了优先级。默认情况下??操作符优先级和与&#x2F;或操作符相同。</p>
<p><strong>用处</strong>：如果一个变量可能是未定义的值，用这个操作符来实现当它为未定义值时赋给它一个默认值。</p>
<h4 id="赋值操作符"><a href="#赋值操作符" class="headerlink" title="赋值操作符"></a>赋值操作符</h4><ol>
<li>简单赋值（&#x3D;）</li>
<li>复合赋值（+&#x3D;、-&#x3D;、*&#x3D;、&#x2F;&#x3D;、%&#x3D;、**&#x3D;）</li>
</ol>
<h4 id="逗号操作符"><a href="#逗号操作符" class="headerlink" title="逗号操作符"></a>逗号操作符</h4><p>可以用来在一条语句中进行多个操作，比如在一条声明语句里声明了多个变量。</p>
<h4 id="展开运算符与剩余运算符"><a href="#展开运算符与剩余运算符" class="headerlink" title="展开运算符与剩余运算符"></a>展开运算符与剩余运算符</h4><p>这两种运算符都是<code>...</code>。</p>
<p>展开运算符可以展开数组这都知道，但是它也可以展开对象，只是<code>...obj</code>的结果不符合console.log的语法所以打印不出来。</p>
<p>展开运算符的用处：</p>
<ol>
<li>合并数组：<code>const result = [...arr1, ...arr2]</code></li>
<li>合并对象：<code>const result = &#123;...obj1, ...obj2&#125;</code></li>
<li>将类数组转化为数组：<code>const args = [...arguments]</code></li>
<li>将数组作为参数传入Math.max()等方法中：<code>Math.max(...arr)</code></li>
<li>在数组的首尾添加元素：<code>const result = [1, ...arr]</code>，也可以使用数组的unshift和push方法实现。</li>
</ol>
<p>剩余运算符也叫收集运算符，可以将“逗号隔开的值列表”转化为对象或数组，用处有：</p>
<ol>
<li>只将对象&#x2F;数组的一部分赋值给变量（剩余）：<code>const &#123;age, ...msg&#125; = person</code>，将被剔除的元素写在前面。这种就当是解构赋值的一种特殊情况看好了。</li>
<li>将函数的一系列参数收集为一个数组（收集）：<code>function fn(...args)&#123;// args将是一个数组&#125;</code></li>
</ol>
<p>如何判断<code>...</code>是作为展开运算符还是剩余运算符出现？</p>
<p>在等号左边&#x2F;函数形参上时是剩余&#x2F;收集运算符，反之为展开运算符。</p>
<blockquote>
<p>另：展开运算符实现的是浅复制不是深复制。</p>
</blockquote>
<h3 id="语句-1"><a href="#语句-1" class="headerlink" title="语句"></a>语句</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> prop <span class="keyword">in</span> obj) &#123; <span class="comment">//prop为非符号键</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> elem <span class="keyword">of</span> arr) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="attr">default</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">name</span>(<span class="params">arg1, arg2, ...</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;<span class="comment">//函数声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fn = <span class="keyword">function</span> (<span class="params">arg1, arg2, ...</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;;<span class="comment">//函数表达式，也叫匿名函数或者lambda函数</span></span><br></pre></td></tr></table></figure>

<p>函数表达式可以简化为ES6箭头函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 不带花括号：(...args) =&gt; expression — 右侧是一个表达式：函数计算表达式并返回其结果。</span><br><span class="line"><span class="number">2.</span> 带花括号：(...args) =&gt; &#123; body &#125; — 花括号允许我们在函数中编写多个语句，但是我们需要显式地 <span class="keyword">return</span> 来返回一些内容。</span><br><span class="line"><span class="number">3.</span> 只有当参数为一个且没有默认值时才可以不加圆括号，否则不加圆括号会报错</span><br><span class="line"><span class="comment">//箭头函数虽然语法简洁，但也有很多场合不适用。箭头函数不能使用arguments、super和new.target，也不能用作构造函数。此外，箭头函数也没有prototype属性。</span></span><br></pre></td></tr></table></figure>

<h4 id="函数名"><a href="#函数名" class="headerlink" title="函数名"></a>函数名</h4><p>函数名相当于指向函数的指针，所以一个函数可以有多个函数名来指向它。</p>
<p>ES6的函数对象都有一个只读属性name，一般就是这个函数的名字；没有名字的会显示为空字符串；如果是Function构造函数构造的就会显示为”anonymous”。如果函数是获取函数&#x2F;设置函数&#x2F;bind（）实例化的函数，name属性值前面就会有相应的前缀：get&#x2F;set&#x2F;bound。</p>
<h4 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h4><ol>
<li>ECMAScript函数不关心调用函数时实际传入的参数个数与声明时的参数个数是否匹配，多传或者少传都不会报错；也不在意传入的参数到底是什么类型。这是因为ECMAScript函数内部有一个<code>arguments</code>类数组对象，它不是数组，不能调用Array类型实例的那些方法，但可以用中括号语法访问以及具有length属性，表示函数调用时实际传入了多少个参数，并且这些参数与arguments中的元素是一一对应的。并且在函数内部也可以通过arguments[n]的方式来使用传入的参数，和命名参数是等价的，虽然二者并不是指向同一个内存地址，只不过二者是同步的而已。</li>
<li><code>arguments</code>对象导致ECMAScript函数没有函数签名（接收参数的类型和数量），没有签名就没有函数重载，即一个函数不能有两个定义，同名函数后面的定义会覆盖前面的。</li>
<li>箭头函数不能使用arguments对象。</li>
<li>ECMAScript中所有的参数都是按值传递的，不可能按引用传递。所以如果参数是一个对象，那么传递的实际上是这个对象的引用。</li>
<li>ES5是不支持<code>arg=value</code>这种默认参数的写法的，想实现默认参数只能在函数内部手动判断参数值是否为undefined，如果是则意味着没有传递这个参数，就可以给它赋予一个默认值；如果不是，就说明已经传递了参数，那就维持原状：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arg = (arg === <span class="literal">undefined</span>) ? <span class="string">&#x27;hello&#x27;</span> : arg;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>ES6已经支持直接在参数列表中定义默认参数了。在使用默认参数时，arguments对象不反映参数的默认值，只会反映实际调用函数时传入的值。箭头函数如果使用默认值参数的话只有一个参数时就不能省略括号了。</li>
<li>在参数列表中定义默认参数是存在暂时性死区现象的，即先定义的参数中不能引用后面定义的参数，因为参数是按顺序初始化的。</li>
<li>ES6新增了扩展操作符<code>...</code>，将其前缀在数组变量或者数组字面量前面就相当于把数组拆分开为其中一个个的元素。当定义函数时参数列表中写<code>a, b, c, ...</code>一系列命名参数而调用时传进去的是<code>...[a, b, c, ...]</code>一个被扩展的数组时，此时为扩展参数，函数内部arguments接收的是一系列参数而不是一个数组，因为数组被扩展操作符扩展了，可以将<code>...arr</code>看作一个整体求值的表达式。</li>
</ol>
<blockquote>
<p>当我不想给函数传进去一个完整数组而是想把它拆开时我就传入一个前面缀有扩展操作符的数组，等价于一系列参数，同时函数定义里参数要写成一系列参数的形式以便接收。</p>
</blockquote>
<ol start="10">
<li>扩展操作符除了可以扩展数组外，也可以将几个参数收集整合为一个数组存进命名参数里。当定义函数时参数列表中写<code>...values</code>一个用于存放数组的变量而调用时传进去的是<code>a, b, c, ...</code>一系列命名参数时，此时为收集参数，函数内部的arguments接收的是仍然是一系列参数而不是一个数组（因为实际传入的就是一系列参数），但命名参数确实是一个经整合后的数组。收集参数只能作为最后一个参数，因为它的长度是可变的。</li>
</ol>
<blockquote>
<p>当我想把一系列参数整合到一个数组里在函数中处理的时候我就传入一系列参数，但是在函数定义里写一个被扩展操作符扩展的参数以便接收这些参数，并使得该参数变成一个整合了实际传入参数的数组。</p>
<p>总结：扩展参数时扩展操作符用在传入的实参中；收集参数时扩展操作符用在函数定义里的形参中。</p>
</blockquote>
<ol start="11">
<li>箭头函数只返回一个对象时可以省略return关键字，但是要在花括号外面加一层圆括号，如<code>const getSize = () =&gt; (&#123;width: 100, height: 10&#125;);</code></li>
<li>箭头函数可以直接解决es5中setTimeout和setInterval方法中this指向的是window对象而不是方法所在对象的问题，用箭头函数替代function函数表达式即可</li>
</ol>
<h4 id="函数声明与函数表达式的区别"><a href="#函数声明与函数表达式的区别" class="headerlink" title="函数声明与函数表达式的区别"></a>函数声明与函数表达式的区别</h4><p>事实上，JavaScript 引擎在加载数据时对这两个是区别对待的。JavaScript 引擎在任何代码执行之前，会先读取函数声明，并在执行上下文中生成函数定义。这个过程叫作<strong>函数声明提升</strong>( function declaration hoisting )。而函数表达式必须等到代码执行到它那一行，才会在执行上下文中生成函数定义。</p>
<p>因此即使函数定义出现在调用它们的代码之后，引擎也会把函数声明提升到顶部。如果把前面代码中的函数声明改为等价的函数表达式，那么执行的时候就会出错。</p>
<p>除了函数什么时候真正有定义这个区别之外，这两种语法是等价的。</p>
<h4 id="函数内部"><a href="#函数内部" class="headerlink" title="函数内部"></a>函数内部</h4><h5 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h5><p>函数内部的arguments对象还有一个callee属性，是一个指向该arguments对象所在函数的指针。</p>
<p>用处：如在递归函数内部，返回的函数名必须与递归函数名一致，导致紧密耦合，如果在函数内使用<code>arguments.callee</code>来解耦，无论递归函数怎么改名，内部都能返回正确的函数。</p>
<h5 id="this"><a href="#this" class="headerlink" title="this"></a>this</h5><p>在标准函数中this就指向调用这个方法的对象（把函数当成方法调用的上下文对象），如果在全局上下文中调用则this指向window。</p>
<p>在箭头函数中this指向的是定义这个箭头函数的上下文，如全局上下文中定义的箭头函数中的this就指向window对象。</p>
<blockquote>
<p>执行上下文(以下简称“上下文”)的概念在JavaScript 中是颇为重要的。变量或函数的上下文决定了它们可以访问哪些数据，以及它们的行为。</p>
<p>每个上下文都有一个关联的变量对象（ variable object )，就是包含该上下文中变量的对象。虽然无法通过代码访问变量对象，但后台处理数据会用到它。</p>
<p>上下文有两种：全局上下文和函数上下文。</p>
<p>全局上下文是最外层的上下文。根据ECMAScript实现的宿主环境，表示全局上下文的对象可能不一样。在浏览器中，全局上下文就是我们常说的window对象，因此所有通过var定义的全局变量和函数都会成为window对象的属性和方法。使用let 和 const 的顶级声明不会定义在全局上下文中，但在作用域链解析上效果是一样的。上下文在其所有代码都执行完毕后会被销毁，包括定义在它上面的所有变量和函数(全局上下文在应用程序退出前才会被销毁，比如关闭网页或退出浏览器)。</p>
<p>每个函数调用都有自己的上下文。当代码执行流进入函数时,函数的上下文被推到一个上下文栈上。在函数执行完之后，上下文栈会弹出该函数上下文，将控制权返还给之前的执行上下文。ECMAScript程序的执行流就是通过这个上下文栈进行控制的。</p>
<p>上下文中的代码在执行的时候，会创建变量对象的一个作用域链( scope chain)。这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。代码正在执行的上下文的变量对象始终位于作用域链的最前端。如果上下文是函数，则其活动对象（activation object)用作变量对象。活动对象最初只有一个定义变量: arguments。(全局上下文中没有这个变量)作用域链中的下一个变量对象来自包含上下文，再下一个对象来自再下一个包含上下文。以此类推直至全局上下文;全局上下文的变量对象始终是作用域链的最后一个变量对象。</p>
<p>代码执行时的标识符解析是通过沿作用域链逐级搜索标识符名称完成的。搜索过程始终从作用域链的最前端开始，然后逐级往后，直到找到标识符。(如果没有找到标识符，那么通常会报错。)</p>
</blockquote>
<h5 id="caller"><a href="#caller" class="headerlink" title="caller"></a>caller</h5><p>该属性是函数对象的属性，指向调用当前函数的函数，若是在全局作用域中调用的则为null。和<code>arguments.callee</code>一样也可以用于解耦。</p>
<h5 id="new-target"><a href="#new-target" class="headerlink" title="new.target"></a>new.target</h5><p>ES6新增属性，检测所在函数是使用new关键字调用的还是被当作普通函数调用的。如果是当作构造函数调用的该属性将指向被调用的构造函数；如果是被当作普通函数调用的该属性值就是 undefined。</p>
<h4 id="函数属性与方法"><a href="#函数属性与方法" class="headerlink" title="函数属性与方法"></a>函数属性与方法</h4><h5 id="属性：length"><a href="#属性：length" class="headerlink" title="属性：length"></a>属性：length</h5><p>length属性是该函数定义的命名参数的个数。</p>
<h5 id="属性：prototype"><a href="#属性：prototype" class="headerlink" title="属性：prototype"></a>属性：prototype</h5><p>原型属性，面向对象中有讲。</p>
<h5 id="方法：apply（）"><a href="#方法：apply（）" class="headerlink" title="方法：apply（）"></a>方法：apply（）</h5><p>apply（）方法接收两个参数，一个是用作被调用的方法里的this对象的对象，一个是给被调用的方法传入的参数，可以是数组或者arguments对象，如果被调用方法不需要参数的话可以不用传第二个参数。</p>
<p>apply（）方法的作用是调用这个调用了apply（）方法的函数（即执行这个调用者函数体内的代码），执行时将这个函数内部的this改为指向apply（）方法接收的第一个参数对象。调用apply（）方法的那行语句的返回值就是调用者函数的返回值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">callSum</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> sum.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);<span class="comment">//sum（）就是那个被调用的方法，sum（）方法在这样通过apply（）方法被调用时其内部的this值将不再是指向原来的对象（在这里sum方法本来的this是指向全局上下文对象的），而是指向apply（）方法的第一个参数所代表的对象，而sum（）方法被调用时接收的参数就是apply（）方法的第二个参数。在这个例子里，传给apply方法的是callSum函数内部的this（只不过在这个例子里callSum函数的this也是指向全局上下文对象的）和callSum函数的arguments。也就是说，传给apply方法的第一个参数如果是this的话，调用apply方法的语句位置在函数内部那就是该函数内部的this，如果在全局作用域里那就是全局上下文对象。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">callSum</span>(<span class="number">1</span>, <span class="number">2</span>));<span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>apply（）方法可以用于改变被调用的方法内部的this值指向的对象。当我们在某个方法里使用了this却发现因为某些原因这个this并没有指向我们所预料的对象，那么我们可以使用apply（）方法来强行改变这个this的指向。</p>
<p>这样的好处是即使一个对象上没有某个方法，我们也可以让这个对象来使用这个方法了。</p>
<p>下面这个例子或许会更清楚一点：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">color</span> = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line"> <span class="attr">color</span>: <span class="string">&#x27;blue&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayColor</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">color</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">sayColor</span>(); <span class="comment">// red</span></span><br><span class="line">sayColor.<span class="title function_">call</span>(<span class="variable language_">this</span>); <span class="comment">// red</span></span><br><span class="line">sayColor.<span class="title function_">call</span>(<span class="variable language_">window</span>); <span class="comment">// red</span></span><br><span class="line"><span class="comment">//由上可见sayColor方法里面的this本来指向的是全局上下文对象window。下面我们让它改变指向来指向对象o。</span></span><br><span class="line">sayColor.<span class="title function_">call</span>(o); <span class="comment">// blue</span></span><br></pre></td></tr></table></figure>

<h5 id="方法：call（）"><a href="#方法：call（）" class="headerlink" title="方法：call（）"></a>方法：call（）</h5><p>call（）方法和apply（）方法基本相同，除了在传第二个参数的时候不能传入数组或arguments对象，而要把参数一个个传进去。</p>
<h5 id="方法：bind（）"><a href="#方法：bind（）" class="headerlink" title="方法：bind（）"></a>方法：bind（）</h5><p>bind（）方法接收一个对象作为参数，它会创建一个函数实例（这个函数实例的函数体与调用bind方法的函数对象是一样的），并将这个函数实例的this值绑定到参数代表的那个对象。</p>
<p>bind（）方法其实还有第二个参数，用法和apply（）方法一样。</p>
<p>所以上面那个例子用bind（）方法就可以改写成：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">color</span> = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line"> <span class="attr">color</span>: <span class="string">&#x27;blue&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayColor</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">color</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> func = sayColor.<span class="title function_">bind</span>(o);</span><br><span class="line"><span class="title function_">func</span>(); <span class="comment">//blue</span></span><br></pre></td></tr></table></figure>

<p>注意，一个方法不能二次绑定，即<code>f.bind(o1).bind(o2)</code>这样的用法是无效的，最终绑定到的仍然是o1。</p>
<h5 id="继承的方法：toString（）"><a href="#继承的方法：toString（）" class="headerlink" title="继承的方法：toString（）"></a>继承的方法：toString（）</h5><p>对于函数而言，这个方法始终返回函数定义的代码，返回格式因环境而异，不应用于重要功能，只应在调试中使用。</p>
<h4 id="函数绑定（bind（）的应用）"><a href="#函数绑定（bind（）的应用）" class="headerlink" title="函数绑定（bind（）的应用）"></a>函数绑定（bind（）的应用）</h4><p>对应<code>setTimeout()</code>方法而言，如果将某个对象的方法作为回调传递给它的话可能会出现一个“丢失this”的问题。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">`Hello, <span class="subst">$&#123;<span class="variable language_">this</span>.firstName&#125;</span>!`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(user.<span class="property">sayHi</span>, <span class="number">1000</span>); <span class="comment">// Hello, undefined!</span></span><br></pre></td></tr></table></figure>

<p>这个例子中的this并没有获取到user.firstName这个属性，而是得到了一个undefined。因为如果在浏览器中的<code>setTimeout（）</code>方法的第一个参数上调用了一个方法（而不是写函数表达式或箭头函数）的话，会为这个方法调用设置一个<code>this=window</code>（在node中会设置为timeout对象）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">setTimeout</span>(obj.<span class="property">fn</span>, <span class="number">1</span>);<span class="comment">//在浏览器中会打印出window对象，在node中会打印出timeout对象。</span></span><br></pre></td></tr></table></figure>

<p>那如何保证this指向正确的对象呢？解决方法之一是把方法调用包裹在一个函数表达式或者箭头函数里面：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  obj.<span class="title function_">fn</span>(); <span class="comment">// &#123; fn: [Function: fn] &#125;</span></span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p>不过这种方法有一个小漏洞：如果在<code>setTimeout()</code>方法里的 回调触发之前obj对象的值改变了，比如方法fn变成了方法func，这样的话this仍将指向obj对象，但是obj对象已经没有fn方法了，又将出现错误的情况。</p>
<p>解决方法之二就是使用<code>bind()</code>方法，将调用的方法的this绑定到正确的对象上，即使对象在之后被改变了，bind（）绑定的那个对象仍然是旧的对象，不会改变，这样就避免了上面的那个漏洞的出现。</p>
<h4 id="立即调用的函数表达式（IIFE）"><a href="#立即调用的函数表达式（IIFE）" class="headerlink" title="立即调用的函数表达式（IIFE）"></a>立即调用的函数表达式（IIFE）</h4><p>写法：先写一个函数表达式，然后把它括在一个圆括号里，在后面再加上一个圆括号（有参数就在圆括号里传参数）表示函数调用，别忘了加分号。</p>
<p>IIFE可以模拟块级作用域，将里面的变量与外面的隔离开来。当然自从ES6增加了块级作用域后IIFE就显得不再必要了。</p>
<h4 id="函数进阶知识"><a href="#函数进阶知识" class="headerlink" title="函数进阶知识"></a>函数进阶知识</h4><h5 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h5><p>闭包指的是那些引用了另一个函数作用域中变量的函数，通常是在嵌套函数中实现的。内部函数被外部函数返回并在其他地方使用之后仍然能保持着对那个变量的引用。</p>
<p>之前说到“上下文中的代码在执行的时候，会创建变量对象的一个作用域链( scope chain)。这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。代码正在执行的上下文的变量对象始终位于作用域链的最前端。如果上下文是函数，则其活动对象（activation object)用作变量对象。活动对象最初只有一个定义变量: arguments。(全局上下文中没有这个变量)作用域链中的下一个变量对象来自包含上下文，再下一个对象来自再下一个包含上下文。以此类推直至全局上下文;全局上下文的变量对象始终是作用域链的最后一个变量对象”，那么函数被调用时也会产生一个上下文从而创建一个作用域链，并使用arguments和参数来初始化它的活动对象。外部函数的活动对象是内部函数作用域链上的第二个对象。这个作用域链一直向外串起了所有包含函数的活动对象，直到全局执行上下文才终止。而如果函数在另一个函数内部定义，那么它会把包含函数的活动对象添加到自己的作用域链中，这样，内部函数就能访问外部函数能访问到的所有变量了。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  </p>
<p>不过这样的话也意味着闭包会保留它们包含函数的作用域，所以比其他函数更占内存。过度使用闭包可能会导致内存过度被占用，所以使用一定要谨慎。</p>
<h6 id="词法环境"><a href="#词法环境" class="headerlink" title="词法环境"></a>词法环境</h6><p>JavaScript中的变量其实是一个叫做“环境记录（Environment Record）”的内部对象的一个属性。JavaScript中每个运行的函数、代码块及整个脚本都有一个叫做<strong>词法环境（Lexical Environnment）</strong>的内部对象，用来记录局部变量和其他一些信息如this等。词法环境由环境记录对象和对外部词法环境的引用两部分组成。</p>
<blockquote>
<p>就代码块来说，理论上来说如果一个变量只存在于一个代码块里，那么在代码块外部是没有办法访问它的。但是实际上只有严格模式下会出现这种情况，非严格模式下代码块外部是可以访问代码块内部的变量的。</p>
</blockquote>
<p>例如，假设脚本中只有<code>let phrase = &#39;Hello&#39;</code>这段代码，那么这个脚本中只有一个词法环境——全局词法环境，它有一个属性名为phrase，其值为字符串’Hello’。全局词法环境没有外部引用，可以认为其外部引用指向<code>null</code>。</p>
<p>可见获取和修改变量其实是在获取和修改词法环境对象的相应属性。</p>
<blockquote>
<p>“词法环境”是一个规范对象（specification object）：它仅仅是 <strong>编程语言规范</strong> 中的“理论上”存在的，用于描述事物如何运作的对象。我们无法在代码中获取该对象并直接对其进行操作。</p>
<p>但 JavaScript 引擎同样可以优化它，比如清除未被使用的变量以节省内存和执行其他内部技巧等，但显性行为应该是和上述的无差。</p>
</blockquote>
<p>对于函数而言，由于函数声明提升，当词法环境对象被创建时其相应的函数属性就已经被初始化了（普通变量要等到执行到变量声明处才会被初始化），这就是为什么我们可以在函数定义前调用函数。注意函数表达式不会提升。</p>
<p>在一个函数运行时，在调用刚开始时，会自动创建一个新的词法环境以存储这个调用的局部变量和参数。在这个函数调用期间，我们有两个词法环境：函数内部一个（用于函数调用）和函数外部一个（如全局）。内部词法环境会引用外部的词法环境。</p>
<p><strong>当代码要访问一个变量时，首先会搜索内部词法环境，然后搜索外部环境，然后搜索更外部的环境，以此类推，直到全局词法环境。</strong></p>
<p>如果在任何地方都找不到这个变量，那么在严格模式下就会报错（在非严格模式下，为了向下兼容，给未定义的变量赋值会创建一个全局变量）。</p>
<p>所有函数在创建时都会记住创建它们的词法环境，因为所有函数都有名为[[Environment]]的隐藏属性，该属性保存了对创建该函数的词法环境的引用，且是永久保存。</p>
<p>这样的话，在嵌套函数中如果内部函数返回了一个函数，那么这个函数将记住创建自己的词法环境——内部函数的词法环境，并保存了对内部函数词法环境的引用。而且这个被返回函数的外部词法环境也是内部函数的词法环境。</p>
<p>所以被返回函数能够引用到内部函数的局部变量就是因为它可以搜索到内部函数的词法环境；而能够在多次调用中保存上一次修改变量的值是因为内部函数的词法环境对象一直存在着，那么它的属性被修改了当然可以一直保存着了。只不过如果又创建了另外一个变量并将被返回函数赋给它的话这个变量的词法环境和之前的那个对象是独立的，因此这两个被返回函数彼此之间是互相独立的。</p>
<p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeCounter</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> count++;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> counter = <span class="title function_">makeCounter</span>();</span><br><span class="line"><span class="title function_">counter</span>();<span class="comment">//1</span></span><br><span class="line"><span class="title function_">counter</span>();<span class="comment">//2</span></span><br><span class="line"><span class="keyword">let</span> annotherCounter = <span class="title function_">makeCounter</span>();</span><br><span class="line"><span class="title function_">annotherCounter</span>();<span class="comment">//1</span></span><br><span class="line"><span class="title function_">annotherCounter</span>();<span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Closure_(computer_programming)">闭包</a> 是指内部函数总是可以访问其所在的外部函数中声明的变量和参数，即使在其外部函数执行完（寿命终结）了之后。在某些编程语言中，这是不可能的，或者应该以特殊的方式编写函数来实现。但是如上所述，在 JavaScript 中，所有函数都是天生闭包的（只有一个例外，将在 <a target="_blank" rel="noopener" href="https://zh.javascript.info/new-function">“new Function” 语法</a> 中讲到）。</p>
<p>也就是说：JavaScript 中的函数会自动通过隐藏的 <code>[[Environment]]</code> 属性记住创建它们的位置，所以它们都可以访问外部变量。</p>
<p>在面试时，前端开发者通常会被问到“什么是闭包？”，正确的回答应该是闭包的定义，并解释清楚为什么 JavaScript 中的所有函数都是闭包的，以及可能的关于 <code>[[Environment]]</code> 属性和词法环境原理的技术细节。</p>
</blockquote>
<p>关于词法环境的一个很好的题目：</p>
<p><strong>函数大军</strong></p>
<p>下列的代码创建了一个 <code>shooters</code> 数组。</p>
<p>每个函数都应该输出其编号。但好像出了点问题……</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeArmy</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> shooters = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> shooter = <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">// 创建一个 shooter 函数，</span></span><br><span class="line">      <span class="title function_">alert</span>( i ); <span class="comment">// 应该显示其编号</span></span><br><span class="line">    &#125;;</span><br><span class="line">    shooters.<span class="title function_">push</span>(shooter); <span class="comment">// 将此 shooter 函数添加到数组中</span></span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ……返回 shooters 数组</span></span><br><span class="line">  <span class="keyword">return</span> shooters;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> army = <span class="title function_">makeArmy</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ……所有的 shooter 显示的都是 10，而不是它们的编号 0, 1, 2, 3...</span></span><br><span class="line">army[<span class="number">0</span>](); <span class="comment">// 编号为 0 的 shooter 显示的是 10</span></span><br><span class="line">army[<span class="number">1</span>](); <span class="comment">// 编号为 1 的 shooter 显示的是 10</span></span><br><span class="line">army[<span class="number">2</span>](); <span class="comment">// 10，其他的也是这样。</span></span><br></pre></td></tr></table></figure>

<p>为什么所有的 shooter 显示的都是同样的值？</p>
<p>修改代码以使得代码能够按照我们预期的那样工作。</p>
<p>答案：</p>
<p>让我们检查一下 <code>makeArmy</code> 内部到底发生了什么，那样答案就显而易见了。</p>
<ol>
<li><p>它创建了一个空数组 <code>shooters</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> shooters = [];</span><br></pre></td></tr></table></figure>
</li>
<li><p>在循环中，通过 <code>shooters.push(function)</code> 用函数填充它。</p>
<p>每个元素都是函数，所以数组看起来是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">shooters = [</span><br><span class="line">  <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="title function_">alert</span>(i); &#125;,</span><br><span class="line">  <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="title function_">alert</span>(i); &#125;,</span><br><span class="line">  <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="title function_">alert</span>(i); &#125;,</span><br><span class="line">  <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="title function_">alert</span>(i); &#125;,</span><br><span class="line">  <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="title function_">alert</span>(i); &#125;,</span><br><span class="line">  <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="title function_">alert</span>(i); &#125;,</span><br><span class="line">  <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="title function_">alert</span>(i); &#125;,</span><br><span class="line">  <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="title function_">alert</span>(i); &#125;,</span><br><span class="line">  <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="title function_">alert</span>(i); &#125;,</span><br><span class="line">  <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="title function_">alert</span>(i); &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
</li>
<li><p>该数组返回自函数。</p>
<p>然后，对数组中的任意数组项的调用，例如调用 <code>army[5]()</code>（它是一个函数），将首先从数组中获取元素 <code>army[5]()</code> 并调用它。</p>
<p>那么，为什么所有此类函数都显示的是相同的值，<code>10</code> 呢？</p>
<p>这是因为 <code>shooter</code> 函数内没有局部变量 <code>i</code>。当一个这样的函数被调用时，<code>i</code> 是来自于外部词法环境的。</p>
<p>那么，<code>i</code> 的值是什么呢？</p>
<p>如果我们看一下源代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeArmy</span>(<span class="params"></span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> shooter = <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">// shooter 函数</span></span><br><span class="line">      <span class="title function_">alert</span>( i ); <span class="comment">// 应该显示它自己的编号</span></span><br><span class="line">    &#125;;</span><br><span class="line">    shooters.<span class="title function_">push</span>(shooter); <span class="comment">// 将 shooter 函数添加到该数组中</span></span><br><span class="line">      i++;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>……我们可以看到，所有的 <code>shooter</code> 函数都是在 <code>makeArmy()</code> 的词法环境中被创建的。但当 <code>army[5]()</code> 被调用时，<code>makeArmy</code> 已经运行完了，最后 <code>i</code> 的值为 <code>10</code>（<code>while</code> 循环在 <code>i=10</code> 时停止）。</p>
<p>因此，所有的 <code>shooter</code> 函数获得的都是外部词法环境中的同一个值，即最后的 <code>i=10</code>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="E:/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/JavaScript/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01.assets/image-20220331181701067.png" alt="image-20220331181701067"></p>
<p>正如你在上边所看到的那样，在 <code>while &#123;...&#125;</code> 块的每次迭代中，都会创建一个新的词法环境。因此，要解决此问题，我们可以将 <code>i</code> 的值复制到 <code>while &#123;...&#125;</code> 块内的变量中，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeArmy</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> shooters = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> j = i;</span><br><span class="line">      <span class="keyword">let</span> shooter = <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">// shooter 函数</span></span><br><span class="line">        <span class="title function_">alert</span>( j ); <span class="comment">// 应该显示它自己的编号</span></span><br><span class="line">      &#125;;</span><br><span class="line">    shooters.<span class="title function_">push</span>(shooter);</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> shooters;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> army = <span class="title function_">makeArmy</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在代码正确运行了</span></span><br><span class="line">army[<span class="number">0</span>](); <span class="comment">// 0</span></span><br><span class="line">army[<span class="number">5</span>](); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<p>在这里，<code>let j = i</code> 声明了一个“局部迭代”变量 <code>j</code>，并将 <code>i</code> 复制到其中。原始类型是“按值”复制的，因此实际上我们得到的是属于当前循环迭代的独立的 <code>i</code> 的副本。</p>
<p>shooter 函数正确运行了，因为 <code>i</code> 值的位置更近了（译注：指转到了更内部的词法环境）。不是在 <code>makeArmy()</code> 的词法环境中，而是在与当前循环迭代相对应的词法环境中：</p>
<p>如果我们一开始使用 <code>for</code> 循环，也可以避免这样的问题，像这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeArmy</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> shooters = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> shooter = <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">// shooter 函数</span></span><br><span class="line">      <span class="title function_">alert</span>( i ); <span class="comment">// 应该显示它自己的编号</span></span><br><span class="line">    &#125;;</span><br><span class="line">    shooters.<span class="title function_">push</span>(shooter);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> shooters;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> army = <span class="title function_">makeArmy</span>();</span><br><span class="line"></span><br><span class="line">army[<span class="number">0</span>](); <span class="comment">// 0</span></span><br><span class="line">army[<span class="number">5</span>](); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<p>这本质上是一样的，因为 <code>for</code> 循环在每次迭代中，都会生成一个带有自己的变量 <code>i</code> 的新词法环境。因此，在每次迭代中生成的 <code>shooter</code> 函数引用的都是自己的 <code>i</code>。</p>
</li>
</ol>
<p>至此，你已经花了很长时间来阅读本文，发现最终的解决方案就这么简单 — 使用 <code>for</code> 循环，你可能会疑问 —— 我花了这么长时间读这篇文章，值得吗？</p>
<p>其实，如果你可以轻松地明白并答对本题目，你应该就不会阅读它的答案。所以，希望这个题目可以帮助你更好地理解闭包。</p>
<p>此外，确实存在有些人相较于 <code>for</code> 更喜欢 <code>while</code>，以及其他情况。</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h4><ol>
<li><code>new Array()</code>创建数组，new 也可以省略。可以传入一个数字作为数组初始的长度；也可以传入一系列元素作为数组里初始的元素。（这就导致有时候会出现一些奇怪的现象，比如想创建只有一个数字元素的数组的时候）</li>
<li>数组字面量创建数组。</li>
<li><code>Array.from()</code>（ES6新增）将类数组结构、Set和Map转换为数组，即任何可迭代结构（如字符串、集合、映射等）或有一个length属性和可索引元素的结构。如果传入数组，将对该数组进行浅复制（只拷贝指向元素的引用）。该方法还可以接收第二个参数，即一个函数表达式或者箭头函数，可以直接增强新数组的值；还可以接收第三个参数，用于改写第二个参数内部this的值，当然这个对于箭头函数是不会生效的。</li>
<li><code>Array.of()</code>（ES6新增）将一组参数转换为数组。</li>
</ol>
<blockquote>
<p>关于类数组，其实就是一个拥有length属性且值为总元素数-1的且其他元素的键都是从0开始顺次数下来的数字的对象。根据这个特征我们也可以手动自定义类数组：</p>
<p><code>&#123;0: &#39;0&#39;, 1: &#39;1&#39;, 2: &#39;2&#39;, length: 3&#125;</code></p>
<p>在ES6之前，将类数组转化为数组的方法为<code>Array.prototype.slice.apply(fakeArr)</code>。</p>
</blockquote>
<h4 id="数组空位"><a href="#数组空位" class="headerlink" title="数组空位"></a>数组空位</h4><p>数组空位，即<code>[, , , , , ]</code>这种创建数组字面量时插入逗号留出来的空位。ES6新增方法将这些空位视为值为undefined的元素，而在这之前的方法都将忽略这些空位，但具体行为因方法而异，如map（）将跳过空位，而join（）将其视为空字符串。</p>
<h4 id="数组索引"><a href="#数组索引" class="headerlink" title="数组索引"></a>数组索引</h4><p>数组是动态变化的，可以通过中括号语法实现对数组的增添和修改。在增添的时候可以跳位添加，比如一个只有三个元素的数组，但是可以直接设置其索引为99的位置为某个值，此时数组的length将直接更新为100，而中间索引为3~98的位置的值都是undefined。</p>
<p>还可以通过改变数组length属性的值来给数组末尾删除或者添加值。添加的值为undefined。</p>
<h4 id="判断一个变量是否为数组"><a href="#判断一个变量是否为数组" class="headerlink" title="判断一个变量是否为数组"></a>判断一个变量是否为数组</h4><ol>
<li><code>instanceof</code>操作符，判断其是否为Array类型的实例。前提：必须在同一个全局上下文中进行判断。</li>
<li>判断<code>Object.prototype.toString.call(arr)</code>的返回值是否为字符串<code>&quot;Array&quot;</code>。</li>
<li>ES6 新增的 <code>Array.isArray()</code>方法，可以直接最终判定一个变量是不是数组。</li>
</ol>
<h4 id="迭代数组"><a href="#迭代数组" class="headerlink" title="迭代数组"></a>迭代数组</h4><p>ES6新增方法。</p>
<p>keys()返回数组索引的迭代器，values()返回数组元素的迭代器，而 entries()返回 索引&#x2F;值对的迭代器。（每个索引值对都存储在一个数组中，所有的索引值对数组组成了整个的大数组）</p>
<p>迭代器即可迭代对象，可以使用<code>Array.from()</code>方法转换为数组。</p>
<h4 id="填充数组（将数组中的元素批量替换为指定值）"><a href="#填充数组（将数组中的元素批量替换为指定值）" class="headerlink" title="填充数组（将数组中的元素批量替换为指定值）"></a>填充数组（将数组中的元素批量替换为指定值）</h4><p>fill（）方法接收三个参数，第一个是用于填充数组的值，后面两个是可选参数，是填充的范围，即填充开始位置和填充结束位置，默认从开头填充到结尾。如果传递了这两个参数，则包含开始索引而不包括结束索引。</p>
<p>fill（）方法会忽略全部超出数组边界、没有长度、方向反向的索引范围，即此时 fill 方法不起作用；如果索引范围只是部分超过数组边界，那么将只填充可用部分。</p>
<p>fill（）方法会原地修改原数组。</p>
<p>copyWithin（）方法按照参数指定范围浅复制数组中的一部分并插入到参数指定的位置。它接收三个参数，第一个是复制之后插入的起始位置，支持负索引；后面两个是可选的，是复制的范围，默认从开始复制到结尾（即第二个参数默认为0，第三个参数默认为数组的length）。如果传递了这两个参数，则包含开始索引而不包括结束索引。</p>
<p>copyWithin（）方法会忽略全部超出数组边界、没有长度、方向反向的索引范围，即此时 copyWithin 方法不起作用；如果索引范围只是部分超过数组边界，那么将只复制、填充可用部分。</p>
<blockquote>
<p>copyWithin这个方法不是很常用。</p>
</blockquote>
<h4 id="将数组转换为字符串"><a href="#将数组转换为字符串" class="headerlink" title="将数组转换为字符串"></a>将数组转换为字符串</h4><ol>
<li>toString()方法：返回数组中的每个元素以逗号为分隔符拼接在一起的字符串。</li>
</ol>
<blockquote>
<p>所有对象都有toString（）方法和valueOf（）方法，其中valueOf（）方法返回的还是数组本身。</p>
</blockquote>
<ol start="2">
<li>join()方法：接收一个参数，作为字符串的分隔符（默认为逗号），然后以此为分隔符将数组中的元素拼接成一个字符串并返回。</li>
</ol>
<blockquote>
<p>如果数组中某一项是 null 或 undefined，则在 join()、toLocaleString()、 toString()和 valueOf()返回的结果中会以空字符串表示。</p>
</blockquote>
<h4 id="打平数组（高维数组扁平化为低维数组）"><a href="#打平数组（高维数组扁平化为低维数组）" class="headerlink" title="打平数组（高维数组扁平化为低维数组）"></a>打平数组（高维数组扁平化为低维数组）</h4><p>ES6的flat()方法可以将多维数组扁平化，接收一个数字或常量<code>Infinity</code>作为参数，前者表示打平n层（从外向内打平），后者表示去掉所有嵌套打平为一维数组。参数有默认值，为1，即默认打平1层。</p>
<p>ES6之前打平数组的方法（递归实现，想控制打平层数的话应该需要控制递归层数）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">flatArr</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> resultArr = [];</span><br><span class="line">    arr.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">item</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> str = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(item); <span class="comment">// 判断该元素是否为数组，是就接着打平再拼接，否就直接参加拼接</span></span><br><span class="line">        <span class="keyword">if</span> (str.<span class="title function_">indexOf</span>(<span class="string">&quot;Array&quot;</span>) !== -<span class="number">1</span>) &#123;</span><br><span class="line">            resultArr = resultArr.<span class="title function_">concat</span>(<span class="title function_">flatArr</span>(item));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resultArr = resultArr.<span class="title function_">concat</span>(item)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> resultArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>]], <span class="number">4</span>, [<span class="number">5</span>]];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">flatArr</span>(arr));</span><br></pre></td></tr></table></figure>

<h4 id="向数组中增加元素"><a href="#向数组中增加元素" class="headerlink" title="向数组中增加元素"></a>向数组中增加元素</h4><ol>
<li>栈方法：push（），接收任意数量的参数并将它们添加到数组的末尾，并返回数组的最新长度。</li>
<li>队列方法：unshift（），接收任意数量的参数并将它们添加到数组的开头，并返回数组的最新长度。（与pop方法配合可将数组当作反向的队列使用）</li>
<li>拼接数组：concat（）方法，它首先会创建一个当前数组的副本，然后再把它的参数添加到副本末尾，最后返回这个新构建的数组。如果传入一个或多个数组，则 concat()会把这些数组的每一项都添加到结果数组。 如果参数不是数组，则直接把它们添加到结果数组末尾。concat（）方法默认会打平数组，即如果参数是数组的话添加时会自动把数组扩展。要想强制不打平数组，可以通过设置<code>arr[Symbol.isConcatSpreadable]=false;</code>来实现（不过这样的话插入的数组中也会多这么一项）。而将该符号值设置为true可以强制打平数组（插入的元素中不会多这么一项）。</li>
<li>splice（）方法：当给它传递三个及以上的参数时可以实现向数组中插入元素：开始位置、0（要删除的元素数量）和要插入的元素，可以在数组中指定的位置插入元素。第三个参数之后还可以传第四个、第五个参数，乃至任意多个要插入的元素。</li>
</ol>
<h4 id="从数组中删除元素"><a href="#从数组中删除元素" class="headerlink" title="从数组中删除元素"></a>从数组中删除元素</h4><ol>
<li>栈方法：pop（），删除数组的最后一项，并返回被删除的项。（与push方法配合使用可将数组当作栈使用）</li>
<li>队列方法：shift（），删除数组的第一项，并返回被删除的项。（与push方法配合使用可将数组当作队列使用）</li>
<li>splice（）方法：当只给它传递两个参数时可以实现从数组中删除元素：要删除的第一个元素的位置和要删除的元素数量。</li>
</ol>
<h4 id="将数组反向排列"><a href="#将数组反向排列" class="headerlink" title="将数组反向排列"></a>将数组反向排列</h4><p>reverse（）方法可以将数组元素反向排列，且是原地修改数组。</p>
<h4 id="将数组按一定的大小顺序排列"><a href="#将数组按一定的大小顺序排列" class="headerlink" title="将数组按一定的大小顺序排列"></a>将数组按一定的大小顺序排列</h4><p>sort（）方法接收一个函数（可以是函数名或者箭头函数形式）作为参数，函数是比较函数，接收两个参数，如果第一个参数应该排在第二个参数前面，就返回负值；如果两个参数相等，就返回 0；如果第一个参数应该排在第二个参数后面，就返回正值。</p>
<p>默认情况下sort（）方法会按照升序排列数组元素，且会对每一项调用String（）转型函数转换为字符串然后根据字符串排列顺序，即使是数字也是如此。</p>
<p>sort（）方法原地修改数组。</p>
<h4 id="数组切片"><a href="#数组切片" class="headerlink" title="数组切片"></a>数组切片</h4><p>slice（）方法可以从数组中切取一部分子数组出来，其接收两个参数，一个是开始索引，一个是结束索引，如果不传递第二个参数则默认切到数组结尾；如果传递了第二个参数则包括开始索引而不包括结束索引。该方法为非原地修改。</p>
<p>负数参数会被认为是负索引；如果切片方向反向的话将返回空数组。</p>
<h4 id="替换数组中的部分元素（也可以替换后再接着插入）"><a href="#替换数组中的部分元素（也可以替换后再接着插入）" class="headerlink" title="替换数组中的部分元素（也可以替换后再接着插入）"></a>替换数组中的部分元素（也可以替换后再接着插入）</h4><p>splice（）方法接收三个参数：开始位置、要删除元素的数量和要插入的任意多个元素。要插入的元素数量不一定跟删除的元素数量一致。如果一致那就是替换，如果不一致那就是替换后再接着插入。</p>
<h4 id="查找数组中的元素"><a href="#查找数组中的元素" class="headerlink" title="查找数组中的元素"></a>查找数组中的元素</h4><ol>
<li>indexOf()、lastIndexOf()和 includes()。其中，前两个方法在所有版本中都可用，而第三个方法是 ECMAScript 7 新增的（但是现在连QQ&#x2F;百度&#x2F;UC浏览器都支持了，所以放心大胆的用吧）。这些方法都接收两个参数：要查找的元素和一个可选的起始搜索位置。indexOf()和 includes()方法从数组前头（第一项） 开始向后搜索，而 lastIndexOf()从数组末尾（最后一项）开始向前搜索。 indexOf()和 lastIndexOf()都返回要查找的元素在数组中的位置，如果没找到则返回 -1。 includes()返回布尔值，表示是否至少找到一个与指定元素匹配的项。在比较第一个参数跟数组每一项时，会使用全等（&#x3D;&#x3D;&#x3D;）比较，也就是说两项必须严格相等。</li>
<li>find()和 findIndex()方法这两个方法的第一个参数是一个断言函数，断言函数接收 3 个参数：元素、索引和数组本身。其中元素是数组中当前搜索的元素，索引是当前元素的索引，而数组就是正在搜索的数组。断言函数返回真值，表示是否匹配。这两个方法都从数组的最小索引开始。find()返回第一个匹配的元素，findIndex()返回第一个匹配元素的索引。当找到匹配的元素后，这两个方法都不会再继续搜索。这两个方法也都接收第二个可选的参数， 用于指定断言函数内部 this 的值。</li>
</ol>
<h4 id="数组迭代方法"><a href="#数组迭代方法" class="headerlink" title="数组迭代方法"></a>数组迭代方法</h4><p>ECMAScript为数组定义了5个迭代方法。每个方法接收两个参数：以数组中的每一项为参数运行的函数， 以及可选的作为函数运行上下文的作用域对象（影响函数中 this 的值）。传给每个方法的函数接收 3 个参数：数组元素、元素索引和数组本身。</p>
<ol>
<li>every()：对数组每一项都运行传入的函数，如果对每一项函数都返回 true，则这个方法返回 true。（判断数组中是否所有元素都满足条件）</li>
<li>filter()：对数组每一项都运行传入的函数，函数返回 true 的项会组成数组之后返回。（过滤）</li>
<li>forEach()：对数组每一项都运行传入的函数，没有返回值。</li>
<li>map()：对数组每一项都运行传入的函数，返回由每次函数调用的结果构成的数组。（映射）</li>
<li>some()：对数组每一项都运行传入的函数，如果有一项函数返回 true，则这个方法返回 true。（判断数组中是否至少存在一个元素满足条件）</li>
</ol>
<p>这些方法都不改变调用它们的数组。</p>
<h4 id="数组归并方法"><a href="#数组归并方法" class="headerlink" title="数组归并方法"></a>数组归并方法</h4><p>ECMAScript 为数组提供了两个归并方法：reduce()和 reduceRight()。reduce()方法从数组第一项开始遍历到最后一项，而 reduceRight()从最后一项开始遍历至第一项。这两个方法除了方向相反之外没有什么区别。</p>
<p>这两个方法都接收两个参数：对每一项都会运行的归并函数，以及可选的以之为归并起点的初始值。传给 reduce()和 reduceRight()的函数接收 4 个参数：上一个归并值、当前项、当前项的索引和数组本身。这个函数返回的任何值都会作为下一次调用同一个函数的第一个参数。如果没有给这两个方法传入可选的第二个参数（作为归并起点值），则第一次迭代将从数组的第二项开始，因此传给归并函数的第一个参数是数组的第一项，第二个参数是数组的第二项。</p>
<h3 id="日期与时间"><a href="#日期与时间" class="headerlink" title="日期与时间"></a>日期与时间</h3><h4 id="创建时间对象"><a href="#创建时间对象" class="headerlink" title="创建时间对象"></a>创建时间对象</h4><p><code>new Date()</code>：创建一个表示当前日期和时间（UTC格式）的Date对象。</p>
<p><code>new Date(milliseconds)</code>：创建一个自1970年1月1日（UTC+0）后经过milliseconds毫秒后的时间对象。这个整数参数就是时间戳。如果时间在标准日期前面的话时间戳就是负值。</p>
<p><code>new Date(datestring)</code>：根据传入的时间字符串来创建对应的时间对象。</p>
<p><code>new Date(year, month, date, hours, minutes, seconds, ms)</code>：使用当前时区中的给定组件创建日期。只有前两个参数是必须的。</p>
<ul>
<li><code>year</code> 必须是四位数：<code>2013</code> 是合法的，<code>98</code> 是不合法的。</li>
<li><code>month</code> 计数从 <code>0</code>（一月）开始，到 <code>11</code>（十二月）结束。</li>
<li><code>date</code> 是当月的具体某一天，如果缺失，则为默认值 <code>1</code>。</li>
<li>如果 <code>hours/minutes/seconds/ms</code> 缺失，则均为默认值 <code>0</code>。</li>
</ul>
<h4 id="时间对象的方法"><a href="#时间对象的方法" class="headerlink" title="时间对象的方法"></a>时间对象的方法</h4><h5 id="获取时间"><a href="#获取时间" class="headerlink" title="获取时间"></a>获取时间</h5><p><code>getFullYear()</code>：获取四位数年份</p>
<blockquote>
<p>很多 JavaScript 引擎都实现了一个非标准化的方法 <code>getYear()</code>。不推荐使用这个方法。它有时候可能会返回 2 位的年份信息。永远都不要使用它。要获取年份就使用 <code>getFullYear()</code>。</p>
</blockquote>
<p><code>getMonth()</code>：获取月份，月份从0-11</p>
<p><code>getDate()</code>：获取当月的日期，从1-31</p>
<p><code>getHours()，getMinutes()，getSeconds()，getMilliseconds()</code></p>
<p>获取相应的时间组件</p>
<p><code>getDay()</code>：获取一周中的第几天，从 <code>0</code>（星期日）到 <code>6</code>（星期六）。第一天始终是星期日，在某些国家可能不是这样的习惯，但是这不能被改变。</p>
<p><strong>以上的所有方法返回的组件都是基于当地时区的。</strong></p>
<p>当然，也有与当地时区的 UTC 对应项，它们会返回基于 UTC+0 时区的日、月、年等：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/getUTCFullYear">getUTCFullYear()</a>，<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/getUTCMonth">getUTCMonth()</a>，<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/getUTCDay">getUTCDay()</a>。只需要在 <code>&quot;get&quot;</code> 之后插入 <code>&quot;UTC&quot;</code> 即可。</p>
<p>还有两个没有UTC变体的方法：</p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/getTime">getTime()</a></p>
<p>返回日期的时间戳 —— 从 1970-1-1 00:00:00 UTC+0 开始到现在所经过的毫秒数。</p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/getTimezoneOffset">getTimezoneOffset()</a></p>
<p>返回 UTC 与本地时区之间的时差，以分钟为单位。</p>
<p>还有一个方法可以从字符串中解析出时间戳：</p>
<p><code>Date.parse(str)</code>，返回的是相应日期的时间戳。</p>
<p>字符串的格式应该是<code>YYYY-MM-DDTHH:mm:ss.sssZ</code>。其中T是一个分隔符，Z为<code>+/-hh:mm</code>格式的相对于UTC+0的时区，单个Z表示UTC+0。</p>
<p>字符串不一定要全部写出来，可以只写前面的一部分。</p>
<p>如果字符串格式不正确，将返回NaN。</p>
<h5 id="设置时间"><a href="#设置时间" class="headerlink" title="设置时间"></a>设置时间</h5><p>下列方法可以设置日期&#x2F;时间组件：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/setFullYear"><code>setFullYear(year, [month], [date])</code></a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/setMonth"><code>setMonth(month, [date])</code></a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/setDate"><code>setDate(date)</code></a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/setHours"><code>setHours(hour, [min], [sec], [ms])</code></a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/setMinutes"><code>setMinutes(min, [sec], [ms])</code></a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/setSeconds"><code>setSeconds(sec, [ms])</code></a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/setMilliseconds"><code>setMilliseconds(ms)</code></a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/setTime"><code>setTime(milliseconds)</code></a>（使用自 1970-01-01 00:00:00 UTC+0 以来的毫秒数来设置整个日期）</li>
</ul>
<p>以上方法除了 <code>setTime()</code> 都有 UTC 变体，例如：<code>setUTCHours()</code>。</p>
<h5 id="自动校准"><a href="#自动校准" class="headerlink" title="自动校准"></a>自动校准</h5><p>这是Date对象的一个特性，如果我们设置了一些不合理的时间值，它会帮我们自动校正到正确的时间值。</p>
<h4 id="测量时间技巧"><a href="#测量时间技巧" class="headerlink" title="测量时间技巧"></a>测量时间技巧</h4><ol>
<li><p><code>let start = new Date();...let end = new Date();let duration = end - start;</code></p>
</li>
<li><p><code>let start = Date.now();..let end  = Date.now();let duration = end - start;</code></p>
<p>Date.now()方法会返回当前相对于1970&#x2F;1&#x2F;1 00：00：00（UTC+0）的时间戳。这个方法由于方便以及性能较好而常用。</p>
</li>
</ol>
<p>如果需要更加精准的时间度量，JavaScript本身不能测量微秒，但是大多数运行环境提供了相应的方法，如浏览器的<code>performance.now()</code>给出从页面加载开始的以毫秒为单位的微秒数（精确到毫秒的小数点后三位），Node.js的microtime模块，等等。</p>
<h3 id="Json"><a href="#Json" class="headerlink" title="Json"></a>Json</h3><p>理解 JSON 最关键的一点是要把它当成一种数据格式，而不是编程语言。JSON 不属于 JavaScript， 它们只是拥有相同的语法而已。JSON 也不是只能在 JavaScript 中使用，它是一种通用数据格式。很多语言都有解析和序列化 JSON 的内置能力。</p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>JSON 语法支持表示 3 种类型的值。</p>
<ul>
<li>简单值：字符串、数值、布尔值和 null 可以在 JSON 中出现，就像在 JavaScript 中一样。特殊值 undefined 不可以。 </li>
<li>对象：第一种复杂数据类型，对象表示有序键&#x2F;值对。每个值可以是简单值，也可以是复杂类型。</li>
<li>数组：第二种复杂数据类型，数组表示可以通过数值索引访问的值的有序列表。数组的值可以 是任意类型，包括简单值、对象，甚至其他数组。</li>
</ul>
<p>JSON 没有变量、函数或对象实例的概念。JSON 的所有记号都只为表示结构化数据，虽然它借用了 JavaScript 的语法，但是千万不要把它跟 JavaScript 语言混淆。</p>
<h5 id="简单值"><a href="#简单值" class="headerlink" title="简单值"></a>简单值</h5><p>最简单的 JSON 可以是一个数值。例如，下面这个数值是有效的 JSON： </p>
<p>5  </p>
<p>这个 JSON 表示数值 5。类似地，下面这个字符串也是有效的 JSON： </p>
<p>“Hello world!”  </p>
<p>JavaScript 字符串与 JSON 字符串的主要区别是，<strong>JSON 字符串必须使用双引号（单引号会导致语法错误）</strong>。 </p>
<p>布尔值和 null 本身也是有效的 JSON 值。不过，实践中更多使用 JSON 表示比较复杂的数据结构， 其中会包含简单值。</p>
<h5 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h5><p>对象使用与 JavaScript 对象字面量略为不同的方式表示。</p>
<p>用 JSON 表示对象的语法是：</p>
<p> {  </p>
<p>​    “name”: “Nicholas”,  </p>
<p>​    “age”: 29 </p>
<p>}  </p>
<p>与 JavaScript 对象字面量相比，JSON 主要有两处不同。首先，没有变量声明（JSON 中没有变量）。 其次，最后没有分号（因为不是 JavaScript 语句）。同样，用引号将属性名包围起来才是有效的 JSON。属性的值可以是简单值或复杂数据类型值，后者可以在对象中再嵌入对象。同一个对象中不允许出现两个相同的属性，但是同一个对象中的嵌套对象可以使用与外层对象相同的属性名。 </p>
<p>与 JavaScript 不同，<strong>JSON 中的对象属性名必须始终带双引号</strong>。手动编写 JSON 时漏掉这些双引号或使用单引号是常见错误。</p>
<h5 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a>数组</h5><p>不需要变量声明，没有分号，其他和JavaScript数组字面量一样。</p>
<p>对象和数组通常会作为 JSON 数组的顶级结构（尽管不是必需的），以便创建大型复杂数据结构。</p>
<h4 id="解析与序列化"><a href="#解析与序列化" class="headerlink" title="解析与序列化"></a>解析与序列化</h4><h5 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h5><p>序列化是指将JavaScript对象转化为JSON字符串。</p>
<p><code>JSON.stringify(obj)</code>可以实现JavaScript对象的序列化，返回一个JSON字符串。输出结果会省略所有空格、缩进以及函数、原型成员、undefined等任何无效的JSON属性。</p>
<p>JSON.stringify的第二个参数是一个数组，可以使返回结果只包含该数组中列出的对象属性。数组中的元素应当是字符串形式的属性键。第二个参数也可以是一个替代函数<code>(key, value)=&gt;&#123;&#125;</code>，它会对对象中的每一个键值对运行这个函数并返回一个值，这个值将替代原有的值。如果返回undefined，就说明跳过这个键值对。</p>
<p>第三个参数是一个包含一个或多个空格的字符串，控制json字符串的缩进空格数。</p>
<h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><p>解析是指将json字符串转换为JavaScript对象。</p>
<p>JSON字符串可以直接传给JSON.parse（）方法，得到相应的JavaScript对象。如果传入一个无效的JSON字符串会导致报错。如果传入的json字符串是多行的话记得用反引号包裹。</p>
<p>该方法的第二个参数是一个还原函数（reviver），还原函数也接收两个参数，属性名（key）和属性值（value），另外也需要返回值。 如果还原函数返回 undefined，则结果中就会删除相应的键。如果返回了其他任何值，则该值就会成为相应键的值插入到结果中。还原函数经常被用于把日期字符串转换为 Date 对象。</p>
<h3 id="错误处理与调试"><a href="#错误处理与调试" class="headerlink" title="错误处理与调试"></a>错误处理与调试</h3><h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><h5 id="try-catch语句"><a href="#try-catch语句" class="headerlink" title="try-catch语句"></a>try-catch语句</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 可能出错的代码 </span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123; </span><br><span class="line"></span><br><span class="line"> <span class="comment">// 出错时要做什么 </span></span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>error具有两个属性：name和message，分别是错误名称和错误消息。</p>
<p><strong>finally子句</strong></p>
<p>try&#x2F;catch 语句中可选的 finally 子句始终运行。如果 try 块中的代码运行完，则接着执行 finally 块中的代码。如果出错并执行 catch 块中的代码，则 finally 块中的代码仍执行。try 或 catch 块无法阻止 finally 块执行，包括 return 语句。</p>
<p>finally 块的存在导致 try 块中的 return 语句被忽略。注意，只要代码中包含了 finally 子句，try 块或 catch 块中的 return 语句就会被忽略，理解这一点很重要。</p>
<h5 id="抛出错误"><a href="#抛出错误" class="headerlink" title="抛出错误"></a>抛出错误</h5><p>throw操作符会使程序立即停止执行并报错。</p>
<p><strong>自定义错误消息</strong></p>
<p>可以通过内置的错误类型来模拟浏览器错误。每种错误类型的构造函数都只接收一个参数，就是错误消息。下面看一个例子：</p>
<p>throw new Error(“Something bad happened.”);  </p>
<p>以上代码使用一个自定义的错误消息生成了一个通用错误。浏览器会像处理自己生成的错误一样来处理这个自定义错误。换句话说，浏览器会像通常一样报告这个错误，最终显示这个自定义错误。当然， 使用特定的错误类型也是一样的，如以下代码所示：</p>
<p>throw new SyntaxError(“I don’t like your syntax.”); </p>
<p>throw new InternalError(“I can’t do that, Dave.”);  </p>
<p>throw new TypeError(“What type of variable do you take me for?”); </p>
<p>throw new RangeError(“Sorry, you just don’t have the range.”);  </p>
<p>throw new EvalError(“That doesn’t evaluate.”);  </p>
<p>throw new URIError(“Uri, is that you?”);  </p>
<p>throw new ReferenceError(“You didn’t cite your references properly.”); </p>
<p>这样可以自定义错误的消息。</p>
<p><strong>自定义错误类型</strong></p>
<p>此外，通过继承 Error 类型也可以创建自定义的错误类型。创建自定义错误类型时，需要提供 name 属性和 message 属性，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CustomError</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Error</span> &#123;  </span><br><span class="line"></span><br><span class="line">​    <span class="title function_">constructor</span>(<span class="params">message</span>) &#123;  </span><br><span class="line"></span><br><span class="line">​        <span class="variable language_">super</span>(message); </span><br><span class="line"></span><br><span class="line">​        <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;CustomError&quot;</span>; </span><br><span class="line"></span><br><span class="line">​        <span class="variable language_">this</span>.<span class="property">message</span> = message;  </span><br><span class="line"></span><br><span class="line">​    &#125; </span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CustomError</span>(<span class="string">&quot;My message&quot;</span>);  </span><br></pre></td></tr></table></figure>

<p>继承 Error 的自定义错误类型会被浏览器当成其他内置错误类型。自定义错误类型有助于在捕获错误时更准确地区分错误。</p>
<p><strong>assert函数</strong></p>
<p>在大型应用程序中，自定义错误通常使用 assert()函数抛出错误。这个函数接收一个应该为 true 的条件，并在条件为 false 时抛出错误。下面是一个基本的 assert()函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">assert</span>(<span class="params">condition, message</span>) &#123;  </span><br><span class="line"></span><br><span class="line">​    <span class="keyword">if</span> (!condition) &#123;  </span><br><span class="line"></span><br><span class="line">​        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(message);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>这个 assert()函数可用于代替多个 if 语句，同时也是记录错误的好地方。使用 assert()函数可以减少抛出自定义错误所需的代码量，并且让代码更好理解。</p>
<h5 id="error事件"><a href="#error事件" class="headerlink" title="error事件"></a>error事件</h5><p>任何没有被 try&#x2F;catch 语句处理的错误都会在 window 对象上触发 error 事件。该事件是浏览器早期支持的事件，为保持向后兼容，很多浏览器保持了其格式不变。在 onerror 事件处理程序中，任何 浏览器都不会传入 event 对象。相反，会传入 3 个参数：错误消息、发生错误的 URL 和行号。大多数情况下，只有错误消息有用，因为 URL 就是当前文档的地址，而行号可能指嵌入 JavaScript 或外部文件中的代码。另外，onerror 事件处理程序需要使用 DOM Level 0 技术来指定，因为它不遵循 DOM Level 2 Events 标准格式：</p>
<p> window.onerror &#x3D; (message, url, line) &#x3D;&gt; {  console.log(message);  };  </p>
<p>在任何错误发生时，无论是否是浏览器生成的，都会触发 error 事件并执行这个事件处理程序。 然后，浏览器的默认行为就会生效，像往常一样显示这条错误消息。<strong>可以返回 false 来阻止浏览器默认报告错误的行为</strong>，如下所示：</p>
<p> window.onerror &#x3D; (message, url, line) &#x3D;&gt; {  console.log(message);  return false;  };  </p>
<p>通过返回 false，这个函数实际上就变成了整个文档的 try&#x2F;catch 语句，可以捕获所有未处理的运行时错误。这个事件处理程序应该是处理浏览器报告错误的最后一道防线。理想情况下，最好永远不要用到。适当使用 try&#x2F;catch 语句意味着不会有错误到达浏览器这个层次，因此也就不会触发 error 事件。 </p>
<blockquote>
<p>浏览器在使用这个事件处理错误时存在明显差异。在 IE 中发生 error 事件时，正常代码会继续执行，所有变量和数据会保持，且可以在 onerror 事件处理程序中访问。 然而在 Firefox 中，正常代码会执行会终止，错误发生之前的所有变量和数据会被销毁， 导致很难真正分析处理错误。</p>
</blockquote>
<h4 id="调试技术"><a href="#调试技术" class="headerlink" title="调试技术"></a>调试技术</h4><h5 id="把消息记录到控制台"><a href="#把消息记录到控制台" class="headerlink" title="把消息记录到控制台"></a>把消息记录到控制台</h5><p>所有主流浏览器都有 JavaScript 控制台，该控制台可用于查询 JavaScript 错误。另外，这些浏览器都支持通过 console 对象直接把 JavaScript 消息写入控制台，这个对象包含如下方法。 </p>
<ul>
<li>error(message)：在控制台中记录错误消息。</li>
<li>info(message)：在控制台中记录信息性内容。</li>
<li>log(message)：在控制台记录常规消息。</li>
<li>warn(message)：在控制台中记录警告消息。</li>
</ul>
<p>记录消息时使用的方法不同，消息显示的样式也不同。错误消息包含一个红叉图标，而警告消息包含一个黄色叹号图标。</p>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p><code>RegExp</code>对象提供正则表达式的功能。</p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>正则表达式（regular expression）是一种表达文本模式（即字符串结构）的方法，有点像字符串的模板，常常用来按照“给定模式”匹配文本。比如，正则表达式给出一个 Email 地址的模式，然后用它来确定一个字符串是否为 Email 地址。JavaScript 的正则表达式体系是参照 Perl 5 建立的。</p>
<p>新建正则表达式有两种方法。一种是使用字面量，以斜杠表示开始和结束。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/xyz/</span>;</span><br></pre></td></tr></table></figure>

<p>另一种是使用<code>RegExp</code>构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&#x27;xyz&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>上面两种写法是等价的，都新建了一个内容为<code>xyz</code>的正则表达式对象。它们的主要区别是，第一种方法在引擎编译代码时，就会新建正则表达式，第二种方法在运行时新建正则表达式，所以前者的效率较高。而且，前者比较便利和直观，所以实际应用中，基本上都采用字面量定义正则表达式。</p>
<p><code>RegExp</code>构造函数还可以接受第二个参数，表示修饰符（详细解释见下文）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&#x27;xyz&#x27;</span>, <span class="string">&#x27;i&#x27;</span>);</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/xyz/i</span>;</span><br></pre></td></tr></table></figure>

<p>上面代码中，正则表达式<code>/xyz/</code>有一个修饰符<code>i</code>。</p>
<h3 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h3><p>正则对象的实例属性分成两类。</p>
<p>一类是修饰符相关，用于了解设置了什么修饰符。</p>
<ul>
<li><code>RegExp.prototype.ignoreCase</code>：返回一个布尔值，表示是否设置了<code>i</code>修饰符。</li>
<li><code>RegExp.prototype.global</code>：返回一个布尔值，表示是否设置了<code>g</code>修饰符。</li>
<li><code>RegExp.prototype.multiline</code>：返回一个布尔值，表示是否设置了<code>m</code>修饰符。</li>
<li><code>RegExp.prototype.flags</code>：返回一个字符串，包含了已经设置的所有修饰符，按字母排序。</li>
</ul>
<p>上面四个属性都是只读的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="regexp">/abc/igm</span>;</span><br><span class="line"></span><br><span class="line">r.<span class="property">ignoreCase</span> <span class="comment">// true</span></span><br><span class="line">r.<span class="property">global</span> <span class="comment">// true</span></span><br><span class="line">r.<span class="property">multiline</span> <span class="comment">// true</span></span><br><span class="line">r.<span class="property">flags</span> <span class="comment">// &#x27;gim&#x27;</span></span><br></pre></td></tr></table></figure>

<p>另一类是与修饰符无关的属性，主要是下面两个。</p>
<ul>
<li><code>RegExp.prototype.lastIndex</code>：返回一个整数，表示下一次开始搜索的位置。该属性可读写，但是只在进行连续搜索时有意义，详细介绍请看后文。</li>
<li><code>RegExp.prototype.source</code>：返回正则表达式的字符串形式（不包括反斜杠），该属性只读。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="regexp">/abc/igm</span>;</span><br><span class="line"></span><br><span class="line">r.<span class="property">lastIndex</span> <span class="comment">// 0</span></span><br><span class="line">r.<span class="property">source</span> <span class="comment">// &quot;abc&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><h4 id="RegExp-prototype-test"><a href="#RegExp-prototype-test" class="headerlink" title="RegExp.prototype.test()"></a>RegExp.prototype.test()</h4><p>正则实例对象的<code>test</code>方法返回一个布尔值，表示当前模式是否能匹配参数字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/cat/.<span class="title function_">test</span>(<span class="string">&#x27;cats and dogs&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码验证参数字符串之中是否包含<code>cat</code>，结果返回<code>true</code>。</p>
<p>如果正则表达式带有<code>g</code>修饰符，则每一次<code>test</code>方法都从上一次结束的位置开始向后匹配。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="regexp">/x/g</span>;</span><br><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;_x_x&#x27;</span>;</span><br><span class="line"></span><br><span class="line">r.<span class="property">lastIndex</span> <span class="comment">// 0</span></span><br><span class="line">r.<span class="title function_">test</span>(s) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">r.<span class="property">lastIndex</span> <span class="comment">// 2</span></span><br><span class="line">r.<span class="title function_">test</span>(s) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">r.<span class="property">lastIndex</span> <span class="comment">// 4</span></span><br><span class="line">r.<span class="title function_">test</span>(s) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面代码的正则表达式使用了<code>g</code>修饰符，表示是全局搜索，会有多个结果。接着，三次使用<code>test</code>方法，每一次开始搜索的位置都是上一次匹配的后一个位置。</p>
<p>带有<code>g</code>修饰符时，可以通过正则对象的<code>lastIndex</code>属性指定开始搜索的位置。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="regexp">/x/g</span>;</span><br><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;_x_x&#x27;</span>;</span><br><span class="line"></span><br><span class="line">r.<span class="property">lastIndex</span> = <span class="number">4</span>;</span><br><span class="line">r.<span class="title function_">test</span>(s) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">r.<span class="property">lastIndex</span> <span class="comment">// 0</span></span><br><span class="line">r.<span class="title function_">test</span>(s)</span><br></pre></td></tr></table></figure>

<p>上面代码指定从字符串的第五个位置开始搜索，这个位置为空，所以返回<code>false</code>。同时，<code>lastIndex</code>属性重置为<code>0</code>，所以第二次执行<code>r.test(s)</code>会返回<code>true</code>。</p>
<p>注意，带有<code>g</code>修饰符时，正则表达式内部会记住上一次的<code>lastIndex</code>属性，这时不应该更换所要匹配的字符串，否则会有一些难以察觉的错误。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="regexp">/bb/g</span>;</span><br><span class="line">r.<span class="title function_">test</span>(<span class="string">&#x27;bb&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">r.<span class="title function_">test</span>(<span class="string">&#x27;-bb-&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，由于正则表达式<code>r</code>是从上一次的<code>lastIndex</code>位置开始匹配，导致第二次执行<code>test</code>方法时出现预期以外的结果。</p>
<p><code>lastIndex</code>属性只对同一个正则表达式有效，所以下面这样写是错误的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="regexp">/a/g</span>.<span class="title function_">test</span>(<span class="string">&#x27;babaa&#x27;</span>)) count++;</span><br></pre></td></tr></table></figure>

<p>上面代码会导致无限循环，因为<code>while</code>循环的每次匹配条件都是一个新的正则表达式，导致<code>lastIndex</code>属性总是等于0。</p>
<p>如果正则模式是一个空字符串，则匹配所有字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">test</span>(<span class="string">&#x27;abc&#x27;</span>)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h4 id="RegExp-prototype-exec"><a href="#RegExp-prototype-exec" class="headerlink" title="RegExp.prototype.exec()"></a>RegExp.prototype.exec()</h4><p>正则实例对象的<code>exec()</code>方法，用来返回匹配结果。如果发现匹配，就返回一个数组，成员是匹配成功的子字符串，否则返回<code>null</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;_x_x&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> r1 = <span class="regexp">/x/</span>;</span><br><span class="line"><span class="keyword">var</span> r2 = <span class="regexp">/y/</span>;</span><br><span class="line"></span><br><span class="line">r1.<span class="title function_">exec</span>(s) <span class="comment">// [&quot;x&quot;]</span></span><br><span class="line">r2.<span class="title function_">exec</span>(s) <span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，正则对象<code>r1</code>匹配成功，返回一个数组，成员是匹配结果；正则对象<code>r2</code>匹配失败，返回<code>null</code>。</p>
<p>如果正则表示式包含圆括号（即含有“组匹配”），则返回的数组会包括多个成员。第一个成员是整个匹配成功的结果，后面的成员就是圆括号对应的匹配成功的组。也就是说，第二个成员对应第一个括号，第三个成员对应第二个括号，以此类推。整个数组的<code>length</code>属性等于组匹配的数量再加1。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;_x_x&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> r = <span class="regexp">/_(x)/</span>;</span><br><span class="line"></span><br><span class="line">r.<span class="title function_">exec</span>(s) <span class="comment">// [&quot;_x&quot;, &quot;x&quot;]</span></span><br></pre></td></tr></table></figure>

<p>上面代码的<code>exec()</code>方法，返回一个数组。第一个成员是整个匹配的结果，第二个成员是圆括号匹配的结果。</p>
<p><code>exec()</code>方法的返回数组还包含以下两个属性：</p>
<ul>
<li><code>input</code>：整个原字符串。</li>
<li><code>index</code>：模式匹配成功的开始位置（从0开始计数）。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="regexp">/a(b+)a/</span>;</span><br><span class="line"><span class="keyword">var</span> arr = r.<span class="title function_">exec</span>(<span class="string">&#x27;_abbba_aba_&#x27;</span>);</span><br><span class="line"></span><br><span class="line">arr <span class="comment">// [&quot;abbba&quot;, &quot;bbb&quot;]</span></span><br><span class="line"></span><br><span class="line">arr.<span class="property">index</span> <span class="comment">// 1</span></span><br><span class="line">arr.<span class="property">input</span> <span class="comment">// &quot;_abbba_aba_&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中的<code>index</code>属性等于1，是因为从原字符串的第二个位置开始匹配成功。</p>
<p>如果正则表达式加上<code>g</code>修饰符，则可以使用多次<code>exec()</code>方法，下一次搜索的位置从上一次匹配成功结束的位置开始。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/a/g</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;abc_abc_abc&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> r1 = reg.<span class="title function_">exec</span>(str);</span><br><span class="line">r1 <span class="comment">// [&quot;a&quot;]</span></span><br><span class="line">r1.<span class="property">index</span> <span class="comment">// 0</span></span><br><span class="line">reg.<span class="property">lastIndex</span> <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> r2 = reg.<span class="title function_">exec</span>(str);</span><br><span class="line">r2 <span class="comment">// [&quot;a&quot;]</span></span><br><span class="line">r2.<span class="property">index</span> <span class="comment">// 4</span></span><br><span class="line">reg.<span class="property">lastIndex</span> <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> r3 = reg.<span class="title function_">exec</span>(str);</span><br><span class="line">r3 <span class="comment">// [&quot;a&quot;]</span></span><br><span class="line">r3.<span class="property">index</span> <span class="comment">// 8</span></span><br><span class="line">reg.<span class="property">lastIndex</span> <span class="comment">// 9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> r4 = reg.<span class="title function_">exec</span>(str);</span><br><span class="line">r4 <span class="comment">// null</span></span><br><span class="line">reg.<span class="property">lastIndex</span> <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>上面代码连续用了四次<code>exec()</code>方法，前三次都是从上一次匹配结束的位置向后匹配。当第三次匹配结束以后，整个字符串已经到达尾部，匹配结果返回<code>null</code>，正则实例对象的<code>lastIndex</code>属性也重置为<code>0</code>，意味着第四次匹配将从头开始。</p>
<p>利用<code>g</code>修饰符允许多次匹配的特点，可以用一个循环完成全部匹配。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/a/g</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;abc_abc_abc&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> match = reg.<span class="title function_">exec</span>(str);</span><br><span class="line">  <span class="keyword">if</span> (!match) <span class="keyword">break</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;#&#x27;</span> + match.<span class="property">index</span> + <span class="string">&#x27;:&#x27;</span> + match[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// #0:a</span></span><br><span class="line"><span class="comment">// #4:a</span></span><br><span class="line"><span class="comment">// #8:a</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，只要<code>exec()</code>方法不返回<code>null</code>，就会一直循环下去，每次输出匹配的位置和匹配的文本。</p>
<p>正则实例对象的<code>lastIndex</code>属性不仅可读，还可写。设置了<code>g</code>修饰符的时候，只要手动设置了<code>lastIndex</code>的值，就会从指定位置开始匹配。</p>
<h3 id="字符串的实例方法"><a href="#字符串的实例方法" class="headerlink" title="字符串的实例方法"></a>字符串的实例方法</h3><p>字符串的实例方法之中，有4种与正则表达式有关。</p>
<ul>
<li><code>String.prototype.match()</code>：返回一个数组，成员是所有匹配的子字符串。</li>
<li><code>String.prototype.search()</code>：按照给定的正则表达式进行搜索，返回一个整数，表示匹配开始的位置。</li>
<li><code>String.prototype.replace()</code>：按照给定的正则表达式进行替换，返回替换后的字符串。</li>
<li><code>String.prototype.split()</code>：按照给定规则进行字符串分割，返回一个数组，包含分割后的各个成员。</li>
</ul>
<h4 id="String-prototype-match"><a href="#String-prototype-match" class="headerlink" title="String.prototype.match()"></a>String.prototype.match()</h4><p>字符串实例对象的<code>match</code>方法对字符串进行正则匹配，返回匹配结果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;_x_x&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> r1 = <span class="regexp">/x/</span>;</span><br><span class="line"><span class="keyword">var</span> r2 = <span class="regexp">/y/</span>;</span><br><span class="line"></span><br><span class="line">s.<span class="title function_">match</span>(r1) <span class="comment">// [&quot;x&quot;]</span></span><br><span class="line">s.<span class="title function_">match</span>(r2) <span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<p>从上面代码可以看到，字符串的<code>match</code>方法与正则对象的<code>exec</code>方法非常类似：匹配成功返回一个数组，匹配失败返回<code>null</code>。</p>
<p>如果正则表达式带有<code>g</code>修饰符，则该方法与正则对象的<code>exec</code>方法行为不同，会一次性返回所有匹配成功的结果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;abba&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> r = <span class="regexp">/a/g</span>;</span><br><span class="line"></span><br><span class="line">s.<span class="title function_">match</span>(r) <span class="comment">// [&quot;a&quot;, &quot;a&quot;]</span></span><br><span class="line">r.<span class="title function_">exec</span>(s) <span class="comment">// [&quot;a&quot;]</span></span><br></pre></td></tr></table></figure>

<p>设置正则表达式的<code>lastIndex</code>属性，对<code>match</code>方法无效，匹配总是从字符串的第一个字符开始。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="regexp">/a|b/g</span>;</span><br><span class="line">r.<span class="property">lastIndex</span> = <span class="number">7</span>;</span><br><span class="line"><span class="string">&#x27;xaxb&#x27;</span>.<span class="title function_">match</span>(r) <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;]</span></span><br><span class="line">r.<span class="property">lastIndex</span> <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>上面代码表示，设置正则对象的<code>lastIndex</code>属性是无效的。</p>
<h4 id="String-prototype-search"><a href="#String-prototype-search" class="headerlink" title="String.prototype.search()"></a>String.prototype.search()</h4><p>字符串对象的<code>search</code>方法，返回第一个满足条件的匹配结果在整个字符串中的位置。如果没有任何匹配，则返回<code>-1</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;_x_x&#x27;</span>.<span class="title function_">search</span>(<span class="regexp">/x/</span>)</span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，第一个匹配结果出现在字符串的<code>1</code>号位置。</p>
<h4 id="String-prototype-replace"><a href="#String-prototype-replace" class="headerlink" title="String.prototype.replace()"></a>String.prototype.replace()</h4><p>字符串对象的<code>replace</code>方法可以替换匹配的值。它接受两个参数，第一个是正则表达式，表示搜索模式，第二个是替换的内容。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.<span class="title function_">replace</span>(search, replacement)</span><br></pre></td></tr></table></figure>

<p>正则表达式如果不加<code>g</code>修饰符，就替换第一个匹配成功的值，否则替换所有匹配成功的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;aaa&#x27;</span>.<span class="title function_">replace</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>) <span class="comment">// &quot;baa&quot;</span></span><br><span class="line"><span class="string">&#x27;aaa&#x27;</span>.<span class="title function_">replace</span>(<span class="regexp">/a/</span>, <span class="string">&#x27;b&#x27;</span>) <span class="comment">// &quot;baa&quot;</span></span><br><span class="line"><span class="string">&#x27;aaa&#x27;</span>.<span class="title function_">replace</span>(<span class="regexp">/a/g</span>, <span class="string">&#x27;b&#x27;</span>) <span class="comment">// &quot;bbb&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，最后一个正则表达式使用了<code>g</code>修饰符，导致所有的<code>a</code>都被替换掉了。</p>
<p><code>replace</code>方法的一个应用，就是消除字符串首尾两端的空格。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;  #id div.class  &#x27;</span>;</span><br><span class="line"></span><br><span class="line">str.<span class="title function_">replace</span>(<span class="regexp">/^\s+|\s+$/g</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="comment">// &quot;#id div.class&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>replace</code>方法的第二个参数可以使用美元符号<code>$</code>，用来指代所替换的内容。</p>
<ul>
<li><code>$&amp;</code>：匹配的子字符串。</li>
<li><code>$`</code>：匹配结果前面的文本。</li>
<li><code>$&#39;</code>：匹配结果后面的文本。</li>
<li><code>$n</code>：匹配成功的第<code>n</code>组内容，<code>n</code>是从1开始的自然数。</li>
<li><code>$$</code>：指代美元符号<code>$</code>。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;hello world&#x27;</span>.<span class="title function_">replace</span>(<span class="regexp">/(\w+)\s(\w+)/</span>, <span class="string">&#x27;$2 $1&#x27;</span>)</span><br><span class="line"><span class="comment">// &quot;world hello&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>.<span class="title function_">replace</span>(<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;[$`-$&amp;-$\&#x27;]&#x27;</span>)</span><br><span class="line"><span class="comment">// &quot;a[a-b-c]c&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，第一个例子是将匹配的组互换位置，第二个例子是改写匹配的值。</p>
<p><code>replace</code>方法的第二个参数还可以是一个函数，将每一个匹配内容替换为函数返回值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;3 and 5&#x27;</span>.<span class="title function_">replace</span>(<span class="regexp">/[0-9]+/g</span>, <span class="keyword">function</span> (<span class="params">match</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span> * match;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// &quot;6 and 10&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;The quick brown fox jumped over the lazy dog.&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/quick|brown|lazy/ig</span>;</span><br><span class="line"></span><br><span class="line">a.<span class="title function_">replace</span>(pattern, <span class="keyword">function</span> <span class="title function_">replacer</span>(<span class="params">match</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> match.<span class="title function_">toUpperCase</span>();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// The QUICK BROWN fox jumped over the LAZY dog.</span></span><br></pre></td></tr></table></figure>

<p>作为<code>replace</code>方法第二个参数的替换函数，可以接受多个参数。其中，第一个参数是捕捉到的内容，第二个参数是捕捉到的组匹配（有多少个组匹配，就有多少个对应的参数）。此外，最后还可以添加两个参数，倒数第二个参数是捕捉到的内容在整个字符串中的位置（比如从第五个位置开始），最后一个参数是原字符串。下面是一个网页模板替换的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> prices = &#123;</span><br><span class="line">  <span class="string">&#x27;p1&#x27;</span>: <span class="string">&#x27;$1.99&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;p2&#x27;</span>: <span class="string">&#x27;$9.99&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;p3&#x27;</span>: <span class="string">&#x27;$5.00&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> template = <span class="string">&#x27;&lt;span id=&quot;p1&quot;&gt;&lt;/span&gt;&#x27;</span></span><br><span class="line">  + <span class="string">&#x27;&lt;span id=&quot;p2&quot;&gt;&lt;/span&gt;&#x27;</span></span><br><span class="line">  + <span class="string">&#x27;&lt;span id=&quot;p3&quot;&gt;&lt;/span&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">template.<span class="title function_">replace</span>(</span><br><span class="line">  <span class="regexp">/(&lt;span id=&quot;)(.*?)(&quot;&gt;)(&lt;\/span&gt;)/g</span>,</span><br><span class="line">  <span class="keyword">function</span>(<span class="params">match, $<span class="number">1</span>, $<span class="number">2</span>, $<span class="number">3</span>, $<span class="number">4</span></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> $<span class="number">1</span> + $<span class="number">2</span> + $<span class="number">3</span> + prices[$<span class="number">2</span>] + $<span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"><span class="comment">// &quot;&lt;span id=&quot;p1&quot;&gt;$1.99&lt;/span&gt;&lt;span id=&quot;p2&quot;&gt;$9.99&lt;/span&gt;&lt;span id=&quot;p3&quot;&gt;$5.00&lt;/span&gt;&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码的捕捉模式中，有四个括号，所以会产生四个组匹配，在匹配函数中用<code>$1</code>到<code>$4</code>表示。匹配函数的作用是将价格插入模板中。</p>
<h4 id="String-prototype-split"><a href="#String-prototype-split" class="headerlink" title="String.prototype.split()"></a>String.prototype.split()</h4><p>字符串对象的<code>split</code>方法按照正则规则分割字符串，返回一个由分割后的各个部分组成的数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.<span class="title function_">split</span>(separator, [limit])</span><br></pre></td></tr></table></figure>

<p>该方法接受两个参数，第一个参数是正则表达式，表示分隔规则，第二个参数是返回数组的最大成员数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非正则分隔</span></span><br><span class="line"><span class="string">&#x27;a,  b,c, d&#x27;</span>.<span class="title function_">split</span>(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line"><span class="comment">// [ &#x27;a&#x27;, &#x27;  b&#x27;, &#x27;c&#x27;, &#x27; d&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正则分隔，去除多余的空格</span></span><br><span class="line"><span class="string">&#x27;a,  b,c, d&#x27;</span>.<span class="title function_">split</span>(<span class="regexp">/, */</span>)</span><br><span class="line"><span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定返回数组的最大成员</span></span><br><span class="line"><span class="string">&#x27;a,  b,c, d&#x27;</span>.<span class="title function_">split</span>(<span class="regexp">/, */</span>, <span class="number">2</span>)</span><br><span class="line">[ <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span> ]</span><br></pre></td></tr></table></figure>

<p>上面代码使用正则表达式，去除了子字符串的逗号后面的空格。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="string">&#x27;aaa*a*&#x27;</span>.<span class="title function_">split</span>(<span class="regexp">/a*/</span>)</span><br><span class="line"><span class="comment">// [ &#x27;&#x27;, &#x27;*&#x27;, &#x27;*&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="string">&#x27;aaa**a*&#x27;</span>.<span class="title function_">split</span>(<span class="regexp">/a*/</span>)</span><br><span class="line"><span class="comment">// [&quot;&quot;, &quot;*&quot;, &quot;*&quot;, &quot;*&quot;]</span></span><br></pre></td></tr></table></figure>

<p>上面代码的分割规则是0次或多次的<code>a</code>，由于正则默认是贪婪匹配，所以例一的第一个分隔符是<code>aaa</code>，第二个分割符是<code>a</code>，将字符串分成三个部分，包含开始处的空字符串。例二的第一个分隔符是<code>aaa</code>，第二个分隔符是0个<code>a</code>（即空字符），第三个分隔符是<code>a</code>，所以将字符串分成四个部分。</p>
<p>如果正则表达式带有括号，则括号匹配的部分也会作为数组成员返回。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;aaa*a*&#x27;</span>.<span class="title function_">split</span>(<span class="regexp">/(a*)/</span>)</span><br><span class="line"><span class="comment">// [ &#x27;&#x27;, &#x27;aaa&#x27;, &#x27;*&#x27;, &#x27;a&#x27;, &#x27;*&#x27; ]</span></span><br></pre></td></tr></table></figure>

<p>上面代码的正则表达式使用了括号，第一个组匹配是<code>aaa</code>，第二个组匹配是<code>a</code>，它们都作为数组成员返回。</p>
<h3 id="匹配规则"><a href="#匹配规则" class="headerlink" title="匹配规则"></a>匹配规则</h3><p>正则表达式的规则很复杂，下面一一介绍这些规则。</p>
<h4 id="字面量字符和元字符"><a href="#字面量字符和元字符" class="headerlink" title="字面量字符和元字符"></a>字面量字符和元字符</h4><p>大部分字符在正则表达式中，就是字面的含义，比如<code>/a/</code>匹配<code>a</code>，<code>/b/</code>匹配<code>b</code>。如果在正则表达式之中，某个字符只表示它字面的含义（就像前面的<code>a</code>和<code>b</code>），那么它们就叫做“字面量字符”（literal characters）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/dog/.<span class="title function_">test</span>(<span class="string">&#x27;old dog&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中正则表达式的<code>dog</code>，就是字面量字符，所以<code>/dog/</code>匹配<code>old dog</code>，因为它就表示<code>d</code>、<code>o</code>、<code>g</code>三个字母连在一起。</p>
<p>除了字面量字符以外，还有一部分字符有特殊含义，不代表字面的意思。它们叫做“元字符”（metacharacters），主要有以下几个。</p>
<p><strong>（1）点字符（.)</strong></p>
<p>点字符（<code>.</code>）匹配除回车（<code>\r</code>）、换行(<code>\n</code>) 、行分隔符（<code>\u2028</code>）和段分隔符（<code>\u2029</code>）以外的所有字符。注意，对于码点大于<code>0xFFFF</code>字符，点字符不能正确匹配，会认为这是两个字符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/c.<span class="property">t</span>/</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>c.t</code>匹配<code>c</code>和<code>t</code>之间包含任意一个字符的情况，只要这三个字符在同一行，比如<code>cat</code>、<code>c2t</code>、<code>c-t</code>等等，但是不匹配<code>coot</code>。</p>
<p><strong>（2）位置字符</strong></p>
<p>位置字符用来提示字符所处的位置，主要有两个字符。</p>
<ul>
<li><code>^</code> 表示字符串的开始位置</li>
<li><code>$</code> 表示字符串的结束位置</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test必须出现在开始位置</span></span><br><span class="line">/^test/.<span class="title function_">test</span>(<span class="string">&#x27;test123&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// test必须出现在结束位置</span></span><br><span class="line">/test$/.<span class="title function_">test</span>(<span class="string">&#x27;new test&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从开始位置到结束位置只有test</span></span><br><span class="line">/^test$/.<span class="title function_">test</span>(<span class="string">&#x27;test&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">/^test$/.<span class="title function_">test</span>(<span class="string">&#x27;test test&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p><strong>（3）选择符（<code>|</code>）</strong></p>
<p>竖线符号（<code>|</code>）在正则表达式中表示“或关系”（OR），即<code>cat|dog</code>表示匹配<code>cat</code>或<code>dog</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/<span class="number">11</span>|<span class="number">22</span>/.<span class="title function_">test</span>(<span class="string">&#x27;911&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，正则表达式指定必须匹配<code>11</code>或<code>22</code>。</p>
<p>多个选择符可以联合使用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配fred、barney、betty之中的一个</span></span><br><span class="line">/fred|barney|betty/</span><br></pre></td></tr></table></figure>

<p>选择符会包括它前后的多个字符，比如<code>/ab|cd/</code>指的是匹配<code>ab</code>或者<code>cd</code>，而不是指匹配<code>b</code>或者<code>c</code>。如果想修改这个行为，可以使用圆括号。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/<span class="title function_">a</span>( |\t)b/.<span class="title function_">test</span>(<span class="string">&#x27;a\tb&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码指的是，<code>a</code>和<code>b</code>之间有一个空格或者一个制表符。</p>
<p>其他的元字符还包括<code>\</code>、<code>*</code>、<code>+</code>、<code>?</code>、<code>()</code>、<code>[]</code>、<code>&#123;&#125;</code>等，将在下文解释。</p>
<h4 id="转义符"><a href="#转义符" class="headerlink" title="转义符"></a>转义符</h4><p>正则表达式中那些有特殊含义的元字符，如果要匹配它们本身，就需要在它们前面要加上反斜杠。比如要匹配<code>+</code>，就要写成<code>\+</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/<span class="number">1</span>+<span class="number">1</span>/.<span class="title function_">test</span>(<span class="string">&#x27;1+1&#x27;</span>)</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">/<span class="number">1</span>\+<span class="number">1</span>/.<span class="title function_">test</span>(<span class="string">&#x27;1+1&#x27;</span>)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，第一个正则表达式之所以不匹配，因为加号是元字符，不代表自身。第二个正则表达式使用反斜杠对加号转义，就能匹配成功。</p>
<p>正则表达式中，需要反斜杠转义的，一共有12个字符：<code>^</code>、<code>.</code>、<code>[</code>、<code>$</code>、<code>(</code>、<code>)</code>、<code>|</code>、<code>*</code>、<code>+</code>、<code>?</code>、<code>&#123;</code>和<code>\</code>。需要特别注意的是，如果使用<code>RegExp</code>方法生成正则对象，转义需要使用两个斜杠，因为字符串内部会先转义一次。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&#x27;1\+1&#x27;</span>)).<span class="title function_">test</span>(<span class="string">&#x27;1+1&#x27;</span>)</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">(<span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&#x27;1\\+1&#x27;</span>)).<span class="title function_">test</span>(<span class="string">&#x27;1+1&#x27;</span>)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>RegExp</code>作为构造函数，参数是一个字符串。但是，在字符串内部，反斜杠也是转义字符，所以它会先被反斜杠转义一次，然后再被正则表达式转义一次，因此需要两个反斜杠转义。</p>
<h4 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h4><p>正则表达式对一些不能打印的特殊字符，提供了表达方法。</p>
<ul>
<li><code>\cX</code> 表示<code>Ctrl-[X]</code>，其中的<code>X</code>是A-Z之中任一个英文字母，用来匹配控制字符。</li>
<li><code>[\b]</code> 匹配退格键(U+0008)，不要与<code>\b</code>混淆。</li>
<li><code>\n</code> 匹配换行键。</li>
<li><code>\r</code> 匹配回车键。</li>
<li><code>\t</code> 匹配制表符 tab（U+0009）。</li>
<li><code>\v</code> 匹配垂直制表符（U+000B）。</li>
<li><code>\f</code> 匹配换页符（U+000C）。</li>
<li><code>\0</code> 匹配<code>null</code>字符（U+0000）。</li>
<li><code>\xhh</code> 匹配一个以两位十六进制数（<code>\x00</code>-<code>\xFF</code>）表示的字符。</li>
<li><code>\uhhhh</code> 匹配一个以四位十六进制数（<code>\u0000</code>-<code>\uFFFF</code>）表示的 Unicode 字符。</li>
</ul>
<h4 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h4><p>字符类（class）表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内，比如<code>[xyz]</code> 表示<code>x</code>、<code>y</code>、<code>z</code>之中任选一个匹配。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/[abc]/.<span class="title function_">test</span>(<span class="string">&#x27;hello world&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">/[abc]/.<span class="title function_">test</span>(<span class="string">&#x27;apple&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，字符串<code>hello world</code>不包含<code>a</code>、<code>b</code>、<code>c</code>这三个字母中的任一个，所以返回<code>false</code>；字符串<code>apple</code>包含字母<code>a</code>，所以返回<code>true</code>。</p>
<p>有两个字符在字符类中有特殊含义。</p>
<p><strong>（1）脱字符（&amp;#94;）</strong></p>
<p>如果方括号内的第一个字符是<code>[^]</code>，则表示除了字符类之中的字符，其他字符都可以匹配。比如，<code>[^xyz]</code>表示除了<code>x</code>、<code>y</code>、<code>z</code>之外都可以匹配。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/[^abc]/.<span class="title function_">test</span>(<span class="string">&#x27;bbc news&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">/[^abc]/.<span class="title function_">test</span>(<span class="string">&#x27;bbc&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，字符串<code>bbc news</code>包含<code>a</code>、<code>b</code>、<code>c</code>以外的其他字符，所以返回<code>true</code>；字符串<code>bbc</code>不包含<code>a</code>、<code>b</code>、<code>c</code>以外的其他字符，所以返回<code>false</code>。</p>
<p>如果方括号内没有其他字符，即只有<code>[^]</code>，就表示匹配一切字符，其中包括换行符。相比之下，点号作为元字符（<code>.</code>）是不包括换行符的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;Please yes\nmake my day!&#x27;</span>;</span><br><span class="line"></span><br><span class="line">s.<span class="title function_">match</span>(<span class="regexp">/yes.*day/</span>) <span class="comment">// null</span></span><br><span class="line">s.<span class="title function_">match</span>(<span class="regexp">/yes[^]*day/</span>) <span class="comment">// [ &#x27;yes\nmake my day&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，字符串<code>s</code>含有一个换行符，点号不包括换行符，所以第一个正则表达式匹配失败；第二个正则表达式<code>[^]</code>包含一切字符，所以匹配成功。</p>
<blockquote>
<p>注意，脱字符只有在字符类的第一个位置才有特殊含义，否则就是字面含义。</p>
</blockquote>
<p><strong>（2）连字符（-）</strong></p>
<p>某些情况下，对于连续序列的字符，连字符（<code>-</code>）用来提供简写形式，表示字符的连续范围。比如，<code>[abc]</code>可以写成<code>[a-c]</code>，<code>[0123456789]</code>可以写成<code>[0-9]</code>，同理<code>[A-Z]</code>表示26个大写字母。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/a-z/.<span class="title function_">test</span>(<span class="string">&#x27;b&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">/[a-z]/.<span class="title function_">test</span>(<span class="string">&#x27;b&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，当连字号（dash）不出现在方括号之中，就不具备简写的作用，只代表字面的含义，所以不匹配字符<code>b</code>。只有当连字号用在方括号之中，才表示连续的字符序列。</p>
<p>以下都是合法的字符类简写形式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span>-<span class="number">9.</span>,]</span><br><span class="line">[<span class="number">0</span>-9a-fA-F]</span><br><span class="line">[a-zA-<span class="variable constant_">Z0</span>-<span class="number">9</span>-]</span><br><span class="line">[<span class="number">1</span>-<span class="number">31</span>]</span><br></pre></td></tr></table></figure>

<p>上面代码中最后一个字符类<code>[1-31]</code>，不代表<code>1</code>到<code>31</code>，只代表<code>1</code>到<code>3</code>。</p>
<p>连字符还可以用来指定 Unicode 字符的范围。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;\u0130\u0131\u0132&quot;</span>;</span><br><span class="line"><span class="regexp">/[\u0128-\uFFFF]/</span>.<span class="title function_">test</span>(str)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>\u0128-\uFFFF</code>表示匹配码点在<code>0128</code>到<code>FFFF</code>之间的所有字符。</p>
<p>另外，不要过分使用连字符，设定一个很大的范围，否则很可能选中意料之外的字符。最典型的例子就是<code>[A-z]</code>，表面上它是选中从大写的<code>A</code>到小写的<code>z</code>之间52个字母，但是由于在 ASCII 编码之中，大写字母与小写字母之间还有其他字符，结果就会出现意料之外的结果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/[A-z]/.<span class="title function_">test</span>(<span class="string">&#x27;\\&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，由于反斜杠（’\‘）的ASCII码在大写字母与小写字母之间，结果会被选中。</p>
<h4 id="预定义模式"><a href="#预定义模式" class="headerlink" title="预定义模式"></a>预定义模式</h4><p>预定义模式指的是某些常见模式的简写方式。</p>
<ul>
<li><code>\d</code> 匹配0-9之间的任一数字，相当于<code>[0-9]</code>。</li>
<li><code>\D</code> 匹配所有0-9以外的字符，相当于<code>[^0-9]</code>。</li>
<li><code>\w</code> 匹配任意的字母、数字和下划线，相当于<code>[A-Za-z0-9_]</code>。</li>
<li><code>\W</code> 除所有字母、数字和下划线以外的字符，相当于<code>[^A-Za-z0-9_]</code>。</li>
<li><code>\s</code> 匹配空格（包括换行符、制表符、空格符等），相等于<code>[ \t\r\n\v\f]</code>。</li>
<li><code>\S</code> 匹配非空格的字符，相当于<code>[^ \t\r\n\v\f]</code>。</li>
<li><code>\b</code> 匹配词的边界。</li>
<li><code>\B</code> 匹配非词边界，即在词的内部。</li>
</ul>
<p>下面是一些例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// \s 的例子</span></span><br><span class="line">/\s\w*<span class="regexp">/.exec(&#x27;hello world&#x27;) /</span><span class="regexp">/ [&quot; world&quot;]</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ \b 的例子</span></span><br><span class="line"><span class="regexp">/</span>\bworld/.<span class="title function_">test</span>(<span class="string">&#x27;hello world&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">/\bworld/.<span class="title function_">test</span>(<span class="string">&#x27;hello-world&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">/\bworld/.<span class="title function_">test</span>(<span class="string">&#x27;helloworld&#x27;</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// \B 的例子</span></span><br><span class="line">/\<span class="title class_">Bworld</span>/.<span class="title function_">test</span>(<span class="string">&#x27;hello-world&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">/\<span class="title class_">Bworld</span>/.<span class="title function_">test</span>(<span class="string">&#x27;helloworld&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>\s</code>表示空格，所以匹配结果会包括空格。<code>\b</code>表示词的边界，所以<code>world</code>的词首必须独立（词尾是否独立未指定），才会匹配。同理，<code>\B</code>表示非词的边界，只有<code>world</code>的词首不独立，才会匹配。</p>
<p>通常，正则表达式遇到换行符（<code>\n</code>）就会停止匹配。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> html = <span class="string">&quot;&lt;b&gt;Hello&lt;/b&gt;\n&lt;i&gt;world!&lt;/i&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="regexp">/.*/</span>.<span class="title function_">exec</span>(html)[<span class="number">0</span>]</span><br><span class="line"><span class="comment">// &quot;&lt;b&gt;Hello&lt;/b&gt;&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，字符串<code>html</code>包含一个换行符，结果点字符（<code>.</code>）不匹配换行符，导致匹配结果可能不符合原意。这时使用<code>\s</code>字符类，就能包括换行符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> html = <span class="string">&quot;&lt;b&gt;Hello&lt;/b&gt;\n&lt;i&gt;world!&lt;/i&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="regexp">/[\S\s]*/</span>.<span class="title function_">exec</span>(html)[<span class="number">0</span>]</span><br><span class="line"><span class="comment">// &quot;&lt;b&gt;Hello&lt;/b&gt;\n&lt;i&gt;world!&lt;/i&gt;&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>[\S\s]</code>指代一切字符。</p>
<h4 id="重复类"><a href="#重复类" class="headerlink" title="重复类"></a>重复类</h4><p>模式的精确匹配次数，使用大括号（<code>&#123;&#125;</code>）表示。<code>&#123;n&#125;</code>表示恰好重复<code>n</code>次，<code>&#123;n,&#125;</code>表示至少重复<code>n</code>次，<code>&#123;n,m&#125;</code>表示重复不少于<code>n</code>次，不多于<code>m</code>次。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/lo&#123;<span class="number">2</span>&#125;k/.<span class="title function_">test</span>(<span class="string">&#x27;look&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">/lo&#123;<span class="number">2</span>,<span class="number">5</span>&#125;k/.<span class="title function_">test</span>(<span class="string">&#x27;looook&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，第一个模式指定<code>o</code>连续出现2次，第二个模式指定<code>o</code>连续出现2次到5次之间。</p>
<h4 id="量词符"><a href="#量词符" class="headerlink" title="量词符"></a>量词符</h4><p>量词符用来设定某个模式出现的次数。</p>
<ul>
<li><code>?</code> 问号表示某个模式出现0次或1次，等同于<code>&#123;0, 1&#125;</code>。</li>
<li><code>*</code> 星号表示某个模式出现0次或多次，等同于<code>&#123;0,&#125;</code>。</li>
<li><code>+</code> 加号表示某个模式出现1次或多次，等同于<code>&#123;1,&#125;</code>。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t 出现0次或1次</span></span><br><span class="line">/t?est/.<span class="title function_">test</span>(<span class="string">&#x27;test&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">/t?est/.<span class="title function_">test</span>(<span class="string">&#x27;est&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// t 出现1次或多次</span></span><br><span class="line">/t+est/.<span class="title function_">test</span>(<span class="string">&#x27;test&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">/t+est/.<span class="title function_">test</span>(<span class="string">&#x27;ttest&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">/t+est/.<span class="title function_">test</span>(<span class="string">&#x27;est&#x27;</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// t 出现0次或多次</span></span><br><span class="line">/t*est/.<span class="title function_">test</span>(<span class="string">&#x27;test&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">/t*est/.<span class="title function_">test</span>(<span class="string">&#x27;ttest&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">/t*est/.<span class="title function_">test</span>(<span class="string">&#x27;tttest&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">/t*est/.<span class="title function_">test</span>(<span class="string">&#x27;est&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h4 id="贪婪模式"><a href="#贪婪模式" class="headerlink" title="贪婪模式"></a>贪婪模式</h4><p>上一小节的三个量词符，默认情况下都是最大可能匹配，即匹配到下一个字符不满足匹配规则为止。这被称为贪婪模式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;aaa&#x27;</span>;</span><br><span class="line">s.<span class="title function_">match</span>(<span class="regexp">/a+/</span>) <span class="comment">// [&quot;aaa&quot;]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，模式是<code>/a+/</code>，表示匹配1个<code>a</code>或多个<code>a</code>，那么到底会匹配几个<code>a</code>呢？因为默认是贪婪模式，会一直匹配到字符<code>a</code>不出现为止，所以匹配结果是3个<code>a</code>。</p>
<p>除了贪婪模式，还有非贪婪模式，即最小可能匹配。只要一发现匹配，就返回结果，不要往下检查。如果想将贪婪模式改为非贪婪模式，可以在量词符后面加一个问号。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;aaa&#x27;</span>;</span><br><span class="line">s.<span class="title function_">match</span>(<span class="regexp">/a+?/</span>) <span class="comment">// [&quot;a&quot;]</span></span><br></pre></td></tr></table></figure>

<p>上面例子中，模式结尾添加了一个问号<code>/a+?/</code>，这时就改为非贪婪模式，一旦条件满足，就不再往下匹配，<code>+?</code>表示只要发现一个<code>a</code>，就不再往下匹配了。</p>
<p>除了非贪婪模式的加号（<code>+?</code>），还有非贪婪模式的星号（<code>*?</code>）和非贪婪模式的问号（<code>??</code>）。</p>
<ul>
<li><code>+?</code>：表示某个模式出现1次或多次，匹配时采用非贪婪模式。</li>
<li><code>*?</code>：表示某个模式出现0次或多次，匹配时采用非贪婪模式。</li>
<li><code>??</code>：表格某个模式出现0次或1次，匹配时采用非贪婪模式。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;abb&#x27;</span>.<span class="title function_">match</span>(<span class="regexp">/ab*/</span>) <span class="comment">// [&quot;abb&quot;]</span></span><br><span class="line"><span class="string">&#x27;abb&#x27;</span>.<span class="title function_">match</span>(<span class="regexp">/ab*?/</span>) <span class="comment">// [&quot;a&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;abb&#x27;</span>.<span class="title function_">match</span>(<span class="regexp">/ab?/</span>) <span class="comment">// [&quot;ab&quot;]</span></span><br><span class="line"><span class="string">&#x27;abb&#x27;</span>.<span class="title function_">match</span>(<span class="regexp">/ab??/</span>) <span class="comment">// [&quot;a&quot;]</span></span><br></pre></td></tr></table></figure>

<p>上面例子中，<code>/ab*/</code>表示如果<code>a</code>后面有多个<code>b</code>，那么匹配尽可能多的<code>b</code>；<code>/ab*?/</code>表示匹配尽可能少的<code>b</code>，也就是0个<code>b</code>。</p>
<h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><p>修饰符（modifier）表示模式的附加规则，放在正则模式的最尾部。</p>
<p>修饰符可以单个使用，也可以多个一起使用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单个修饰符</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/test/i</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个修饰符</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/test/ig</span>;</span><br></pre></td></tr></table></figure>

<p><strong>（1）g 修饰符</strong></p>
<p>默认情况下，第一次匹配成功后，正则对象就停止向下匹配了。<code>g</code>修饰符表示全局匹配（global），加上它以后，正则对象将匹配全部符合条件的结果，主要用于搜索和替换。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/b/</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;abba&#x27;</span>;</span><br><span class="line"></span><br><span class="line">regex.<span class="title function_">test</span>(str); <span class="comment">// true</span></span><br><span class="line">regex.<span class="title function_">test</span>(str); <span class="comment">// true</span></span><br><span class="line">regex.<span class="title function_">test</span>(str); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，正则模式不含<code>g</code>修饰符，每次都是从字符串头部开始匹配。所以，连续做了三次匹配，都返回<code>true</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/b/g</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;abba&#x27;</span>;</span><br><span class="line"></span><br><span class="line">regex.<span class="title function_">test</span>(str); <span class="comment">// true</span></span><br><span class="line">regex.<span class="title function_">test</span>(str); <span class="comment">// true</span></span><br><span class="line">regex.<span class="title function_">test</span>(str); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，正则模式含有<code>g</code>修饰符，每次都是从上一次匹配成功处，开始向后匹配。因为字符串<code>abba</code>只有两个<code>b</code>，所以前两次匹配结果为<code>true</code>，第三次匹配结果为<code>false</code>。</p>
<p><strong>（2）i 修饰符</strong></p>
<p>默认情况下，正则对象区分字母的大小写，加上<code>i</code>修饰符以后表示忽略大小写（ignoreCase）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/abc/.<span class="title function_">test</span>(<span class="string">&#x27;ABC&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">/abc/i.<span class="title function_">test</span>(<span class="string">&#x27;ABC&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码表示，加了<code>i</code>修饰符以后，不考虑大小写，所以模式<code>abc</code>匹配字符串<code>ABC</code>。</p>
<p><strong>（3）m 修饰符</strong></p>
<p><code>m</code>修饰符表示多行模式（multiline），会修改<code>^</code>和<code>$</code>的行为。默认情况下（即不加<code>m</code>修饰符时），<code>^</code>和<code>$</code>匹配字符串的开始处和结尾处，加上<code>m</code>修饰符以后，<code>^</code>和<code>$</code>还会匹配行首和行尾，即<code>^</code>和<code>$</code>会识别换行符（<code>\n</code>）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/world$/.<span class="title function_">test</span>(<span class="string">&#x27;hello world\n&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">/world$/m.<span class="title function_">test</span>(<span class="string">&#x27;hello world\n&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面的代码中，字符串结尾处有一个换行符。如果不加<code>m</code>修饰符，匹配不成功，因为字符串的结尾不是<code>world</code>；加上以后，<code>$</code>可以匹配行尾。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/^b/m.<span class="title function_">test</span>(<span class="string">&#x27;a\nb&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码要求匹配行首的<code>b</code>，如果不加<code>m</code>修饰符，就相当于<code>b</code>只能处在字符串的开始处。加上<code>m</code>修饰符以后，换行符<code>\n</code>也会被认为是一行的开始。</p>
<h4 id="组匹配"><a href="#组匹配" class="headerlink" title="组匹配"></a>组匹配</h4><p><strong>（1）概述</strong></p>
<p>正则表达式的括号表示分组匹配，括号中的模式可以用来匹配分组的内容。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/fred+<span class="regexp">/.test(&#x27;fredd&#x27;) /</span><span class="regexp">/ true</span></span><br><span class="line"><span class="regexp">/</span>(fred)+<span class="regexp">/.test(&#x27;fredfred&#x27;) /</span><span class="regexp">/ true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，第一个模式没有括号，结果<code>+</code>只表示重复字母<code>d</code>，第二个模式有括号，结果<code>+</code>就表示匹配<code>fred</code>这个词。</p>
<p>下面是另外一个分组捕获的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="string">&#x27;abcabc&#x27;</span>.<span class="title function_">match</span>(<span class="regexp">/(.)b(.)/</span>);</span><br><span class="line">m</span><br><span class="line"><span class="comment">// [&#x27;abc&#x27;, &#x27;a&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，正则表达式<code>/(.)b(.)/</code>一共使用两个括号，第一个括号捕获<code>a</code>，第二个括号捕获<code>c</code>。</p>
<p>注意，使用组匹配时，不宜同时使用<code>g</code>修饰符，否则<code>match</code>方法不会捕获分组的内容。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="string">&#x27;abcabc&#x27;</span>.<span class="title function_">match</span>(<span class="regexp">/(.)b(.)/g</span>);</span><br><span class="line">m <span class="comment">// [&#x27;abc&#x27;, &#x27;abc&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>上面代码使用带<code>g</code>修饰符的正则表达式，结果<code>match</code>方法只捕获了匹配整个表达式的部分。这时必须使用正则表达式的<code>exec</code>方法，配合循环，才能读到每一轮匹配的组捕获。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;abcabc&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/(.)b(.)/g</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> result = reg.<span class="title function_">exec</span>(str);</span><br><span class="line">  <span class="keyword">if</span> (!result) <span class="keyword">break</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [&quot;abc&quot;, &quot;a&quot;, &quot;c&quot;]</span></span><br><span class="line"><span class="comment">// [&quot;abc&quot;, &quot;a&quot;, &quot;c&quot;]</span></span><br></pre></td></tr></table></figure>

<p>正则表达式内部，还可以用<code>\n</code>引用括号匹配的内容，<code>n</code>是从1开始的自然数，表示对应顺序的括号。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/(.)<span class="title function_">b</span>(.)\1b\<span class="number">2</span>/.<span class="title function_">test</span>(<span class="string">&quot;abcabc&quot;</span>)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面的代码中，<code>\1</code>表示第一个括号匹配的内容（即<code>a</code>），<code>\2</code>表示第二个括号匹配的内容（即<code>c</code>）。</p>
<p>下面是另外一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/<span class="title function_">y</span>(..)(.)\<span class="number">2</span>\<span class="number">1</span>/.<span class="title function_">test</span>(<span class="string">&#x27;yabccab&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>括号还可以嵌套。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/<span class="title function_">y</span>((..)\<span class="number">2</span>)\<span class="number">1</span>/.<span class="title function_">test</span>(<span class="string">&#x27;yabababab&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>\1</code>指向外层括号，<code>\2</code>指向内层括号。</p>
<p>组匹配非常有用，下面是一个匹配网页标签的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tagName = <span class="regexp">/&lt;([^&gt;]+)&gt;[^&lt;]*&lt;\/\1&gt;/</span>;</span><br><span class="line"></span><br><span class="line">tagName.<span class="title function_">exec</span>(<span class="string">&quot;&lt;b&gt;bold&lt;/b&gt;&quot;</span>)[<span class="number">1</span>]</span><br><span class="line"><span class="comment">// &#x27;b&#x27;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，圆括号匹配尖括号之中的标签，而<code>\1</code>就表示对应的闭合标签。</p>
<p>上面代码略加修改，就能捕获带有属性的标签。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> html = <span class="string">&#x27;&lt;b class=&quot;hello&quot;&gt;Hello&lt;/b&gt;&lt;i&gt;world&lt;/i&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> tag = <span class="regexp">/&lt;(\w+)([^&gt;]*)&gt;(.*?)&lt;\/\1&gt;/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> match = tag.<span class="title function_">exec</span>(html);</span><br><span class="line"></span><br><span class="line">match[<span class="number">1</span>] <span class="comment">// &quot;b&quot;</span></span><br><span class="line">match[<span class="number">2</span>] <span class="comment">// &quot; class=&quot;hello&quot;&quot;</span></span><br><span class="line">match[<span class="number">3</span>] <span class="comment">// &quot;Hello&quot;</span></span><br><span class="line"></span><br><span class="line">match = tag.<span class="title function_">exec</span>(html);</span><br><span class="line"></span><br><span class="line">match[<span class="number">1</span>] <span class="comment">// &quot;i&quot;</span></span><br><span class="line">match[<span class="number">2</span>] <span class="comment">// &quot;&quot;</span></span><br><span class="line">match[<span class="number">3</span>] <span class="comment">// &quot;world&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>（2）非捕获组</strong></p>
<p><code>(?:x)</code>称为非捕获组（Non-capturing group），表示不返回该组匹配的内容，即匹配的结果中不计入这个括号。</p>
<p>非捕获组的作用请考虑这样一个场景，假定需要匹配<code>foo</code>或者<code>foofoo</code>，正则表达式就应该写成<code>/(foo)&#123;1, 2&#125;/</code>，但是这样会占用一个组匹配。这时，就可以使用非捕获组，将正则表达式改为<code>/(?:foo)&#123;1, 2&#125;/</code>，它的作用与前一个正则是一样的，但是不会单独输出括号内部的内容。</p>
<p>请看下面的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="string">&#x27;abc&#x27;</span>.<span class="title function_">match</span>(<span class="regexp">/(?:.)b(.)/</span>);</span><br><span class="line">m <span class="comment">// [&quot;abc&quot;, &quot;c&quot;]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中的模式，一共使用了两个括号。其中第一个括号是非捕获组，所以最后返回的结果中没有第一个括号，只有第二个括号匹配的内容。</p>
<p>下面是用来分解网址的正则表达式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常匹配</span></span><br><span class="line"><span class="keyword">var</span> url = <span class="regexp">/(http|ftp):\/\/([^/\r\n]+)(\/[^\r\n]*)?/</span>;</span><br><span class="line"></span><br><span class="line">url.<span class="title function_">exec</span>(<span class="string">&#x27;http://google.com/&#x27;</span>);</span><br><span class="line"><span class="comment">// [&quot;http://google.com/&quot;, &quot;http&quot;, &quot;google.com&quot;, &quot;/&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 非捕获组匹配</span></span><br><span class="line"><span class="keyword">var</span> url = <span class="regexp">/(?:http|ftp):\/\/([^/\r\n]+)(\/[^\r\n]*)?/</span>;</span><br><span class="line"></span><br><span class="line">url.<span class="title function_">exec</span>(<span class="string">&#x27;http://google.com/&#x27;</span>);</span><br><span class="line"><span class="comment">// [&quot;http://google.com/&quot;, &quot;google.com&quot;, &quot;/&quot;]</span></span><br></pre></td></tr></table></figure>

<p>上面的代码中，前一个正则表达式是正常匹配，第一个括号返回网络协议；后一个正则表达式是非捕获匹配，返回结果中不包括网络协议。</p>
<p><strong>（3）先行断言</strong></p>
<p><code>x(?=y)</code>称为先行断言（Positive look-ahead），<code>x</code>只有在<code>y</code>前面才匹配，<code>y</code>不会被计入返回结果。比如，要匹配后面跟着百分号的数字，可以写成<code>/\d+(?=%)/</code>。</p>
<p>“先行断言”中，括号里的部分是不会返回的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="string">&#x27;abc&#x27;</span>.<span class="title function_">match</span>(<span class="regexp">/b(?=c)/</span>);</span><br><span class="line">m <span class="comment">// [&quot;b&quot;]</span></span><br></pre></td></tr></table></figure>

<p>上面的代码使用了先行断言，<code>b</code>在<code>c</code>前面所以被匹配，但是括号对应的<code>c</code>不会被返回。</p>
<p><strong>（4）先行否定断言</strong></p>
<p><code>x(?!y)</code>称为先行否定断言（Negative look-ahead），<code>x</code>只有不在<code>y</code>前面才匹配，<code>y</code>不会被计入返回结果。比如，要匹配后面跟的不是百分号的数字，就要写成<code>/\d+(?!%)/</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/\d+(?!\.)/.<span class="title function_">exec</span>(<span class="string">&#x27;3.14&#x27;</span>)</span><br><span class="line"><span class="comment">// [&quot;14&quot;]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，正则表达式指定，只有不在小数点前面的数字才会被匹配，因此返回的结果就是<code>14</code>。</p>
<p>“先行否定断言”中，括号里的部分是不会返回的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="string">&#x27;abd&#x27;</span>.<span class="title function_">match</span>(<span class="regexp">/b(?!c)/</span>);</span><br><span class="line">m <span class="comment">// [&#x27;b&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>上面的代码使用了先行否定断言，<code>b</code>不在<code>c</code>前面所以被匹配，而且括号对应的<code>d</code>不会被返回。</p>
<!-- flag of hidden posts --></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://blog.elzzach.top">Elzzach</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://blog.elzzach.top/article/fbb5b1c9a9c7.html">https://blog.elzzach.top/article/fbb5b1c9a9c7.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.elzzach.top" target="_blank">暮紫天地</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.elzzach.top/global-img/avatar.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Elzzach</div><div class="author-info__description">一个爱好视觉效果的(想花里胡哨却花不起来的)入门小前端</div></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/legend-cpu" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:el-zzach@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到暮紫天地！🎉<br/>博主去知识的海洋里遨游了，更新随缘哦~<br/><strong>主站点</strong>：<a href="https://blog.elzzach.top/" target="_blank">blog.elzzach.top</a><br/><strong>镜像站</strong>：<a href="https://legend-cpu.github.io/" target="_blank">Github镜像站</a><br/>作者才疏学浅，读者若发现文章有错误之处，请不吝指出！<br/><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.elzzach.top/global-img/202202241714592.gif" alt="可爱"/></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript%E5%8E%86%E5%8F%B2%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">JavaScript历史概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="toc-number">2.</span> <span class="toc-text">开发环境搭建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80"><span class="toc-number">3.</span> <span class="toc-text">语法基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-number">3.1.</span> <span class="toc-text">标识符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%EF%BC%88%E7%89%B9%E6%80%A7%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">严格模式（特性）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.3.</span> <span class="toc-text">语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E-x2F-%E8%B5%8B%E5%80%BC"><span class="toc-number">3.4.</span> <span class="toc-text">变量声明&#x2F;赋值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ES5%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E"><span class="toc-number">3.4.1.</span> <span class="toc-text">ES5变量声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ES6%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E"><span class="toc-number">3.4.2.</span> <span class="toc-text">ES6变量声明</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.5.</span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%88%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B%EF%BC%89"><span class="toc-number">3.5.1.</span> <span class="toc-text">简单数据类型（原始类型）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Undefined"><span class="toc-number">3.5.1.1.</span> <span class="toc-text">Undefined</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Null"><span class="toc-number">3.5.1.2.</span> <span class="toc-text">Null</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Boolean"><span class="toc-number">3.5.1.3.</span> <span class="toc-text">Boolean</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Number"><span class="toc-number">3.5.1.4.</span> <span class="toc-text">Number</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%A1%A8%E7%A4%BA%E5%8D%81%E8%BF%9B%E5%88%B6%E6%95%B0"><span class="toc-number">3.5.1.4.1.</span> <span class="toc-text">表示十进制数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%A1%A8%E7%A4%BA%E5%85%AB%E8%BF%9B%E5%88%B6%E6%95%B0"><span class="toc-number">3.5.1.4.2.</span> <span class="toc-text">表示八进制数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%A1%A8%E7%A4%BA%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E6%95%B0"><span class="toc-number">3.5.1.4.3.</span> <span class="toc-text">表示十六进制数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%A1%A8%E7%A4%BA%E6%B5%AE%E7%82%B9%E6%95%B0"><span class="toc-number">3.5.1.4.4.</span> <span class="toc-text">表示浮点数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A1%A8%E7%A4%BA%E7%A7%91%E5%AD%A6%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="toc-number">3.5.1.4.5.</span> <span class="toc-text">如何表示科学计数法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#JavaScript%E8%83%BD%E5%A4%9F%E8%A1%A8%E7%A4%BA%E7%9A%84%E6%95%B0%E5%80%BC%E8%8C%83%E5%9B%B4"><span class="toc-number">3.5.1.4.6.</span> <span class="toc-text">JavaScript能够表示的数值范围</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#JavaScript%E4%B8%8D%E8%83%BD%E8%A1%A8%E7%A4%BA%E7%9A%84%E6%95%B0%E5%80%BC%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86"><span class="toc-number">3.5.1.4.7.</span> <span class="toc-text">JavaScript不能表示的数值怎么处理</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%B0%86%E9%9D%9E%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B%E6%89%8B%E5%8A%A8%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.5.1.4.8.</span> <span class="toc-text">如何将非数值类型手动转换为数值类型</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="toc-number">3.5.1.4.9.</span> <span class="toc-text">数字格式化</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#String"><span class="toc-number">3.5.1.5.</span> <span class="toc-text">String</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%A1%A8%E7%A4%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">3.5.1.5.1.</span> <span class="toc-text">表示字符串</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A6"><span class="toc-number">3.5.1.5.2.</span> <span class="toc-text">获取字符串长度</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">3.5.1.5.3.</span> <span class="toc-text">转换其他数据类型为字符串</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%8C%87%E5%AE%9A%E7%B4%A2%E5%BC%95%E4%BD%8D%E7%BD%AE%E7%9A%84%E5%AD%97%E7%AC%A6"><span class="toc-number">3.5.1.5.4.</span> <span class="toc-text">查找字符串中指定索引位置的字符</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8B%BC%E6%8E%A5%E5%A4%9A%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%BA%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">3.5.1.5.5.</span> <span class="toc-text">拼接多个字符串为一个字符串</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BB%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%88%87%E5%8F%96%E5%AD%90%E4%B8%B2"><span class="toc-number">3.5.1.5.6.</span> <span class="toc-text">从字符串中切取子串</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E6%8C%87%E5%AE%9A%E5%88%86%E5%89%B2%E7%AC%A6%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%86%E5%89%B2%E4%B8%BA%E8%8B%A5%E5%B9%B2%E9%83%A8%E5%88%86"><span class="toc-number">3.5.1.5.7.</span> <span class="toc-text">根据指定分割符将字符串分割为若干部分</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9C%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%AE%9A%E4%BD%8D%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">3.5.1.5.8.</span> <span class="toc-text">在字符串中定位子字符串</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%89%8D%E5%90%8E%E7%9A%84%E6%89%80%E6%9C%89%E7%A9%BA%E7%99%BD%E7%AC%A6%EF%BC%88%E4%B8%AD%E9%97%B4%E7%9A%84%E7%A9%BA%E7%99%BD%E7%AC%A6%E4%B8%8D%E5%8F%97%E5%BD%B1%E5%93%8D%EF%BC%89"><span class="toc-number">3.5.1.5.9.</span> <span class="toc-text">删除字符串前后的所有空白符（中间的空白符不受影响）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B9%B6%E6%8B%BC%E6%8E%A5"><span class="toc-number">3.5.1.5.10.</span> <span class="toc-text">复制字符串并拼接</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9C%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B7%A6%E4%BE%A7%E6%88%96%E5%8F%B3%E4%BE%A7%E5%A1%AB%E5%85%85%E5%AD%97%E7%AC%A6"><span class="toc-number">3.5.1.5.11.</span> <span class="toc-text">在字符串左侧或右侧填充字符</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E6%9E%84"><span class="toc-number">3.5.1.5.12.</span> <span class="toc-text">字符串解构</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A4%A7%E5%B0%8F%E5%86%99%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.5.1.5.13.</span> <span class="toc-text">大小写转换</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">3.5.1.5.14.</span> <span class="toc-text">比较两个字符串</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%88%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%EF%BC%89"><span class="toc-number">3.5.2.</span> <span class="toc-text">复杂数据类型（引用类型）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Object"><span class="toc-number">3.5.2.1.</span> <span class="toc-text">Object</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%93%AA%E4%B8%AA%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA%E7%9A%84"><span class="toc-number">3.5.2.1.1.</span> <span class="toc-text">查看当前对象是哪个构造函数创建的</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%BD%93%E5%89%8D%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B-%E4%B8%8D%E6%98%AF%E5%8E%9F%E5%9E%8B-%E4%B8%8A%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E7%BB%99%E5%AE%9A%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">3.5.2.1.2.</span> <span class="toc-text">判断当前对象实例(不是原型)上是否存在给定的属性</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%BD%93%E5%89%8D%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E4%B8%BA%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8E%9F%E5%9E%8B"><span class="toc-number">3.5.2.1.3.</span> <span class="toc-text">判断当前对象是否为另一个对象的原型</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E7%BB%99%E5%AE%9A%E7%9A%84%E5%B1%9E%E6%80%A7%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8for-in%E8%AF%AD%E5%8F%A5%E6%9E%9A%E4%B8%BE"><span class="toc-number">3.5.2.1.4.</span> <span class="toc-text">判断给定的属性是否可以使用for-in语句枚举</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A1%A8%E7%A4%BA"><span class="toc-number">3.5.2.1.5.</span> <span class="toc-text">返回对象的字符串表示</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E5%AF%B9%E5%BA%94%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E6%95%B0%E5%80%BC%E6%88%96%E5%B8%83%E5%B0%94%E5%80%BC%E8%A1%A8%E7%A4%BA"><span class="toc-number">3.5.2.1.6.</span> <span class="toc-text">返回对象对应的字符串、数值或布尔值表示</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">3.6.</span> <span class="toc-text">操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E5%85%83%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">3.6.1.</span> <span class="toc-text">一元操作符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">3.6.2.</span> <span class="toc-text">布尔操作符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B9%98%E6%80%A7%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">3.6.3.</span> <span class="toc-text">乘性操作符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E6%95%B0%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">3.6.4.</span> <span class="toc-text">指数操作符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E6%80%A7%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">3.6.5.</span> <span class="toc-text">加性操作符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">3.6.6.</span> <span class="toc-text">关系操作符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E7%AD%89%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">3.6.7.</span> <span class="toc-text">相等操作符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">3.6.8.</span> <span class="toc-text">条件操作符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E5%80%BC%E5%90%88%E5%B9%B6%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">3.6.9.</span> <span class="toc-text">空值合并操作符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">3.6.10.</span> <span class="toc-text">赋值操作符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%97%E5%8F%B7%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">3.6.11.</span> <span class="toc-text">逗号操作符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%95%E5%BC%80%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E5%89%A9%E4%BD%99%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.6.12.</span> <span class="toc-text">展开运算符与剩余运算符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E5%8F%A5-1"><span class="toc-number">3.7.</span> <span class="toc-text">语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">3.8.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%90%8D"><span class="toc-number">3.8.1.</span> <span class="toc-text">函数名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-number">3.8.2.</span> <span class="toc-text">函数参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.8.3.</span> <span class="toc-text">函数声明与函数表达式的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8"><span class="toc-number">3.8.4.</span> <span class="toc-text">函数内部</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#arguments"><span class="toc-number">3.8.4.1.</span> <span class="toc-text">arguments</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#this"><span class="toc-number">3.8.4.2.</span> <span class="toc-text">this</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#caller"><span class="toc-number">3.8.4.3.</span> <span class="toc-text">caller</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#new-target"><span class="toc-number">3.8.4.4.</span> <span class="toc-text">new.target</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%B1%9E%E6%80%A7%E4%B8%8E%E6%96%B9%E6%B3%95"><span class="toc-number">3.8.5.</span> <span class="toc-text">函数属性与方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%EF%BC%9Alength"><span class="toc-number">3.8.5.1.</span> <span class="toc-text">属性：length</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%EF%BC%9Aprototype"><span class="toc-number">3.8.5.2.</span> <span class="toc-text">属性：prototype</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%EF%BC%9Aapply%EF%BC%88%EF%BC%89"><span class="toc-number">3.8.5.3.</span> <span class="toc-text">方法：apply（）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%EF%BC%9Acall%EF%BC%88%EF%BC%89"><span class="toc-number">3.8.5.4.</span> <span class="toc-text">方法：call（）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%EF%BC%9Abind%EF%BC%88%EF%BC%89"><span class="toc-number">3.8.5.5.</span> <span class="toc-text">方法：bind（）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9AtoString%EF%BC%88%EF%BC%89"><span class="toc-number">3.8.5.6.</span> <span class="toc-text">继承的方法：toString（）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%BB%91%E5%AE%9A%EF%BC%88bind%EF%BC%88%EF%BC%89%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%89"><span class="toc-number">3.8.6.</span> <span class="toc-text">函数绑定（bind（）的应用）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AB%8B%E5%8D%B3%E8%B0%83%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88IIFE%EF%BC%89"><span class="toc-number">3.8.7.</span> <span class="toc-text">立即调用的函数表达式（IIFE）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86"><span class="toc-number">3.8.8.</span> <span class="toc-text">函数进阶知识</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-number">3.8.8.1.</span> <span class="toc-text">闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%AF%8D%E6%B3%95%E7%8E%AF%E5%A2%83"><span class="toc-number">3.8.8.1.1.</span> <span class="toc-text">词法环境</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">3.9.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84"><span class="toc-number">3.9.1.</span> <span class="toc-text">创建数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%A9%BA%E4%BD%8D"><span class="toc-number">3.9.2.</span> <span class="toc-text">数组空位</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95"><span class="toc-number">3.9.3.</span> <span class="toc-text">数组索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F%E6%98%AF%E5%90%A6%E4%B8%BA%E6%95%B0%E7%BB%84"><span class="toc-number">3.9.4.</span> <span class="toc-text">判断一个变量是否为数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E6%95%B0%E7%BB%84"><span class="toc-number">3.9.5.</span> <span class="toc-text">迭代数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A1%AB%E5%85%85%E6%95%B0%E7%BB%84%EF%BC%88%E5%B0%86%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0%E6%89%B9%E9%87%8F%E6%9B%BF%E6%8D%A2%E4%B8%BA%E6%8C%87%E5%AE%9A%E5%80%BC%EF%BC%89"><span class="toc-number">3.9.6.</span> <span class="toc-text">填充数组（将数组中的元素批量替换为指定值）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">3.9.7.</span> <span class="toc-text">将数组转换为字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%93%E5%B9%B3%E6%95%B0%E7%BB%84%EF%BC%88%E9%AB%98%E7%BB%B4%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96%E4%B8%BA%E4%BD%8E%E7%BB%B4%E6%95%B0%E7%BB%84%EF%BC%89"><span class="toc-number">3.9.8.</span> <span class="toc-text">打平数组（高维数组扁平化为低维数组）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%91%E6%95%B0%E7%BB%84%E4%B8%AD%E5%A2%9E%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="toc-number">3.9.9.</span> <span class="toc-text">向数组中增加元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E6%95%B0%E7%BB%84%E4%B8%AD%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-number">3.9.10.</span> <span class="toc-text">从数组中删除元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86%E6%95%B0%E7%BB%84%E5%8F%8D%E5%90%91%E6%8E%92%E5%88%97"><span class="toc-number">3.9.11.</span> <span class="toc-text">将数组反向排列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86%E6%95%B0%E7%BB%84%E6%8C%89%E4%B8%80%E5%AE%9A%E7%9A%84%E5%A4%A7%E5%B0%8F%E9%A1%BA%E5%BA%8F%E6%8E%92%E5%88%97"><span class="toc-number">3.9.12.</span> <span class="toc-text">将数组按一定的大小顺序排列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87"><span class="toc-number">3.9.13.</span> <span class="toc-text">数组切片</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%BF%E6%8D%A2%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%83%A8%E5%88%86%E5%85%83%E7%B4%A0%EF%BC%88%E4%B9%9F%E5%8F%AF%E4%BB%A5%E6%9B%BF%E6%8D%A2%E5%90%8E%E5%86%8D%E6%8E%A5%E7%9D%80%E6%8F%92%E5%85%A5%EF%BC%89"><span class="toc-number">3.9.14.</span> <span class="toc-text">替换数组中的部分元素（也可以替换后再接着插入）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-number">3.9.15.</span> <span class="toc-text">查找数组中的元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E8%BF%AD%E4%BB%A3%E6%96%B9%E6%B3%95"><span class="toc-number">3.9.16.</span> <span class="toc-text">数组迭代方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%BD%92%E5%B9%B6%E6%96%B9%E6%B3%95"><span class="toc-number">3.9.17.</span> <span class="toc-text">数组归并方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E4%B8%8E%E6%97%B6%E9%97%B4"><span class="toc-number">3.10.</span> <span class="toc-text">日期与时间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%97%B6%E9%97%B4%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.10.1.</span> <span class="toc-text">创建时间对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">3.10.2.</span> <span class="toc-text">时间对象的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%97%B6%E9%97%B4"><span class="toc-number">3.10.2.1.</span> <span class="toc-text">获取时间</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E6%97%B6%E9%97%B4"><span class="toc-number">3.10.2.2.</span> <span class="toc-text">设置时间</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E6%A0%A1%E5%87%86"><span class="toc-number">3.10.2.3.</span> <span class="toc-text">自动校准</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E9%87%8F%E6%97%B6%E9%97%B4%E6%8A%80%E5%B7%A7"><span class="toc-number">3.10.3.</span> <span class="toc-text">测量时间技巧</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Json"><span class="toc-number">3.11.</span> <span class="toc-text">Json</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95"><span class="toc-number">3.11.1.</span> <span class="toc-text">语法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%80%BC"><span class="toc-number">3.11.1.1.</span> <span class="toc-text">简单值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.11.1.2.</span> <span class="toc-text">对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E7%BB%84-1"><span class="toc-number">3.11.1.3.</span> <span class="toc-text">数组</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">3.11.2.</span> <span class="toc-text">解析与序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">3.11.2.1.</span> <span class="toc-text">序列化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90"><span class="toc-number">3.11.2.2.</span> <span class="toc-text">解析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E8%B0%83%E8%AF%95"><span class="toc-number">3.12.</span> <span class="toc-text">错误处理与调试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">3.12.1.</span> <span class="toc-text">错误处理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#try-catch%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.12.1.1.</span> <span class="toc-text">try-catch语句</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8A%9B%E5%87%BA%E9%94%99%E8%AF%AF"><span class="toc-number">3.12.1.2.</span> <span class="toc-text">抛出错误</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#error%E4%BA%8B%E4%BB%B6"><span class="toc-number">3.12.1.3.</span> <span class="toc-text">error事件</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF"><span class="toc-number">3.12.2.</span> <span class="toc-text">调试技术</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8A%8A%E6%B6%88%E6%81%AF%E8%AE%B0%E5%BD%95%E5%88%B0%E6%8E%A7%E5%88%B6%E5%8F%B0"><span class="toc-number">3.12.2.1.</span> <span class="toc-text">把消息记录到控制台</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">4.</span> <span class="toc-text">正则表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">4.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7"><span class="toc-number">4.2.</span> <span class="toc-text">实例属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="toc-number">4.3.</span> <span class="toc-text">实例方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RegExp-prototype-test"><span class="toc-number">4.3.1.</span> <span class="toc-text">RegExp.prototype.test()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RegExp-prototype-exec"><span class="toc-number">4.3.2.</span> <span class="toc-text">RegExp.prototype.exec()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="toc-number">4.4.</span> <span class="toc-text">字符串的实例方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#String-prototype-match"><span class="toc-number">4.4.1.</span> <span class="toc-text">String.prototype.match()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String-prototype-search"><span class="toc-number">4.4.2.</span> <span class="toc-text">String.prototype.search()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String-prototype-replace"><span class="toc-number">4.4.3.</span> <span class="toc-text">String.prototype.replace()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String-prototype-split"><span class="toc-number">4.4.4.</span> <span class="toc-text">String.prototype.split()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99"><span class="toc-number">4.5.</span> <span class="toc-text">匹配规则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E9%9D%A2%E9%87%8F%E5%AD%97%E7%AC%A6%E5%92%8C%E5%85%83%E5%AD%97%E7%AC%A6"><span class="toc-number">4.5.1.</span> <span class="toc-text">字面量字符和元字符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E4%B9%89%E7%AC%A6"><span class="toc-number">4.5.2.</span> <span class="toc-text">转义符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6"><span class="toc-number">4.5.3.</span> <span class="toc-text">特殊字符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E7%B1%BB"><span class="toc-number">4.5.4.</span> <span class="toc-text">字符类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%84%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.5.5.</span> <span class="toc-text">预定义模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E5%A4%8D%E7%B1%BB"><span class="toc-number">4.5.6.</span> <span class="toc-text">重复类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8F%E8%AF%8D%E7%AC%A6"><span class="toc-number">4.5.7.</span> <span class="toc-text">量词符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%AA%E5%A9%AA%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.5.8.</span> <span class="toc-text">贪婪模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">4.5.9.</span> <span class="toc-text">修饰符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E5%8C%B9%E9%85%8D"><span class="toc-number">4.5.10.</span> <span class="toc-text">组匹配</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background: rgba(255, 255, 255, 0.8)"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By Elzzach</div><div class="footer_custom_text"><div class="footer_custom_text"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a><span class="footer-separator">|</span><span>备案 </span><a href="https://beian.miit.gov.cn" target="_blank">皖ICP备2022000051号</a></div></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://npm.elemecdn.com/medium-zoom@latest/dist/medium-zoom.min.js"></script><script src="https://npm.elemecdn.com/vanilla-lazyload@latest/dist/lazyload.iife.min.js"></script><script src="https://npm.elemecdn.com/node-snackbar@latest/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://npm.elemecdn.com/pangu@latest/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script src="https://npm.elemecdn.com/ezsttcfs@latest/live2d-widget/autoload.js"></script><script src="/ext/ez.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://npm.elemecdn.com/butterfly-extsrc@latest/dist/fireworks.min.js"></script><script src="https://npm.elemecdn.com/butterfly-extsrc@latest/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script></div></body></html>