<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>为了在PTA上用JavaScript做题，如何利用 Node.js 进行输入输出？</title>
      <link href="/article/fb3ad4d9de42.html"/>
      <url>/article/fb3ad4d9de42.html</url>
      
        <content type="html"><![CDATA[<div class="note info mordern flat"><p>本文为我2021年10月11日在CSDN上发的第三篇文章，现在稍加改动并搬运到本站上来。</p><p>不过说来惭愧，当初这篇文章本来是后面打算接一些PTA乙级题目的js版题解的，但是。。刷了几道之后我发现太花时间了，没时间做，所以后来就没做过了。不过这篇在PTA做题的时候如何使用Node.js进行输入输出还是可以看的。</p></div><h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p>在PTA上做题需要进行读取输入以及输出的操作，而JavaScript本来是没有标准输入输出这种东西的，后来出现的Node.js使之变成了现实。尽管如此，现在网上也不太容易找到一篇专门讲解为了在PTA上用JavaScript做题，输入输出到底应该怎么做的教程，而这恰恰是很多用JavaScript刷PTA的新手的困惑之处。因此这篇文章就是来做这件事，详细讲解为了在PTA上用JavaScript做题，如何利用 Node.js 进行输入输出？</p><p>开始之前，假定读者使用的代码编写工具为vscode。因为<del>这是一款颜值高、体验好的轻量级代码编辑器</del> —— 因为用它来写JavaScript代码还是很方便的，可以配置单独运行JavaScript文件的环境（只要简简单单安装个node还有Code Runner插件就行了，node安装教程推荐<a href="https://blog.csdn.net/Small_Yogurt/article/details/104968169">这个</a>）。</p><p>同时建议用vscode运行js代码时放到“终端”一栏输出，因为在“输出”那一栏输出的话有时候会出现中文乱码的情况，而且没有终端输出体验好。</p><h2 id="如何输入"><a href="#如何输入" class="headerlink" title="如何输入"></a>如何输入</h2><h3 id="基本输入操作"><a href="#基本输入操作" class="headerlink" title="基本输入操作"></a>基本输入操作</h3><p>现在正式开始，先把Node.js读取输入的最好用的模板放出来：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> readline = <span class="built_in">require</span>(<span class="string">&#x27;readline&#x27;</span>); <span class="comment">//引入readline模块</span></span><br><span class="line"><span class="keyword">const</span> rl = readline.<span class="title function_">createInterface</span>(&#123;</span><br><span class="line"><span class="attr">input</span>: process.<span class="property">stdin</span>,</span><br><span class="line"><span class="attr">output</span>: process.<span class="property">stdout</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">rl.<span class="title function_">on</span>(<span class="string">&#x27;line&#x27;</span>, <span class="keyword">function</span>(<span class="params">line</span>)&#123;</span><br><span class="line"><span class="comment">//做题的主体代码</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>头两个const声明可以说是定式了，用的时候直接复制粘贴过去就行。</p><p>重点在于那个on方法。代码执行到on方法时程序将开始持续按行接受输入（控制台输入，放到PTA上就是接受它给出的输入用例）。注意它是按行接受输入，也就是说当它读取输入时碰到换行符（是敲回车产生的看不见的换行符，不是打出来看得见的\n）时就认为这一行输入结束了，然后将这一行输入以字符串的形式赋值给on方法的第二个参数——一个带有一个参数的函数表达式——的参数（这个函数表达式如果对js比较熟的话应该知道它叫回调函数？），也就是上面代码中的函数参数line，不是引号括起来的那个哦，那个是表示line事件。所以line变量就是最终读取的输入的字符串形式：<br><img src="https://img-blog.csdnimg.cn/ca90ded1cc764c8d8fd5f40f520868c4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXVtaW5nZ3VpY2Fp,size_16,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>on方法每接受一行输入（碰到换行符认为一行输入完毕时）就会暂停接受输入，转而去执行on方法的第二个参数——回调函数。</p><p>如果回调函数内部没有写<code>rl.close();</code>来结束接受输入的话就会接着处于接受输入的状态，再接受一行输入，就像上面那样执行完一遍回调函数后下一行仍然会出现等待输入的光标。然后接受一行输入完毕后再整个执行一遍回调函数，反复循环：</p><blockquote><p>如果对node比较熟的话应该知道on方法其实是用于注册事件监听器的方法，而这里的<code>rl.on(&#39;line&#39;, function&#123;&#125;)</code>其实是给rl变量注册了一个监听line事件的监听器，每当读取到换行符时即触发这个line事件，然后被监听器监听到，然后就会执行一遍该监听器所携带的回调函数。如果没有用rl.close()方法结束接收输入的话，监听器将持续监听line事件，一旦事件被触发就会执行一遍回调函数，所以会反复循环。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/4bf559495958427ea639b9b8dc5b219f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXVtaW5nZ3VpY2Fp,size_16,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>除非回调函数内部写了<code>rl.close();</code>，那样的话回调函数碰到这一行代码就会立即停止执行，同时也不会再接受新的输入，程序就结束了：<br><img src="https://img-blog.csdnimg.cn/def2b24bccaf46e4aa29171d05d4115f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXVtaW5nZ3VpY2Fp,size_16,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><blockquote><p>对了，回调函数中的这个参数line其实是任意命名的，就像其他任何函数参数一样，比如你把它命名成data、inputs什么的都可以。</p></blockquote><h3 id="何时使用rl-close-方法"><a href="#何时使用rl-close-方法" class="headerlink" title="何时使用rl.close()方法"></a>何时使用rl.close()方法</h3><p>关于on方法还有一点需要注意的。上面说做题的主体代码需要放在回调函数里面（除了变量声明部分可以放在外面，我也推荐将变量声明部分放在外面），那么放在外面行不行呢？不行！看下面的图：<br><img src="https://img-blog.csdnimg.cn/390be99faa49499ca5fb7d0272328a26.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXVtaW5nZ3VpY2Fp,size_17,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>发现了吗？所有放在on方法外面的代码，即使是放在on方法后面的代码都会先于on方法执行，on方法本身放到最后执行。在PTA中所有的主体代码都是基于输入进行操作的，还没有输入就执行了处理代码，这算什么呢？所以一定要将做题的主体代码放在回调函数里面，但同时我推荐将所有用到的变量的声明都放在外面，这样当我们遇到多行输入的情况、回调函数被反复执行时不会将某些变量反复声明或者初始化，从而出现bug。可以看一下我后面的题目的题解代码，变量声明都是放在on方法外面的。</p><blockquote><p>额，如果有了解js异步编程的话应该知道像on方法注册的事件监听器这种就是一种异步，这个监听器注册完就会被放在一边放着持续监听事件，然后程序会将其他非异步的代码放在一起先执行掉，异步代码比如事件监听器只有当事件触发时才会执行。这是个比较粗浅的解释，详细的可以自己有时间去了解一下异步编程。</p></blockquote><p>回归正题，何时使用<code>rl.close()</code>方法呢？Emm。。。其实不用也可以，虽然这样会让程序在所有代码执行完后仍然处于等待输入状态，但是对于PTA而言只要输入完了也都处理完了也都输出完了，那就可以评判结果了，所以说不用也可以，没有影响。但是作为强迫症的我是一定要想办法结束输入从而彻底结束整个程序的，而且这里可以顺便一提多行输入时要注意的点。办法也很简单：<strong>把<code>rl.close();</code>放到整个程序执行的过程里的最后一步，注意不是指回调函数里代码的最后一行</strong>！因为只要在程序执行过程中碰到了<code>rl.close();</code>,整个程序就结束了（on方法会放到最后执行），而在一些多行输入的过程中回调函数会被执行多次，如果直接把<code>rl.close();</code>放在回调函数里的最后一行，那么回调函数第一次执行完整个程序就结束了，根本没有去读取接下来几行的输入的机会，对吧？</p><p>当然很明显这种影响也只有在多行输入的时候才会有，如果只有一行输入的话<code>rl.close();</code>肯定是直接放在回调函数里的最后一行了。那么多行输入时将<code>rl.close();</code>放在哪里呢（当然是整个程序执行的过程里的最后一步！！！）？看下面的代码：<br><img src="https://img-blog.csdnimg.cn/f8baf2aeadf44a3fbf9e8d869f4c3169.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXVtaW5nZ3VpY2Fp,size_15,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>这里在on方法外（也必须在on方法外！）声明了一个lineNumber变量来存储输入行的行号（从0开始，当然你想从1开始也可以），假设我们知道这个程序只接受4行的输入（实际上在PTA做题时多数需要多行输入的题目都是事先知道需要接受多少行输入的），那么上图中的 if 语句和<code>lineNumber++;</code>配合起来就能标记当前是第几行输入，对于每一行应当做什么样的处理（很多题目需要对多行输入中的不同行做不同的处理，比如第一行作为数字处理，其他行作为字符串处理），以及如果到了最后一行时在 if 里放一个<code>rl.close();</code>就行了，这样才算是将其放在了整个程序的结束处。这样我们就能处理多行输入的情况了。</p><p>关于多行输入还有一个小技巧，就是我们在vscode上自己调试程序时如果在控制台手动一行一行输入的话是很麻烦的，即使是一行一行复制粘贴也是很麻烦的，我推荐在当前js文件的同级位置新建一个文本文件，将多行输入的内容放在里面，输入时可以直接将一整个多行的内容复制粘贴进控制台里，这样跟你一行一行输入进去的效果是一样的。</p><p>对了，最后再提一点：在vscode中断点调试js代码时，on方法内部的代码是无法调试的（可能是因为它是异步代码吧），调试到on方法时会直接跳过去。想要调试其内部代码的话就要把它们拎出来新建一个文件单独调试了。</p><p>关于用Node.js读取输入就讲这么多了，想要用得熟练就要在实战中慢慢练习了。</p><h3 id="Node-js获取输入微总结"><a href="#Node-js获取输入微总结" class="headerlink" title="Node.js获取输入微总结"></a>Node.js获取输入微总结</h3><blockquote><p>1.回调函数的参数（可命名为line、data等）就是输入的字符串形式。<br>2.每次只接受一行输入，一行输入完毕就会将回调函数整个执行一遍。<br>3.多行输入时需借助lineNumber变量来标记当前是第几行输入，便于对不同行进行不同的处理以及将<code>rl.close()</code>方法放在合适的位置。别忘了<code>lineNumber++</code>这行代码！<br>4.自己本地调试程序时快速多行输入的小技巧。</p></blockquote><h2 id="如何输出"><a href="#如何输出" class="headerlink" title="如何输出"></a>如何输出</h2><p>输出其实很简单，即<code>console.log();</code>。不过只会这个的话就会有点问题，因为PTA的输出格式是要求非常严格的，比如末尾不能有多余的空格、空行等等，否则就会报“格式错误”的错误。而<code>console.log();</code>的输出会在最后面自动加一个换行符，也就是说会让最后一行输出后面多一个空行。为了解决这个问题，如果想要输出不带换行符的输出（类似于C语言中的<code>printf </code>函数那样），可以用<code>process.stdout.write()</code>方法来替代<code>console.log()</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">process.<span class="property">stdout</span>.<span class="title function_">write</span>(<span class="string">&#x27;hello!&#x27;</span>);</span><br><span class="line">process.<span class="property">stdout</span>.<span class="title function_">write</span>(<span class="string">&#x27;hi!&#x27;</span>);</span><br><span class="line">process.<span class="property">stdout</span>.<span class="title function_">write</span>(<span class="string">&#x27;hey!&#x27;</span>);</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//hello!hi!hey!</span></span><br></pre></td></tr></table></figure><p>只要是用node运行的js代码都可以直接使用这个方法。</p><p>有一点要特别注意！就是这个<code>process.stdout.write()</code>方法的参数必须是字符串类型，不然会报错！如果你的代码报了像下面这样的错误：</p><p><img src="https://img-blog.csdnimg.cn/771b656ad7bc44eea81265cccdee2892.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXVtaW5nZ3VpY2Fp,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>就要认真检查一下你的<code>process.stdout.write()</code>方法的参数是不是有问题了。</p><p>好了，关于 Node.js 如何输入输出就到这里，剩下的就要靠大家自己去实战练习了。</p>]]></content>
      
      
      <categories>
          
          <category> Node.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Python的 you-get 库 + FFmpeg 工具下载B站视频</title>
      <link href="/article/28b1fd971f7a.html"/>
      <url>/article/28b1fd971f7a.html</url>
      
        <content type="html"><![CDATA[<div class="note info mordern flat"><p>本文为我2021年10月8日在CSDN上发的第二篇文章，现在稍加改动并搬运到本站上来。</p></div><p>电脑系统环境：Windows 10</p><h2 id="准备阶段（安装you-get和FFmpeg）"><a href="#准备阶段（安装you-get和FFmpeg）" class="headerlink" title="准备阶段（安装you-get和FFmpeg）"></a>准备阶段（安装you-get和FFmpeg）</h2><p>安装非常简单，出现问题可以在网上参考其他资料。</p><p>you-get：直接命令行<code>pip install you-get</code>即可。</p><p>FFmpeg：这个要去其官网下载，我在这里把链接贴出来：<a href="https://www.gyan.dev/ffmpeg/builds/#release-builds">FFmpeg Windows版下载链接</a></p><p>在relase-builds那一块的latest-release（最新版）或者previous-release（历史版本）中，找一个zip压缩包即可。7z压缩包或许也可，反正我下的是zip。</p><p>反正解压完之后文件夹里面是这样的就对了：<br><img src="https://img-blog.csdnimg.cn/3509d21aafed403d91d8458e125db2c1.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXVtaW5nZ3VpY2Fp,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>文件夹路径应该不一样，这个是我自己设置的，我喜欢搞成这样，看着舒服一点。。。</p><p>至此安装阶段结束。</p><h2 id="配置环境阶段"><a href="#配置环境阶段" class="headerlink" title="配置环境阶段"></a>配置环境阶段</h2><p>you-get没什么好配置的，主要是FFmpeg，我们在这一步把它的路径加到环境变量里面去就可以了。</p><p>添加环境变量的流程基本相同，这里再说明一下：</p><p>在“此电脑”上右击，点击属性，再找到高级系统设置，点进去，找环境变量，点进去：</p><p><img src="https://img-blog.csdnimg.cn/9334a5d08eb14664821108678e74cfb0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXVtaW5nZ3VpY2Fp,size_9,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/f7368405282b4192a72b0fb724480c4b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXVtaW5nZ3VpY2Fp,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="E:/MyProjects/blog/source/_posts/2022081502.assets/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXVtaW5nZ3VpY2Fp,size_16,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"><br>点进去用户变量中的Path：</p><p><img src="https://img-blog.csdnimg.cn/aa3611133aa04446bdf1d6aba69a95ca.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXVtaW5nZ3VpY2Fp,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>点击“新建”，新建一个环境变量，把自己的这个bin文件夹的路径复制粘贴进去就行了：<br><img src="https://img-blog.csdnimg.cn/025ba6b56b52406ea5438858fc87f117.png" alt="在这里插入图片描述"><br>至此配置完成，可以打开cmd命令行（不用多说了吧），然后输入<code>ffmpeg -version</code>，查看版本，若看到差不多是这样：<br><img src="https://img-blog.csdnimg.cn/57d9a192e38b4573b6a9fe7d5ae43b9b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXVtaW5nZ3VpY2Fp,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>就说明添加环境变量已经成功了。</p><p>至此配置阶段结束。</p><h2 id="开始下载B站视频"><a href="#开始下载B站视频" class="headerlink" title="开始下载B站视频"></a>开始下载B站视频</h2><p>大家下载you-get的时候可能已经知道了这个东西可以下载现在网上大多数主流视频网站的视频，但是为什么还要安装这个ffmpeg呢?下面会有说明。</p><p>首先随便打开一个B站视频，我选择了这个：<a href="https://www.bilibili.com/video/BV1JV411t7ow?p=1">中科大郑烇、杨坚全套《计算机网络（自顶向下方法 第7版，James F.Kurose，Keith W.Ross）》（P1 课程目标）</a></p><p>然后我们打开命令行，此处最好是新建一个你准备放置下载的视频的文件夹，然后将命令行的工作目录转到此文件夹，因为you-get视频默认下载位置就是命令行当前的工作目录。</p><p>如下：<br><img src="https://img-blog.csdnimg.cn/8194f31a223743dc82e6857165553234.png" alt="在这里插入图片描述"><br>然后就像上面那样输入<code>you-get -i [视频url地址]</code>，稍等片刻，等它的解析结果出来，差不多是这个样子的：<br><img src="https://img-blog.csdnimg.cn/b53109334f3e4218b8cb0a7ed68f22fd.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXVtaW5nZ3VpY2Fp,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>视频站点、视频名称、视频大小、清晰度等等都给我们列出来了。看到下面的两大部分没？DASH和DEFAULT，这两个部分里面都是可下载的视频格式，其中DASH中下载的是MP4的视频格式，DEFAULT中下载的是flv的视频格式。flv格式的视频无法直接播放，这时候就需要用我们刚刚安装的FFmpeg工具来转换格式了，这也是我们为什么要安装FFmpeg的原因之一。</p><p>将flv视频转换为MP4格式视频方法如下（不过我在使用的时候出了一点小问题）：<br><img src="https://img-blog.csdnimg.cn/2eeddb59c2944015941479f4b40823f2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXVtaW5nZ3VpY2Fp,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>DASH或者DEFAULT中每一项都给出了可下载视频的清晰度和下载命令（#download-with字段)，清晰度建议下载720P或者1080P的，下载命令只要把 [URL] 替换为实际视频的网址就行了。</p><p>建议使用DASH中的命令下载MP4格式视频，第一这样省去了我们手动转换格式的麻烦，尤其是我们在下载时可以在视频网址前面加上–playlist命令把这个视频所在的那一全套的视频都一次性下载下来（但是得当你解析视频信息完成后看到一条可以使用–playlist命令的提示之后才能这么做，一般能这么干的都是B站上的分P视频），如果下载flv格式视频一个个转换还是比较麻烦的（据说可以写C语言程序来自动转换，不过我不会，可参考其他资料)，第二，我在把用DEFAULT中命令下载下来的flv视频转换之后没有视频，只有音频，这个问题我也不知道是怎么回事，也还没有进行进一步研究，反正我觉得用DASH 中的指令下载比较好。</p><p>这里就要提到我们为什么要安装FFmpeg的原因之二了。如果视频大小比较大的话you-get会将它分成两部分下载——视频和音频，也就是说如果没有安装FFmpeg的话你把一个视频下载下来会发现有两个mp4文件，一个是视频（没有声音），一个是音频（没有图像），当然如果你就是想搞一个音视频分离的这也可以，但是正常情况下我们需要它们俩合二为一，也就是安装FFmpeg并配置完成之后you-get将视频的两部分下载下来之后会自动将它们俩合成一个视频（有声音有图像）：<br><img src="https://img-blog.csdnimg.cn/f2bcc5fb14274f439c57251a64ffefff.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXVtaW5nZ3VpY2Fp,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>就是这个Merging的过程。</p><p>这样我们就把B站的视频下载下来了。然后下载的同时you-get会在下载目录里生成一些xml文件，这些是可以删除的。可以直接删除，或者太多了不想手动删也可以用命令行指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del *.xml</span><br></pre></td></tr></table></figure><p>至此就完成了you-get + FFmpeg下载B站视频的任务了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用Python的you-get库结合FFmpeg来下载B站视频的方法总结起来如下：</p><ol><li>如果你已经准备好了you-get库和FFmpeg工具并配置好了FFmpeg的环境变量，你需要去复制一下你要下载的B站视频的网址，然后在你要保存视频的目录下进入命令行，输入<code>you-get -i 视频网址</code>来解析视频信息，看看有哪些清晰度可供下载；</li><li>解析完毕后你可以查看DEFAULT和DASH中的每一项，选择你满意的一个清晰度然后输入#download-with字段中介绍的命令来下载相应的视频，推荐使用DASH中的命令来下载mp4视频。不过要注意清晰度越大视频越大，下载时间可能就越长，网络不佳的时候尤其要注意；</li><li>下载完成后可以手动清除目录里的xml文件。</li></ol><p>可以看出主要步骤只有两步，即解析和下载。</p><p>当然，you-get还可以下载其他一些视频网站上面的视频（VIP视频什么的大概还是没戏吧），而FFmpeg的用处也绝不止上面提到的那样，它们的其他用途大家就自己去慢慢探索了。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> you-get库 </tag>
            
            <tag> FFmpeg </tag>
            
            <tag> 下载视频 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用urllib.robotparser模块解析某些网站的robots文件时本应返回True的结果却返回了False是怎么回事？</title>
      <link href="/article/87e42dc57f76.html"/>
      <url>/article/87e42dc57f76.html</url>
      
        <content type="html"><![CDATA[<div class="note info mordern flat"><p>本文为我2021年5月29日在CSDN上发的第一篇文章，现在稍加改动并搬运到本站上来。</p></div><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>用以下代码尝试分析简书网站的robots文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.robotparser <span class="keyword">import</span> RobotFileParser</span><br><span class="line">rp = RobotFileParser(<span class="string">&#x27;https://www.jianshu.com/robots.txt&#x27;</span>)</span><br><span class="line">rp.read()</span><br><span class="line"><span class="built_in">print</span>(rp.can_fetch(<span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;https://www.jianshu.com/mobile/campaign/day_by_day/join?from=home&#x27;</span>))</span><br></pre></td></tr></table></figure><p>通过观察简书的robots文件推断这里的代码返回结果应该是True，但实际执行时却返回了False。</p><h2 id="原因探索"><a href="#原因探索" class="headerlink" title="原因探索"></a>原因探索</h2><p>首先要了解can_fetch（）方法返回True或False的逻辑是什么样的。在Pycharm中查看can_fetch()方法的部分源码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">can_fetch</span>(<span class="params">self, useragent, url</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;using the parsed robots.txt decide if useragent can fetch url&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> self.disallow_all:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> self.allow_all:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>可见该方法会首先判断disallow_all属性的值，若为True就将返回False。而这个属性在RobotFileParser类中的默认值是False，也就是说在程序执行过程中它的值被修改为True了。而前面只有一个read（）方法可能修改了它的值，所以来看看read（）方法的源码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">read</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Reads the robots.txt URL and feeds it to the parser.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        f = urllib.request.urlopen(self.url)</span><br><span class="line">    <span class="keyword">except</span> urllib.error.HTTPError <span class="keyword">as</span> err:</span><br><span class="line">        <span class="keyword">if</span> err.code <span class="keyword">in</span> (<span class="number">401</span>, <span class="number">403</span>):</span><br><span class="line">            self.disallow_all = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> err.code &gt;= <span class="number">400</span> <span class="keyword">and</span> err.code &lt; <span class="number">500</span>:</span><br><span class="line">            self.allow_all = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        raw = f.read()</span><br><span class="line">        self.parse(raw.decode(<span class="string">&quot;utf-8&quot;</span>).splitlines())</span><br></pre></td></tr></table></figure><p>可以看到read（）方法的本质就是先用urlopen()方法打开上面传入给类的网址，如果这个过程中出现了401或403的HTTPError异常就把disallow_all属性修改为True。如果没有异常的话就会执行else语句块中的代码。</p><p>所以我们就直接用urlopen（）方法打开一下那个网址看会发生什么(下面代码默认已经导入了urllib库及相关模块)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(urllib.request.urlopen(<span class="string">&#x27;http://www.jianshu.com/robots.txt&#x27;</span>))</span><br></pre></td></tr></table></figure><p>返回是这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;input&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">&quot;D:\Program Files\Python\Python38\lib\urllib\request.py&quot;</span>, line <span class="number">222</span>, <span class="keyword">in</span> urlopen</span><br><span class="line">    <span class="keyword">return</span> opener.<span class="built_in">open</span>(url, data, timeout)</span><br><span class="line">  File <span class="string">&quot;D:\Program Files\Python\Python38\lib\urllib\request.py&quot;</span>, line <span class="number">531</span>, <span class="keyword">in</span> <span class="built_in">open</span></span><br><span class="line">    response = meth(req, response)</span><br><span class="line">  File <span class="string">&quot;D:\Program Files\Python\Python38\lib\urllib\request.py&quot;</span>, line <span class="number">640</span>, <span class="keyword">in</span> http_response</span><br><span class="line">    response = self.parent.error(</span><br><span class="line">  File <span class="string">&quot;D:\Program Files\Python\Python38\lib\urllib\request.py&quot;</span>, line <span class="number">563</span>, <span class="keyword">in</span> error</span><br><span class="line">    result = self._call_chain(*args)</span><br><span class="line">  File <span class="string">&quot;D:\Program Files\Python\Python38\lib\urllib\request.py&quot;</span>, line <span class="number">502</span>, <span class="keyword">in</span> _call_chain</span><br><span class="line">    result = func(*args)</span><br><span class="line">  File <span class="string">&quot;D:\Program Files\Python\Python38\lib\urllib\request.py&quot;</span>, line <span class="number">755</span>, <span class="keyword">in</span> http_error_302</span><br><span class="line">    <span class="keyword">return</span> self.parent.<span class="built_in">open</span>(new, timeout=req.timeout)</span><br><span class="line">  File <span class="string">&quot;D:\Program Files\Python\Python38\lib\urllib\request.py&quot;</span>, line <span class="number">531</span>, <span class="keyword">in</span> <span class="built_in">open</span></span><br><span class="line">    response = meth(req, response)</span><br><span class="line">  File <span class="string">&quot;D:\Program Files\Python\Python38\lib\urllib\request.py&quot;</span>, line <span class="number">640</span>, <span class="keyword">in</span> http_response</span><br><span class="line">    response = self.parent.error(</span><br><span class="line">  File <span class="string">&quot;D:\Program Files\Python\Python38\lib\urllib\request.py&quot;</span>, line <span class="number">569</span>, <span class="keyword">in</span> error</span><br><span class="line">    <span class="keyword">return</span> self._call_chain(*args)</span><br><span class="line">  File <span class="string">&quot;D:\Program Files\Python\Python38\lib\urllib\request.py&quot;</span>, line <span class="number">502</span>, <span class="keyword">in</span> _call_chain</span><br><span class="line">    result = func(*args)</span><br><span class="line">  File <span class="string">&quot;D:\Program Files\Python\Python38\lib\urllib\request.py&quot;</span>, line <span class="number">649</span>, <span class="keyword">in</span> http_error_default</span><br><span class="line">    <span class="keyword">raise</span> HTTPError(req.full_url, code, msg, hdrs, fp)</span><br><span class="line">urllib.error.HTTPError: HTTP Error <span class="number">403</span>: Forbidden</span><br></pre></td></tr></table></figure><p>看最后一行！发生了403错误。</p><p>至此就圆上了，那么为什么本该返回True的结果却返回了False就很清楚了。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>解决方法可能不止一种，我这里给出我思考后得出的方案。</p><p>要解决这个问题，首先要避免403错误的发生。</p><p>这里的403错误产生原因可能是发送请求时没有加上请求头信息，或者至少是没有加上User-Agent信息。所以如果我们发送请求时加入自己的User-Agent信息就好了。</p><p>如何利用浏览器获取自己的User-Agent信息请自行上网搜索，此处不再赘述。</p><p>但是这样有个问题，RobotFileParser类中没有哪个方法是可以让你发送加入User-Agent信息的请求的，有一个能发送请求的read（）方法，但没办法这么用。</p><p>但是，观察上面的read（）方法源码发现它其实就是urlopen()方法打开网址，然后如果不发生异常的话就用读取文件的那个python内置的read()方法读取结果，然后再调用这个类中的parse（）方法。所以can_fetch()方法的返回结果其实主要是依赖于parse()方法的解析结果的。</p><p>所以！思路就出来了~</p><p>我们直接手动编写代码代替原来直接调用read()方法的这一部分，即发送加入User-Agent信息的请求然后得到返回结果，然后直接把结果手动发送给parse（）方法，即调用RobotFileParser对象的parse方法，这样的话一切就能正常运行了。</p><p>所以最终方案如下：</p><p>（怎么加入User-Agent信息然后发送请求这个也可以自己去搜索，一般有build_opener()和add_header()两种思路，这里用第一个）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">from</span> urllib.robotparser <span class="keyword">import</span> RobotFileParser</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://jianshu.com/robots.txt&#x27;</span></span><br><span class="line">headers = (<span class="string">&#x27;User-Agent&#x27;</span>, <span class="keyword">pass</span>)  <span class="comment"># pass处是自己的User-Agent字符串</span></span><br><span class="line">opener = urllib.request.build_opener()</span><br><span class="line">opener.addheaders = [headers]</span><br><span class="line">data = opener.<span class="built_in">open</span>(url).read().decode(<span class="string">&#x27;utf-8&#x27;</span>).splitlines()  <span class="comment"># 参考read（）方法源码的最后一行</span></span><br><span class="line"></span><br><span class="line">rp = RobotFileParser(url)</span><br><span class="line">rp.parse(data)  <span class="comment"># 这里就代替了read()方法的最后一行的功能</span></span><br><span class="line"><span class="built_in">print</span>(rp.can_fetch(<span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;https://www.jianshu.com/mobile/campaign/day_by_day/join?from=home&#x27;</span>))</span><br></pre></td></tr></table></figure><p>运行一下，结果得到了True，搞定。</p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>建站记录系列（二）——正式建站</title>
      <link href="/article/2601d0bcdbb7.html"/>
      <url>/article/2601d0bcdbb7.html</url>
      
        <content type="html"><![CDATA[<p>买好服务器之后可以进入“云服务器ECS”控制台页面来查看自己服务器的情况以及对它进行各种操作。最重要的是，你现在可以知道你的服务器的公网ip地址。</p><h2 id="SSH登录服务器"><a href="#SSH登录服务器" class="headerlink" title="SSH登录服务器"></a>SSH登录服务器</h2><p>首先如果是win10的电脑的话，可以查看一下有没有自带的一个叫openssh的工具，可以在命令行输入命令<code>ssh -V</code>回车查看，有openssh的版本信息就是有该工具，可以直接登录了。如果没有，就自己下一个好了_(:з)∠) _，或者看一看有什么其他的比较中意的ssh工具，我这里用的就是我的win10电脑自带的openssh。</p><p>ssh连接服务器的命令：<code>ssh root@你的服务器公网IP</code>，root表示以root用户身份登录服务器，root用户是有最高权限的用户。</p><p>输入完该命令回车之后需要输入服务器密码，由于Linux系统中输入密码屏幕上不会有任何反应，所以不要以为出了什么bug，就安心把密码正确输入就行了，然后回车，就以root用户身份登录到服务器上了。</p><blockquote><p>ssh登录到服务器之后如果一段时间不操作就会断连无响应，这时只能等待它自动退出或者直接关闭命令行窗口再重新连接一下。</p></blockquote><h2 id="CentOS7系统安装nginx"><a href="#CentOS7系统安装nginx" class="headerlink" title="CentOS7系统安装nginx"></a>CentOS7系统安装nginx</h2><p>本文采用命令行操作方式进行nginx软件的安装。</p><h3 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h3><p>首先去<a href="https://nginx.org/en/download.html">nginx官网下载页面</a>下载“Stable version”中中间的那个文件：</p><p><img src="https://elzzach-src.oss-cn-hangzhou.aliyuncs.com/img/20220806/image-20220723163159459.png" alt="image-20220723163159459"></p><p>下载下来是一个带有<code>.tar.gz</code>后缀名的压缩文件。然后我们要把这个文件上传到服务器的文件夹中，我选择的是上传到&#x2F;opt&#x2F;tools文件夹中，tools文件夹是我新建的。</p><h3 id="上传到服务器"><a href="#上传到服务器" class="headerlink" title="上传到服务器"></a>上传到服务器</h3><p>上传有两种方式：下载WinSCP软件用可视化界面来传输文件以及管理服务器文件，这样比较方便。或者使用scp命令将该文件复制到相应的远程目录中。我选择的是使用winscp软件，软件的下载安装和使用方法都很容易解决。</p><h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><p>将nginx安装包上传到&#x2F;opt&#x2F;tools目录中后用cd命令进入该目录中，然后运行解压命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf nginx-1.22.0.tar.gz</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>这时该目录下就会出现一个叫nginx-1.22.0的目录，用cd命令进入该目录下，然后执行配置命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --with-http_stub_status_module --with http_ssl_module</span><br></pre></td></tr></table></figure><p>这条命令后面两个参数是为了以后服务器安装ssl证书做准备的，不然只执行<code>./configure</code>命令的话之后安装ssl证书会提示缺少ssl模块，到时还要重新编译安装比较麻烦（没错就是我踩的坑），所以现在就安装好。</p><p>这条命令执行之后对云服务器来说一般不会有什么问题，但假如出现了一些报错则解决方案如下：</p><p>报错1：<code>error: the HTTP rewrite module requires the PCRE library.</code></p><p>解决方案：在当前工作目录下接着执行<code>yum -y install pcre-devel</code>命令安装所需依赖即可，然后将配置命令再执行一遍。</p><p>报错2：<code>error: SSL modules require the OpenSSL library.</code></p><p>解决方案：在当前工作目录下接着执行<code>yum -y install openssl openssl-devel</code>命令安装所需依赖即可，然后将配置命令再执行一遍。</p><p>其他报错的话自己将报错信息复制粘贴去搜索引擎搜索一下。</p><p>这两个报错是我在自己电脑上的VMware虚拟机的Linux系统里安装nginx时遇到的，当初在云服务器上安装nginx并没有碰到这两个问题，应该是服务器自带了这些依赖。</p><p>出现下图这种输出时就说明配置成功了：</p><p><img src="https://elzzach-src.oss-cn-hangzhou.aliyuncs.com/img/20220806/image-20220723180517257.png" alt="image-20220723180517257"></p><h3 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h3><p>配置成功之后依次执行以下两条命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>等待约二三十秒后安装完成，出现类似于下面的输出：</p><p><img src="https://elzzach-src.oss-cn-hangzhou.aliyuncs.com/img/20220806/image-20220723181008997.png" alt="image-20220723181008997"></p><p>这样的话我们的nginx就算安装好了，接下来我们需要启动它一下来验证安装成功以及配置环境变量。</p><h3 id="启动并访问80端口"><a href="#启动并访问80端口" class="headerlink" title="启动并访问80端口"></a>启动并访问80端口</h3><p><img src="https://elzzach-src.oss-cn-hangzhou.aliyuncs.com/img/20220806/image-20220723181410004.png" alt="image-20220723181410004"></p><p>在上面的输出中红框区域告诉了我们nginx被安装在了哪个目录下，即&#x2F;usr&#x2F;lcoal&#x2F;nginx&#x2F;是我们nginx的所在目录。或者也可以在命令行执行<code>whereis nginx</code>命令来查看。</p><p>以此为例，用cd命令进入&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin目录中，然后执行<code>./nginx</code>命令来启动nginx。</p><p>启动之后我们可以用浏览器访问<code>http://服务器公网ip</code>来看看是否出现了nginx的欢迎页面：</p><p><img src="https://elzzach-src.oss-cn-hangzhou.aliyuncs.com/img/20220806/image-20220723181822290.png" alt="image-20220723181822290"></p><p>出现了就说明启动成功。可能的情况是服务器80端口未开放或者被防火墙挡住了。一般来说阿里云服务器买来之后80端口默认是开放的，可以在<strong>服务器安全组配置</strong>中查看自己服务器的端口开放情况以及通过增减安全组规则来增加开放端口或关闭端口。</p><p>当安全组规则配置好后仍不能访问可能是服务器防火墙问题，可以用如下命令查看并解决：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看防火墙放开的端口</span></span><br><span class="line">firewall-cmd --zone=public --list-ports</span><br><span class="line"><span class="comment"># 放开指定端口</span></span><br><span class="line">firewall-cmd --zone=public --add-port=80/tcp --permanent</span><br><span class="line"><span class="comment"># 配置立即生效</span></span><br><span class="line">firewall-cmd --reload</span><br><span class="line"><span class="comment"># 关闭指定端口</span></span><br><span class="line">firewall-cmd --zone=public --remove-port=4000/tcp --permanent</span><br></pre></td></tr></table></figure><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打开环境变量配置文件</span></span><br><span class="line">vim /etc/profile</span><br><span class="line"><span class="comment"># 在文件末尾加入nginx的位置，即上面whereis命令告诉我们的位置</span></span><br><span class="line"><span class="built_in">export</span> NGINX_HOME=/usr/local/nginx</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$NGINX_HOME</span>/sbin</span><br><span class="line"><span class="comment"># 使配置生效</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br><span class="line"><span class="comment"># 校验配置是否成功，查看nginx版本</span></span><br><span class="line">nginx -v</span><br></pre></td></tr></table></figure><p>到此我们的nginx的安装就正式完成了。</p><h2 id="本地部署hexo"><a href="#本地部署hexo" class="headerlink" title="本地部署hexo"></a>本地部署hexo</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>本地部署hexo需要先安装nodejs包和git，安装方法请自行搜索。</p><p>Windows安装git可以看廖雪峰老师的教程所说的：</p><p><img src="https://elzzach-src.oss-cn-hangzhou.aliyuncs.com/img/20220806/image-20220730090839398.png" alt="image-20220730090839398"></p><h3 id="部署hexo"><a href="#部署hexo" class="headerlink" title="部署hexo"></a>部署hexo</h3><h4 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h4><p>如果nodejs环境变量已经配置好，那么直接进入命令行输入命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全局安装hexo-cli包</span></span><br><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><h4 id="初始化博客目录"><a href="#初始化博客目录" class="headerlink" title="初始化博客目录"></a>初始化博客目录</h4><p>为博客新建一个文件夹，例如<code>E:\\MyProjects\\blog</code>，下文将用“博客根目录”或“hexo根目录”称呼这个地址。</p><p>将命令行工作目录切到博客根目录下，输入命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><p>稍等片刻你的博客根目录下就会出现一些文件夹了，目录结构及每个文件夹、文件的作用请看<a href="https://hexo.io/zh-cn/docs/setup">官方文档</a>。</p><p>这时就可以在博客根目录下输入预览命令<code>hexo s</code>然后等待片刻访问它给你的本地地址就可以看到初始效果了。</p><h4 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h4><p>本站使用的是butterfly主题，主题官网：<a href="https://butterfly.js.org/">https://butterfly.js.org/</a></p><p>主题安装方法：<a href="https://butterfly.js.org/posts/21cfbf15/">https://butterfly.js.org/posts/21cfbf15/</a></p><p>实际上hexo主题的安装基本都是这样，在hexo根目录下用git clone命令将相应的主题仓库克隆过来即可，然后就会在themes文件夹里找到相应的主题文件夹了。</p><p>安装好之后记得打开hexo根目录下的hexo配置文件_config.yml找到其中的theme字段将其改成hexo-theme-butterfly以应用主题。其他的工作就需要参考主题文档了，例如对于butterfly主题而言还需要安装两个插件才能渲染出来。</p><p>所有工作完成以后在hexo根目录下执行<code>hexo s</code>预览命令即可看到主题默认效果。</p><blockquote><p>搭建博客过程中要勤看hexo文档和主题文档，认真研读，会发现很多的东西。</p></blockquote><h2 id="服务器部署hexo"><a href="#服务器部署hexo" class="headerlink" title="服务器部署hexo"></a>服务器部署hexo</h2><h3 id="本地配置ssh密钥"><a href="#本地配置ssh密钥" class="headerlink" title="本地配置ssh密钥"></a>本地配置ssh密钥</h3><p>以win10为例，如果用过Github并且进行过远程仓库的推送的话那么在用户目录底下应该有一个.ssh目录，以及目录下应该有一个id_rsa和id_rsa.pub文件。如果没有，在命令行里执行<code>ssh-keygen -t rsa -C &quot;邮箱地址&quot;</code>命令生成ssh密钥即可。</p><h3 id="服务器安装git"><a href="#服务器安装git" class="headerlink" title="服务器安装git"></a>服务器安装git</h3><p>登录服务器，直接执行<code>yum install git</code>命令即可。</p><h3 id="创建专门用于hexo推送的用户并设置权限"><a href="#创建专门用于hexo推送的用户并设置权限" class="headerlink" title="创建专门用于hexo推送的用户并设置权限"></a>创建专门用于hexo推送的用户并设置权限</h3><p>这一步的目的是创建一个专门用于hexo推送的用户并设置相关的权限，然后通过配置ssh密钥使本地电脑能够，所需要执行的命令总结如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先以root用户身份登录服务器</span></span><br><span class="line">adduser git <span class="comment"># 创建一个叫git的新用户</span></span><br><span class="line"><span class="built_in">chmod</span> 740 /etc/sudoers <span class="comment"># 设置权限使得git用户能够读写sudoers文件</span></span><br><span class="line">vim /etc/sudoers <span class="comment"># 用vim编辑器打开sudoers文件</span></span><br></pre></td></tr></table></figure><p>进入vim编辑器界面后先敲i键进入编辑模式将光标移到以下内容位置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">## Allow root to run any commands anywhere</span><br><span class="line">root    ALL=(ALL)     ALL</span><br></pre></td></tr></table></figure><p>在下面新建一行输入以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git     ALL=(ALL)     ALL</span><br></pre></td></tr></table></figure><p>即为git用户设置能够执行sudo命令的权限。</p><p>然后按esc键退出编辑模式，并依次输入:wq来保存并退出vim。</p><p>然后：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 400 /etc/sudoers <span class="comment"># 将git用户对该文件的权限设置为只读</span></span><br><span class="line">sudo passwd git <span class="comment"># 设置git账户的密码，Linux输入密码是不显示的，输入完直接回车就行</span></span><br><span class="line">su git <span class="comment"># 切换至git用户</span></span><br><span class="line"><span class="built_in">mkdir</span> /root/.ssh <span class="comment"># 在root目录下创建.ssh文件夹，当然创建之前可以先确认一下root目录下有没有该文件夹，可以用ls -a命令查看</span></span><br><span class="line">vim /root/.ssh/authorized_keys <span class="comment"># 用vim打开该文件，没有的会直接新建</span></span><br></pre></td></tr></table></figure><p>按i键进入编辑模式，然后在本地电脑上用记事本打开刚刚提到的id_rsa.pub文件，将其中的公钥内容复制到authorized_keys文件中（如果是用命令行登录服务器的话，粘贴是点击鼠标右键粘贴而不是ctrl+v，我不清楚这个是不是随不同品牌电脑而变化的），然后退出编辑模式并保存文件退出vim。</p><p>然后：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 600 /home/git/.ssh/authorized_keys <span class="comment"># 将这个文件权限设置为可读写</span></span><br><span class="line"><span class="built_in">chmod</span> 700 /home/git/.ssh <span class="comment"># 将这个目录权限设置为可进入、查看和修改</span></span><br></pre></td></tr></table></figure><p>这时候我们本地电脑应该就能免密登录git用户了，可以在本地执行命令<code>ssh git@服务器ip</code>看是不是不需要输入密码就能登录了。</p><blockquote><p>我是很顺利就成功了，如果碰到报错，请自行搜索并凭借自身的linux知识解决。。。</p></blockquote><blockquote><p>另外通过这一步我们可以看出对于hexo博客而言我们只能在我们部署的这台电脑上写文章推送，因为只有这台电脑上有相应的公钥和密钥，如果换了电脑，就要重新生成公钥和密钥并修改服务器上的authorized_keys文件或者将原来的公钥、密钥文件迁移到新电脑上。</p></blockquote><h3 id="仓库创建及相关配置"><a href="#仓库创建及相关配置" class="headerlink" title="仓库创建及相关配置"></a>仓库创建及相关配置</h3><p>在服务器上新建一个文件夹用作Git仓库的目录，例如&#x2F;var&#x2F;repo这个目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先将当前用户切换回到root用户</span></span><br><span class="line"><span class="built_in">mkdir</span> /var/repo</span><br></pre></td></tr></table></figure><p>然后：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chown</span> -R git:git /var/repo <span class="comment"># 将仓库目录的所有者设置为git用户</span></span><br><span class="line"><span class="built_in">chmod</span> -R 755 /var/repo <span class="comment"># 赋予对目录的进入、查看、修改权限</span></span><br></pre></td></tr></table></figure><p>再新建一个文件夹作为网站目录，例如&#x2F;var&#x2F;hexo这个目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /var/hexo</span><br><span class="line"><span class="built_in">chown</span> -R git:git /var/hexo</span><br><span class="line"><span class="built_in">chmod</span> -R 755 /var/hexo</span><br></pre></td></tr></table></figure><p>然后初始化git仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /var/repo</span><br><span class="line">git init --bare hexo.git</span><br></pre></td></tr></table></figure><p>创建Git钩子用于自动部署：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /var/repo/hexo.git/hooks/post-receive</span><br></pre></td></tr></table></figure><p>按i键然后输入以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">git --work-tree=/var/hexo --git-dir=/var/repo/hexo.git checkout -f</span><br></pre></td></tr></table></figure><p>然后修改所有者和权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chown</span> -R git:git /var/repo/hexo.git/hooks/post-receive</span><br><span class="line"><span class="built_in">chmod</span> +x /var/repo/hexo.git/hooks/post-receive</span><br></pre></td></tr></table></figure><p>这样就行了，然后修改一下本地hexo配置文件_config.yml，将deploy字段中的type字段值写为git，然后将repo字段值写为<code>git@服务器ip:/var/repo/hexo.git</code>，服务器ip可以等域名解析到服务器上后改为域名；branch字段值为master。</p><p>这样服务器上hexo的部署就基本成功了，可以在博客根目录执行<code>hexo clean</code>、<code>hexo g</code>、<code>hexo d</code>命令来看是否能够部署成功。</p><p>可能会出现权限相关的问题，多试几次或者自行查阅资料解决，因为我当初没碰到什么问题 :D。</p><h2 id="网站对外提供访问"><a href="#网站对外提供访问" class="headerlink" title="网站对外提供访问"></a>网站对外提供访问</h2><h3 id="Nginx添加站点"><a href="#Nginx添加站点" class="headerlink" title="Nginx添加站点"></a>Nginx添加站点</h3><p>这一步只需要修改nginx的配置文件即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure><p>找到第一个你看到的具有“listen 80”字段的server节点，修改其中的location字段里的root字段，将它默认的值改为你网站的真实根目录，比如&#x2F;var&#x2F;hexo。</p><p>然后我们需要重载一下配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/nginx/sbin/</span><br><span class="line">./nginx -s reload</span><br></pre></td></tr></table></figure><p>然后在本地博客根目录执行一下<code>hexo clean</code>、<code>hexo g</code>、<code>hexo d</code>三件套命令进行推送，推送完访问一下你的服务器ip地址看看是否出现了正常的hexo+butterfly主题的页面。</p><h3 id="域名DNS解析"><a href="#域名DNS解析" class="headerlink" title="域名DNS解析"></a>域名DNS解析</h3><p>这一步是在阿里云的云解析DNS控制台完成的。</p><p>首先进入阿里云云解析DNS控制台，然后点击一个叫“添加域名”的按钮，然后将你当初购买的二级域名填进去，按提示操作即可。</p><p>接下来如果你想直接使用该二级域名作为你博客的域名的话在它里面添加一个A类型记录即可，主机记录直接填写@，记录值填写服务器的ip地址，解析线路和TTL值都保持默认。如果你想像本站一样使用一个三级域名作为博客域名，那还需要再点击一下添加域名按钮，然后填写你想使用的三级域名，例如<code>blog.example.com</code>，注意这里它可能会提示你要添加子域需要先进行TXT授权校验，点击它的提示获得主机记录（一般是alidnscheck）、记录值等信息，然后在自己刚刚的二级域名底下添加一条TXT类型的记录即可，主机记录和记录值填写你刚刚获取的（即alidnscheck和一条长长的乱七八糟的字符串）。等TXT校验成功之后就可以添加三级域名了，然后在该三级域名底下添加一条A记录，记录值填服务器ip地址。主机记录填写时要注意填写的是@而不是blog，因为输入框后面给出来的是你的三级域名，你需要让你填写的主机记录和后面给出的域名连起来读是你所需要的三级域名，@表示直接解析后面的域名。这一点在以后添加主机记录时也要注意，即并不是页面提示你添加哪个主机记录你就直接照搬，视你所添加记录的域名而定。</p><p>等待片刻记录生效之后就可以访问域名看看是否正常显示网站了。</p><p>如果有什么问题的话，可以多参考阿里云官方文档。</p><h3 id="安装SSL证书"><a href="#安装SSL证书" class="headerlink" title="安装SSL证书"></a>安装SSL证书</h3><p>这个不用多说，看这个<a href="https://help.aliyun.com/document_detail/98728.htm">官方教程</a>就够了。</p><p>总结起来就是：首先在阿里云SSL证书控制台为自己的域名申请免费证书，然后下载nginx服务器用的证书到本地，解压后获得pem文件和key文件，然后在服务器上nginx安装目录中的conf目录下新建cert目录（即&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;cert），将刚刚下载的两个证书文件上传到这个cert目录中，然后打开nginx配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure><p>添加一个server节点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#以下属性中，以ssl开头的属性表示与证书配置有关。</span><br><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    #配置HTTPS的默认访问端口为443。</span><br><span class="line">    #如果未在此处配置HTTPS的默认访问端口，可能会造成Nginx无法启动。</span><br><span class="line">    #如果您使用Nginx 1.15.0及以上版本，请使用listen 443 ssl代替listen 443和ssl on。</span><br><span class="line">    server_name yourdomain; # 你的域名</span><br><span class="line">    root html;</span><br><span class="line">    index index.html index.htm;</span><br><span class="line">    ssl_certificate cert/cert-file-name.pem;  # pem文件名</span><br><span class="line">    ssl_certificate_key cert/cert-file-name.key; # key文件名</span><br><span class="line">    ssl_session_timeout 5m;</span><br><span class="line">    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line">    #表示使用的加密套件的类型。</span><br><span class="line">    ssl_protocols TLSv1.1 TLSv1.2 TLSv1.3; #表示使用的TLS协议的类型，您需要自行评估是否配置TLSv1.1协议。</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line">    location / &#123;</span><br><span class="line">        root html;  #Web网站程序存放目录，依本文的例子就是/var/hexo</span><br><span class="line">        index index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重载配置即可。</p><p>如果想要配置http请求强制跳转https，那就再添加一个server节点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name yourdomain; #需要将yourdomain替换成证书绑定的域名。</span><br><span class="line">    rewrite ^(.*)$ https://$host$1; #将所有HTTP请求通过rewrite指令重定向到HTTPS。</span><br><span class="line">    location / &#123;</span><br><span class="line">        index index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>到这里一个hexo+butterfly主题的博客网站就搭好了，现在可以自己去探索一下hexo的配置文件和butterfly的配置文件看一看如何搭配自己喜欢的功能，如果想要美化甚至魔改的话那就多参考大佬们的博客站以及发挥自己的创意咯。</p><blockquote><p>本文在hexo服务器部署部分参考了该文章：<a href="https://blog.laoda.de/archives/hexo-building.html">将Hexo部署到阿里云轻量服务器（保姆级教程）</a>，自己当初也是看着这篇文章建成的网站，这里把部分内容抄过来做一下笔记，感谢大佬</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 建站记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搭建hexo博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>建站记录系列（一）——前言及准备工作</title>
      <link href="/article/02c95d658b91.html"/>
      <url>/article/02c95d658b91.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本站建站过程实际起始于2021年11月下旬，1月15日使用wordpress框架搭好了一个雏形，<del>然后就一个寒假再也没管过</del>。到了2月下旬我开学的时候，我看到了hexo框架和它的butterfly主题，深为蝴蝶主题的外观感到惊艳，再加上自己是主修前端的，基于node.js的hexo框架自然是深得我心，所以果断将wordpress换成了hexo，主题当然使用的是butterfly。折腾了一段时间才搭建成功，然后后面的几个月我基本就有时间就来看看有什么可以魔改的地方，奈何本人想象力实在贫乏，看着小冰akilar一众大佬的博客乱秀但自己完全无从下手，改了几个月也才改成你们现在（2022年7月）看到的这个样子，。。。</p><p>总之，目前来说看着还凑合，然后就是五个月了，终于决定动手开始写博客了。_ (:з)∠) _</p><p>本文仅仅作为本人hexo建站过程的记录，并不是一份详细的新手向教程，但是可以作为hexo建站的一份参考资料。</p><p>另外由于实在是拖得太久（五个月），有些地方真的不是太想写了😶，所以可能写的有<strong>亿点点马虎</strong>，不过一些重难点都写清楚了，emm……假如有时间会再回来看看然后改改的。</p><blockquote><p>本文不涉及宝塔面板，一切采用Linux命令行操作。弃用宝塔面板是因为它的ssl证书功能在我这失效了，解决不了，结果手动命令行方式安装好了证书，干脆也不再需要宝塔面板了。</p></blockquote><p>建站原材料：</p><ol><li><strong>200多块钱</strong>：用于购买域名及服务器，因此本过程并非是一个免费的过程。想免费可以试试GitHub pages或者vercel等一些静态网页托管服务，比如本站的镜像站就是在Github pages上面。</li><li><strong>一些基础的前端及命令行知识&#x2F;bug定位能力和能折腾的耐心</strong>：搭建hexo博客还是挺折腾的，需要一些技术基础。如果中间没有认真看文档或者某些原因出了错误，最好是能靠自己的定位bug能力分析出来，如果没有那个能力，嗯。。。一言难尽了。你可以跑到主题群里问人，但如果是自己一些基础知识&#x2F;能力没有的话还是会很难受。</li></ol><h2 id="准备工作：域名、服务器、ICP备案"><a href="#准备工作：域名、服务器、ICP备案" class="headerlink" title="准备工作：域名、服务器、ICP备案"></a>准备工作：域名、服务器、ICP备案</h2><p>众所周知要想搭建一个网站我们需要一个服务器和域名，目前本站所使用的是阿里云的云服务器，域名也是从阿里云购买的。这里就不写什么域名、服务器购买教程了，只简单回忆一下步骤：</p><h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3><blockquote><p>该步骤用时：3~5天，经济消耗：9元（对我来说）</p></blockquote><p>先去阿里云官网注册一个账号，然后在<a href="https://wanwang.aliyun.com/">阿里云万网</a>上寻找域名，先想好自己想要一个什么样的域名，然后在万网的搜索框里搜索看有没有被别人注册过，如果没有，那就再根据价格等因素来选择一个自己喜欢的域名后缀，比如本站当初选择的域名就是elzzach.top，top域名还是很便宜的，首年只需9元（2021.11月价格），后面每年续费只需29元（每年都要续费一次哦），像什么com、cn这样的域名是比较贵的，都要好几十块钱来着。在购买域名确认订单的时候你可能会发现它提示你需要一个验证过邮箱的信息模板，你可以点击“创建新的信息模板”然后填写自己的一些相关信息，最重要的是你的邮箱要经过验证，验证完邮箱之后你的这个个人信息模板就可以用来确认订单了，接下来支付宝付款即可，这样一个域名就到手了。</p><blockquote><p>域名后缀不要选一些过于奇怪的后缀，比如汉字之类的，这样的域名多数在后面无法完成工信部ICP备案。</p></blockquote><p>到手了之后我们可以在阿里云官网上进入一个叫“域名控制台”的地方，在“域名列表”里我们可以看到自己刚刚购买的域名，然后我们会发现域名状态是“未实名认证”。点击这个未实名认证的链接，会跳转到实名认证界面，我们会发现有两种认证方式，一种是快速认证，即使用已经实名认证的信息模板来认证，但是我们是刚刚注册的账号，信息模板只验证了邮箱并没有实名认证，所以这种方式用不了，那就只能用第二种方法：普通认证。普通认证需要你上传你的身份证的人像面图片，请提前准备好，顺便准备一下身份证国徽面照片，并且将这两张照片保存一段时间，后面ICP备案时会用到。</p><p>实名认证大概需要三到五个工作日，我当初就是四天完成的，完成后会收到邮件通知。</p><h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><blockquote><p>该步骤用时：几分钟，经济消耗：约174元（假如我当初没加钱的话）</p></blockquote><p>域名实名认证是为了能够解析到服务器上，不然是不能解析的。现在实名认证完成了之后就可以着手准备服务器了。</p><p>服务器仍然是选择在阿里云购买。国内比较好的云服务器厂商有阿里云、腾讯云、百度云、华为云等等，我推荐优先考虑阿里和腾讯。</p><p>首先进入<a href="https://www.aliyun.com/product/ecs">阿里云官网的云服务器购买页面</a>，然后挑选自己心仪的服务器。我所购买的是ECS共享型n4服务器，1核2G1M带宽40G云盘的那种，并且由于是新用户有优惠，买三年只要174元（2021.12月价格），要知道如果不是新用户的话一年就已经需要上千的费用了😰。至于配置的话，我上面说的这个对于单纯的hexo博客网站而言已经足够了，尤其是存储空间是大大的溢出，因为一个hexo博客站初期文件夹大小都只有几M到几十M，完全是够的（猜猜是哪个冤种当初加了二十块钱买了50G的）。唯一可能不太够的就是1M的带宽是有些略小，假如有很多人来访问的话，但是一般而言并发数少的话是没问题的。</p><p>还有就是流量这块，阿里云像这种包年的套餐是相当于无限流量的，所以你不用担心什么网站被打了然后一个月下来流量账单爆炸，但是刚刚也说了带宽不大，假如真被打了虽然不用担心欠费，但是占你带宽让别人无法访问什么的还是可以的。</p><p>选择好了服务器之后点击立即购买，然后选一下服务器所在的地域，一般选一个离自己比较近的地方吧（），或者选一个自己喜欢的随便什么地方，另外再选择一下服务器的操作系统，一般对新手而言服务器会选择CentOS7的系统，如果你对Linux有比较深刻的理解的话就自己选自己的，我选择的是CentOS7.9。请不要选择CentOS8，因为这个版本很早之前已经停止维护了。其他的都保持默认配置即可。接下来就是确认订单并付款啦，这样一台云服务器也就到手了。</p><h3 id="ICP备案"><a href="#ICP备案" class="headerlink" title="ICP备案"></a>ICP备案</h3><blockquote><p>此步骤用时：3-10天，可能更长；经济消耗：0</p></blockquote><p>我没有将我ICP备案的过程进行录屏，然后现在时间有点久了，就只能回忆一下大概过程了。</p><p>ICP备案是任何国内网站都要完成的一道步骤，或者说是服务器在国内的网站，只有在工信部完成了ICP备案才能够对外提供访问，如果网站服务器在港澳台或国外是不需要ICP备案的。</p><p>首先你需要在阿里云官网上找一找ICP备案的相关规定，尤其是你所在地区的规定。如果有不清楚的地方可以询问阿里云客服，客服工作时间一般是早上八点（还是九点来着，而且我还忘了他们一周工作几天来着）到晚上六点，且中午十二点会休息一会。备案过程中遇到问题都可以去问备案方面的客服。</p><p>备案在阿里云官网上进行，但是建议下载阿里云手机app，提交资料会方便一点。一般来说个人网站备案都只需要填写提交服务器IP、一些身份证两面照片、自己手持身份证照片等等资料即可，按照备案过程中的要求来。备案时还需要你给你的网站起一个名字，记住网站名称不可以带有“博客”、“论坛”等字眼，否则申请会在阿里云初审阶段被退回。当你提交了你的备案材料之后记得一定要注意接听电话，阿里云客服工作时间随时会给你来电确认你的身份，就是问一些你的姓名、身份证号码、网站名称、网站用途之类这样的问题。像我当初是上午提交的备案申请，下午两点多就给我打电话来了，但当时我在上课没时间接，结果它就给我把备案申请退回来了，理由是按照提交的电话号码打电话无人接听，无法确认该号码是否属实。然后我下午四点多又提交了一遍，然后几十分钟后就又打电话来了。所以一定要注意接电话。</p><p>接完电话就说明通过了阿里云的初审，你的备案资料将会提交到管局进行审核，这时应该会有一条短信提醒你在工信部备案管理系统上完成短信核验，就是你用它发给你在备案信息中填写的手机号码的验证码去访问它进行核验，就算核验完成了。然后就是等待管局审核你的资料，时间一般在三到十个工作日左右，仍然要注意接听电话，因为我的是第四天它就给我打电话来了，但我没听到，然后它又等了四天才给我再打了一次电话，所以我的备案用时总共是八天。</p><p>这次接电话仍然是确认你的身份和网站信息之类的，之后就算是你的审核通过了，通过之后你应该会收到短信或者邮件的通知，然后登录阿里云账号，你可以看到你的备案网站里面给了你一个备案号，这就是你的ICP备案号了，你需要在搭好你的网站之后将备案号放在网站首页的最下方并链接到<a href="https://beian.miit.gov.cn/">工信部网站</a>，否则被查到的话会处以罚款的。这就是为什么你需要一点前端知识的原因😬。（但是对于hexo的butterfly主题来说即使不会前端也很简单）</p><p>到这里准备工作就结束了，接下来开始正式建站。</p>]]></content>
      
      
      <categories>
          
          <category> 建站记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搭建hexo博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
