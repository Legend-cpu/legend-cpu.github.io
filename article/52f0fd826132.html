<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Git学习笔记 | 暮紫天地</title><meta name="robots" content="noindex"><meta name="keywords" content="前端, 设计"><meta name="author" content="Elzzach"><meta name="copyright" content="Elzzach"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="安装git Linux上：  首先，你可以试着输入git，看看系统有没有安装Git： 123$ gitThe program &amp;#x27;git&amp;#x27; is currently not installed. You can install it by typing:sudo apt-get install git  像上面的命令，有很多Linux会友好地告诉你Git没有安装，还会告诉你如何安">
<meta property="og:type" content="article">
<meta property="og:title" content="Git学习笔记">
<meta property="og:url" content="https://blog.elzzach.top/article/52f0fd826132.html">
<meta property="og:site_name" content="暮紫天地">
<meta property="og:description" content="安装git Linux上：  首先，你可以试着输入git，看看系统有没有安装Git： 123$ gitThe program &amp;#x27;git&amp;#x27; is currently not installed. You can install it by typing:sudo apt-get install git  像上面的命令，有很多Linux会友好地告诉你Git没有安装，还会告诉你如何安">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.elzzach.top/rgba(0,%200,%200,%200)">
<meta property="article:published_time" content="2023-12-28T09:17:32.000Z">
<meta property="article:modified_time" content="2023-12-28T09:45:46.528Z">
<meta property="article:author" content="Elzzach">
<meta property="article:tag" content="前端, 设计">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.elzzach.top/rgba(0,%200,%200,%200)"><link rel="shortcut icon" href="https://blog.elzzach.top/global-img/favicon.webp"><link rel="canonical" href="https://blog.elzzach.top/article/52f0fd826132.html"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://npm.elemecdn.com/@fortawesome/fontawesome-free@latest/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/node-snackbar@latest/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"https://npm.elemecdn.com/ezsttcfs@latest/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"距离本文上次更新已经过去了","messageNext":"天，文章中的内容有可能已经过时。如果过时，请联系作者尝试更新为最新版。"},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":null},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#c449f5","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://npm.elemecdn.com/flickr-justified-gallery@latest/dist/fjGallery.min.js',
      css: 'https://npm.elemecdn.com/flickr-justified-gallery@latest/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Git学习笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-12-28 17:45:46'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" /><meta http-equiv="Cache" content="no-cache"><meta http-equiv="Pragma" content="no-cache" /><meta http-equiv="Expires" content="0" /><link rel="stylesheet" href="/ext/ez.css"><meta name="generator" content="Hexo 6.0.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.elzzach.top/global-img/avatar.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">16</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">35</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo/"><i class="fa-fw fas fa-ellipsis"></i><span> 碎碎念</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img nav-fixed nav-visible" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">暮紫天地</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo/"><i class="fa-fw fas fa-ellipsis"></i><span> 碎碎念</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Git学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-12-28T09:17:32.000Z" title="发表于 2023-12-28 17:17:32">2023-12-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-12-28T09:45:46.528Z" title="更新于 2023-12-28 17:45:46">2023-12-28</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>28分钟</span></span></div></div></div><article class="post-content" id="article-container"><h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><ol>
<li>Linux上：</li>
</ol>
<p>首先，你可以试着输入<code>git</code>，看看系统有没有安装Git：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git</span><br><span class="line">The program &#x27;git&#x27; is currently not installed. You can install it by typing:</span><br><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure>

<p>像上面的命令，有很多Linux会友好地告诉你Git没有安装，还会告诉你如何安装Git。</p>
<p>如果你碰巧用Debian或Ubuntu Linux，通过一条<code>sudo apt-get install git</code>就可以直接完成Git的安装，非常简单。</p>
<p>老一点的Debian或Ubuntu Linux，要把命令改为<code>sudo apt-get install git-core</code>，因为以前有个软件也叫GIT（GNU Interactive Tools），结果Git就只能叫<code>git-core</code>了。由于Git名气实在太大，后来就把GNU Interactive Tools改成<code>gnuit</code>，<code>git-core</code>正式改为<code>git</code>。</p>
<p>如果是其他Linux版本，可以直接通过源码安装。先从Git官网下载源码，然后解压，依次输入：<code>./config</code>，<code>make</code>，<code>sudo make install</code>这几个命令安装就好了。</p>
<ol start="2">
<li>在Windows上：</li>
</ol>
<p>在Windows上使用Git，可以从Git官网直接<a target="_blank" rel="noopener" href="https://git-scm.com/downloads">下载安装程序</a>，然后按默认选项安装即可。</p>
<p>安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！</p>
<p>安装完成后，还需要最后一步设置，在命令行输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;Your Username&quot;</span><br><span class="line">$ git config --global user.email &quot;email@example.com&quot;</span><br></pre></td></tr></table></figure>

<p>设置用户名和邮箱的目的在于让你以后提交的commit中存有能证明这个提交出自你手的信息。用户名相当于网名，没有规定就按自己的喜好起；邮箱最好写你自己的邮箱，随便写一个当然能继续使用，但是可能导致别人看到你的commit想通过邮箱联系你时联系不到你。在使用Github时，如果你向Github远程仓库提交commit时所配置的user.email与你的Github账号所用的邮箱相同，则Github平台会将这个commit与你的Github账号自动关联起来，同时你的Github主页的contribution也会记录此次提交。相反，如果你使用的邮箱并非Github账号的邮箱，则此次提交不会自动关联账号，你Github主页的contribution也不记录此次提交。</p>
<p>注意<code>git config</code>命令的<code>--global</code>参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p>
<p><code>git config</code>命令做出的设置会保存在<code>Git安装目录/Git/etc/gitconfig</code>文件中，使用命令<code>git config --list --show-origin</code>可以查看该文件的位置及其中的内容。</p>
<h3 id="使用git"><a href="#使用git" class="headerlink" title="使用git"></a>使用git</h3><h4 id="工作区、暂存区和版本库"><a href="#工作区、暂存区和版本库" class="headerlink" title="工作区、暂存区和版本库"></a>工作区、暂存区和版本库</h4><p>工作区（又称工作树work-tree）：即本地仓库目录，是可以直接进行编辑的地方</p>
<p>版本库：即仓库目录中的<code>.git</code>目录，版本库里至少会有被称为 stage 或者 index 的暂存区和Git为我们自动创建的第一个分支master还有初始指向master分支的一个指针HEAD。HEAD是指向“指向当前工作分支的指针” 的指针，当前在哪个分支工作，HEAD就会指向“指向当前工作分支的指针”。版本库存放已经commit的数据。</p>
<p>暂存区：即<code>.git/index</code>文件，临时存放文件的改动，也叫索引区。是暂时存储文件改动的地方。</p>
<h4 id="git仓库中文件的四种状态"><a href="#git仓库中文件的四种状态" class="headerlink" title="git仓库中文件的四种状态"></a>git仓库中文件的四种状态</h4><p>git不关心文件两个版本之间的具体差别，而是关心文件的整体是否有改变，若文件被改变，在添加提交时就生成文件新版本的快照，而判断文件整体是否改变的方法就是用SHA-1算法计算文件的校验和。</p>
<p>git中文件的状态有以下几种：</p>
<p><strong>Untracked:</strong>  未跟踪, 此文件在仓库中, 但并没有加入到版本库, 不参与版本控制。通过<code>git add</code>状态变为Staged。VSCode将在此状态的文件名旁显示字母U。用<code>git rm &lt;file&gt;</code>将直接删除此文件。</p>
<p><strong>Unmodify:</strong>  文件已入库, 未修改或者修改后已经commit提交了，即版本库中的文件快照内容与文件夹中完全一致。VSCode对此状态文件不作特殊标识。对文件进行修改会使其变为Modified状态。用<code>git rm --cached &lt;file&gt;</code>命令从版本库中移除变为Untracked状态。</p>
<p><strong>Modified:</strong> 文件已入库，并且入库后经历了修改且修改尚未commit提交。VSCode将在此状态的文件名旁显示字母M。用<code>git restore &lt;file&gt;</code>或者<code>git checkout -- &lt;file&gt;</code>命令丢弃当前工作区未add提交暂存的修改，如果已经add提交暂存，则先用<code>git restore --staged &lt;file&gt;</code>或者<code>git reset HEAD &lt;filename&gt;</code>将修改从暂存区撤出，再丢弃修改。用<code>git add</code>则将修改提交到暂存区，文件变为Staged状态。</p>
<p><strong>Staged:</strong> 暂存状态，VSCode将在此状态的文件名旁显示字母A。用<code>git rm --cached &lt;file&gt;</code>命令从版本库中移除变为Untracked状态。用<code>git commit</code>将暂存区修改提交到仓库，文件变为Unmodify状态。</p>
<blockquote>
<p>一说认为Unmodify状态与Commited状态是两种状态。</p>
</blockquote>
<h4 id="各种命令"><a href="#各种命令" class="headerlink" title="各种命令"></a>各种命令</h4><h5 id="常用命令："><a href="#常用命令：" class="headerlink" title="常用命令："></a>常用命令：</h5><p><code>git init</code>将当前目录初始化为git仓库，在当前目录下生成默认隐藏的<code>.git</code>文件夹。</p>
<p><code>git add &lt;filename1&gt; &lt;filename2&gt; ...</code> 将文件添加到仓库，可以一次添加多个文件，文件名之间用空格分开即可，文件名包含后缀名。<code>git add</code>实际上是将文件修改提交到暂存区。</p>
<blockquote>
<p><code>git add .</code>在git 2.x版本中会提交当前工作区中当前目录及其子目录下所有的文件改动到暂存区，包括被删除的文件</p>
<p><code>git add -A</code>与上面的类似，只不过作用范围扩大到整个工作区</p>
<p><code>git add -u</code>将所有已跟踪的文件改动提交到缓存区，包括被删除的文件。对Untracked文件无效。</p>
</blockquote>
<p><code>git commit -m &quot;msg&quot;</code>配合<code>git add</code>将修改提交到工作区和版本库。msg是本次提交操作的注释。</p>
<blockquote>
<p>git只会将所有暂存区中的内容提交到版本库，所以commit之前一定要add。</p>
<p>如果只想commit一部分文件的修改就和add一样指定文件名列表即可。</p>
<p>只使用<code>git commit</code>命令会直接进入vim界面输入commit注释，不输入注释会中断commit操作。</p>
<p><code>git commit -am &quot;msg&quot;</code>可以不使用add命令直接commit，本质是在commit之前自动执行了一次<code>git add -u</code></p>
<p><code>git commit --amend -m &quot;msg&quot;</code>使用新的提交覆盖上一次的提交，用于修正上次提交中出现的错误，如果代码没有变化则可以用来改写上次提交的注释。或者用<code>git commit --amend --only -m &lt;message&gt;</code>只修改注释，不会提交暂存区内容。</p>
</blockquote>
<p><code>git status</code>让我们时刻掌握仓库的状态，如有修改未提交等。</p>
<p><code>git diff &lt;filename&gt;</code>可以让我们查看该文件上次具体被修改了什么内容。</p>
<blockquote>
<p><code>git diff</code>将当前工作区内容与暂存区进行比较。</p>
<p><code>git diff &lt;commitID&gt;</code>将工作区与指定id的commit版本进行比较。与最新版本比较时&lt; commitID &gt;可写为HEAD。</p>
<p><code>git diff --cached &lt;commitID&gt;</code>比较暂存区与指定id的commit。</p>
<p><code>git diff commit1 commit2</code>比较两个指定的commit。</p>
<p>加上–stat参数可以直观地显示改动的数量。</p>
</blockquote>
<p><code>git log</code>命令显示从最近到最远（从上到下排列）的commit日志，加上<code>--pretty=oneline</code>参数后可以简化输出。</p>
<h5 id="版本回滚："><a href="#版本回滚：" class="headerlink" title="版本回滚："></a>版本回滚：</h5><blockquote>
<p>Git中用<code>HEAD</code>表示当前版本，上一个版本即<code>HEAD^</code>，上上个版本即<code>HEAD^^</code>，往上一百个版本可以简化写成<code>HEAD~100</code>。</p>
</blockquote>
<p><code>git reset --hard &lt;commitID&gt;</code>命令可以让我们将仓库回退到指定版本的状态。–hard表示在回滚时清除工作区的未暂存的内容。</p>
<blockquote>
<p>注意Windows下该命令最后的 ^ 要加一个 ^ 来转义或者用~1代替，不然会出错。</p>
</blockquote>
<p>当这样回退到上个版本后再查看<code>git log</code>，会发现之前最新的一条提交日志没有了，那这是否意味着无法再恢复到之前的最新版本了呢？如果命令行窗口还未关闭的话可以往上翻找之前那条最新日志的版本号，复制，然后利用<code>git reset --hard ...</code>来恢复到之前的最新版本（… 表示复制的版本号）。版本号可以只写前面几位，至于多少位会起效可能因系统而异，一般七位即可。</p>
<p>如果命令行窗口已经关闭了，可以用<code>git reflog</code>命令查看之前的版本改动记录，在里面找到你要恢复的那个版本的版本号然后再使用<code>git reset</code>命令即可。（这时候就一定程度上体现了<code>git commit</code>命令中注释的重要性了，因为注释有利于寻找你要恢复到的那个版本）</p>
<blockquote>
<p>总结：<br>回到过去：<code>git log</code>+<code>git reset</code></p>
<p>回到未来：<code>git reflog</code>+<code>git reset</code></p>
</blockquote>
<h5 id="撤销修改："><a href="#撤销修改：" class="headerlink" title="撤销修改："></a>撤销修改：</h5><p>在<a href="#git%E4%BB%93%E5%BA%93%E4%B8%AD%E6%96%87%E4%BB%B6%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%8A%B6%E6%80%81">Modified文件状态</a>中提到过如何撤销修改的问题。</p>
<p>已修改但还未add：如果改乱了工作区中某个文件的内容想要丢弃这次修改，使用<code>git checkout -- &lt;filename&gt;</code>命令丢弃对该文件的这次修改，让它回到和版本库一模一样的状态。</p>
<p>已修改，且已add，但还未commit：如果不合适的修改已经被 add 到暂存区，想丢弃修改需要两步：用<code>git reset HEAD &lt;filename&gt;</code>撤销暂存区中的修改放回工作区，然后就和上面一样了，用<code>git checkout -- &lt;filename&gt;</code>来丢弃工作区的修改。</p>
<p>如果不合适的修改已经被 commit 了，可以用版本回滚的方法来撤销修改，但如果已经push到远程库那就没办法了。所以push之前一定要谨慎确认。</p>
<blockquote>
<p><code>git checkout</code>是先将<code>HEAD</code>指向某个分支的最近一次commit，然后从commit恢复index，最后从index恢复工作区。</p>
</blockquote>
<h5 id="删除文件："><a href="#删除文件：" class="headerlink" title="删除文件："></a>删除文件：</h5><p><code>git rm &lt;filename&gt;</code>直接删除工作区文件并将这次删除改动放入暂存区。要求文件必须是Unmodify状态（和版本库中的文件相同）才能使用该命令。Unmodify状态文件不会存在于暂存区，故彻底删除只需要commit改动删除版本库中的文件即可。</p>
<p><code>git rm -f &lt;filename&gt;</code> 命令会删除工作区和暂存区文件，并且将这次删除放入暂存区。要求被删除的文件已经修改过（Modified状态），和当前版本库文件的内容不同。要彻底删除还需要commit提交。</p>
<p><code>git rm --cached &lt;filename&gt;</code> 命令会删除暂存区文件，但保留工作区的文件（变为Untracked状态），并且将这次删除放入暂存区。要删除版本库中的文件仍需commit提交。如果删除时工作区文件已被修改过则删除后保留修改后的状态。</p>
<p>如果误删了工作区文件且文件之前已经添加到版本库中可以用版本库中的最新版本来替换工作区的版本，使用<code>git checkout -- &lt;deleted filename&gt;</code>命令即可。</p>
<h5 id="git分支："><a href="#git分支：" class="headerlink" title="git分支："></a>git分支：</h5><p>git中的分支相当于创建一个仓库的副本，主分支往往为产品发布的分支，在副本分支上开发不会影响主分支，开发完毕后合并到主分支即可。</p>
<p><code>git branch</code>命令可以查看当前分支（列出所有分支且当前分支用 * 标注）</p>
<p><code>git branch &lt;branchname&gt;</code>命令可以创建一个指定名称的分支。</p>
<p><code>git checkout &lt;branchname&gt;</code>命令可以将当前分支切换到指定名称的分支上。</p>
<blockquote>
<p>以上创建并切换的两步操作可以用一个命令实现，即<code>git checkout -b &lt;branchname&gt;</code>。</p>
</blockquote>
<p>新版Git支持switch命令，即创建并切换到新分支的操作可以用<code>git switch -c &lt;branchname&gt;</code>来实现。切换到指定名称的分支可以用<code>git switch &lt;branchname&gt;</code>命令。</p>
<p><code>git branch -d &lt;branchname&gt;</code>命令可以删除指定名称的分支（不能删除当前所在分支）。</p>
<p><code>git merge &lt;branchname&gt;</code>命令可以将指定名称的分支合并到当前分支上。</p>
<blockquote>
<p>fast forward 模式合并与 no-ff 模式合并的区别：<br>后者合并时要加一个 -m 参数附上本次提交的注释，因为这种模式下合并是会有一个commit提交历史的；而 fast forward 模式合并就没有历史记录。默认为ff模式。</p>
</blockquote>
<p>合并冲突：在合并两个分支的时候，如果这两个分支对同一文件的同一行“做出了不同的修改”，此时就会产生合并冲突，需要人为修改合并冲突，此时我们将列出了冲突详情的文件中冲突的内容改为自己想要保留的那一个，再commit提交就行了。</p>
<p>用<code>git log --graph</code>命令可以看到分支合并图。</p>
<h5 id="远程仓库（Github）："><a href="#远程仓库（Github）：" class="headerlink" title="远程仓库（Github）："></a>远程仓库（Github）：</h5><p>本地Git仓库和Github仓库之间的传输是通过SSH加密的，在操作远程库之前要先看自己电脑的用户主目录（和<code>.Appdata</code>目录同级的地方）有没有<code>.ssh</code>目录，以及里面有没有<code>id_sra</code>和<code>id_rsa.pub</code>两个文件，如果没有，</p>
<ol>
<li>Windows下打开Git Bash创建SSH Key:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;你的邮箱（要与Github账号邮箱相同）&quot;</span><br></pre></td></tr></table></figure>

<p><code>id_rsa.pub</code>为公钥，可以公开；<code>id_rsa</code>是私钥，不能泄漏。</p>
<ol start="2">
<li>登录Github在账户设置页面添加SSH Key，将<code>id_rsa.pub</code>文件里的内容复制粘贴即可。这样，假如换了电脑，迁移操作应该是：在新电脑上重新生成两个密钥，并将公钥内容复制到github账号上的SSH Key中。</li>
</ol>
<p><strong>添加远程库</strong>：在Github上新建一个<code>learngit</code>仓库，然后将本地的Git仓库与之关联：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin &lt;远程库的https地址或者ssh地址&gt;</span><br></pre></td></tr></table></figure>

<p>添加后远程库的名字就是origin，这是Git的默认叫法，也可以叫成别的。</p>
<p><strong>删除远程库</strong>：可以先用<code>git remote -v</code>查看远程库信息，然后根据名字用<code>git remote rm &lt;repositoryname&gt;</code>删除，仓库名是指远程库名，如origin。这个删除其实只是解除了本地和远程的绑定关系，真正删除远程库还要在Github页面上在后台用删除按钮删除。</p>
<p><strong>将本地分支中的内容向远程库推送</strong>：<code>git push &lt;远程库名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</code>，当远程分支名不存在时会自动创建。</p>
<p>如果本地仓库只与一个远程库关联，则可以省略<code>&lt;远程库名&gt;</code>。</p>
<p>本地分支名和远程分支名相同时可以省略一个，只写一个分支名。</p>
<p>如果当前所在本地分支已经跟远程分支建立了追踪关系，那么可以省略<code>&lt;本地分支名&gt;</code>和<code>:&lt;远程分支名&gt;</code>。要查看是否有追踪关系，使用<code>git branch -vv</code>命令，它会将建立了追踪关系的分支列出来（有[远程库名&#x2F;分支名]格式，没有就是没建立追踪关系）。</p>
<p>非clone下来的本地仓库第一次向远程库推送时往往是没有建立追踪关系的，这时如果想以后推送这个分支的时候只用<code>git push</code>来推送，需要使用<code>git push --set-upstream &lt;远程库名&gt; &lt;分支名&gt;</code>形式推送来将本地分支与远程分支关联，–set-upstream参数可简写为-u。如<code>git push -u origin master</code>，第一次时远程库名和分支名不可省略。</p>
<p>如果添加远程库时使用的是https地址，那么执行push之后需要你先Github认证一下，建议在fq状态下进行没有网络问题。使用ssh地址则没有这个问题。另外第一次使用ssh方式推送或克隆时可能会有一个警告，什么什么”can’t be established”之类的，如果需要输入，输入yes回车就行了。</p>
<p>推送成功后Github页面上的仓库当前分支的内容就会和本地分支一模一样了。</p>
<p>总结：第一次向空的远程库push时使用<code>git push -u origin master</code>，以后只要是继续向该远程库的该分支推送，就可以只写<code>git push</code>，如果要推送新分支，把分支名改一下就行了。</p>
<p><strong>将远程库内容拉取到本地分支</strong>：这个就是push推送的逆操作，用于将远程库的更新内容拉取到本地，使自己本地的仓库保持与远程库同步的状态。</p>
<p><code>git pull</code>：从与当前本地分支建立追踪关系的远程分支拉取最新内容并与本地分支合并，相当于<code>git fetch</code>和<code>git merge</code>的结合。它也有完整格式，不过此处暂不赘述。有分支合并就有可能发送合并冲突，本地解决提交就好了。</p>
<p><strong>克隆远程库到本地：</strong>克隆与拉取的区别是前者的本地是没有与远程库对应的本地仓库的，而后者是有的。首先在Github上找一个远程库，复制其https&#x2F;ssh地址，在本地要存放这个仓库的目录下进入命令行（不用事先创建同名目录），然后用命令<code>git clone &lt;address&gt;</code>命令将远程库克隆至当前目录下。ssh方式比https方式方便一点，因为https方式每次都要输入口令，且国内可能受网络环境限制速度慢。克隆下来的库会自动将远程分支和本地分支之间建立追踪关系。</p>
<h4 id="预留知识"><a href="#预留知识" class="headerlink" title="预留知识"></a>预留知识</h4><h5 id="Git-commit规范之一"><a href="#Git-commit规范之一" class="headerlink" title="Git commit规范之一"></a>Git commit规范之一</h5><p><strong>commit message格式</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</span><br></pre></td></tr></table></figure>

<p><strong>type(必须)</strong></p>
<p>用于说明git commit的类别，只允许使用下面的标识。</p>
<p>feat：新功能（feature）。</p>
<p>perf：优化相关，比如提升性能、体验。</p>
<p>fix&#x2F;to：修复bug，可以是QA发现的BUG，也可以是研发自己发现的BUG。</p>
<ul>
<li>fix：产生diff并自动修复此问题。适合于一次提交直接修复问题</li>
<li>to：只产生diff不自动修复此问题。适合于多次提交。最终修复问题提交时使用fix</li>
</ul>
<p>docs：文档（documentation）。</p>
<p>style：格式（不影响代码运行的变动）。</p>
<p>refactor：重构（即不是新增功能，也不是修改bug的代码变动）。</p>
<p>test：增加测试。</p>
<p>revert：回滚到上一个版本。</p>
<p>merge：代码合并。</p>
<p>sync：同步主线或分支的Bug。</p>
<p>chore：构建过程或辅助工具的变动。</p>
<p><strong>scope(可选)</strong></p>
<p>scope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。</p>
<p>例如在Angular，可以是location，browser，compile，compile，rootScope， ngHref，ngClick，ngView等。如果你的修改影响了不止一个scope，你可以使用*代替。</p>
<p><strong>subject(必须)</strong></p>
<p>subject是commit目的的简短描述，不超过50个字符。</p>
<p>建议使用中文（感觉中国人用中文描述问题能更清楚一些）。</p>
<ul>
<li>结尾不加句号或其他标点符号。</li>
<li>根据以上规范git commit message将是如下的格式：</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fix(DAO):用户查询缺少username属性 </span><br><span class="line">feat(Controller):用户查询接口开发</span><br></pre></td></tr></table></figure>

<h5 id="Git分支管理"><a href="#Git分支管理" class="headerlink" title="Git分支管理"></a>Git分支管理</h5><p>主分支&#x2F;保留分支：Master（正式发布产品版本）、Develop（日常开发的主分支）</p>
<p>辅助分支&#x2F;临时分支：</p>
<ul>
<li>功能（feature）分支，<strong>开发完成后，并入Develop</strong>。</li>
<li>预发布（release）分支，<strong>预发布结束以后，必须合并进Develop和Master分支</strong>。</li>
<li>修补bug（bugfix&#x2F;hotfix）分支，<strong>修补结束以后，再合并进Master和Develop分支</strong>。</li>
</ul>
<p>这三种分支都属于临时性需要，使用完以后，应该删除，使得代码库的常设分支始终只有Master和Develop。</p>
<h5 id="Git标签"><a href="#Git标签" class="headerlink" title="Git标签"></a>Git标签</h5><p>给项目中的一些重要的commit节点打上标签，比如v1.0.0。</p>
<p>创建标签是给具体的某次提交创建的，跟分支无关。创建标签使用 <strong><code>git tag [标签名] -m [备注信息] [commitID]</code></strong> 这个命令。其中 <strong>-m [备注信息]</strong> 可以省略不写，但建议不要省略。**[commitID]** 可以省略，如果是给当前分支最新的提交创建标签的话。</p>
<p>执行 <strong>git tag</strong> 命令显示仓库中的全部标签列表，执行 <strong>git show [标签名]</strong> 查看标签详情。</p>
<p>执行 <strong>git tag -d [标签名]</strong> 删除本地标签，标签文件也会被删除。</p>
<p><code>git push</code>命令不会自动推送标签，推送标签到远程库需要使用执行 <strong>git push origin [标签名]</strong> 命令。可以使用 <strong>git push origin –tags</strong> 命令将全部本地标签推送至远程仓库。</p>
<p>可以使用 <strong>git push origin :refs&#x2F;tags&#x2F;[标签名]</strong> 删除远程仓库的标签，本地仓库的标签需要另外手动删除。</p>
<p>利用标签签出项目的一个版本：首先执行 <strong>git checkout [标签名]</strong> 切换到之前的某个提交版本，然后执行 <strong>git checkout -b [新的分支名]</strong> 将此提交版本固定到一个新分支上并切换到此分支。</p>
<h5 id="版本库-git文件夹结构"><a href="#版本库-git文件夹结构" class="headerlink" title="版本库.git文件夹结构"></a>版本库.git文件夹结构</h5><p>hooks           文件夹，包含客户端或服务端的钩子脚本<br>                     (可以自定义在代码提交过程中应该做的事，比如在代码提交前检测代码格式是否符合规范)<br>info               文件夹，包含一个全局性排除文件exclude(记录不需要git进行管理的文件，即.gitignore文件里提到的文件)<br>logs               文件夹，保存日志信息<br>objects         文件夹，存储工作目录中数据的快照，文件从暂存区提交到版本库时就放在这里。<br>refs               文件夹，存储指向数据(分支)的提交对象的指针<br>config            文件，包含项目特有的配置选项<br>description    文件，用来显示对仓库的描述信息<br>HEAD           文件，指示目前被检出的分支<br>index            文件，保存暂存区信息</p>
<h5 id="gitignore文件"><a href="#gitignore文件" class="headerlink" title=".gitignore文件"></a>.gitignore文件</h5><p>该文件中提到的文件不会被git add，但是git add -f可以强制添加被忽略文件到暂存区。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dir 不需要提交的目录</span></span><br><span class="line">/node_modules</span><br><span class="line"></span><br><span class="line"><span class="comment"># file 不需要提交的文件</span></span><br><span class="line">config.ini</span><br><span class="line"></span><br><span class="line"><span class="comment"># log 不需要提交的任意包含后缀名为log的文件</span></span><br><span class="line">*.<span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Package Files 不需要提交的任意包含后缀名为jar的文件</span></span><br><span class="line">*.jar</span><br></pre></td></tr></table></figure>

<p>.gitignore注释用’#’, *表示匹配0个或多个任意字符，所以上面的模式就是要忽略所有的xml文件,log文件和apk文件。</p>
<p><strong>.gitignore忽略规则的优先级</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在 .gitingore 文件中，每一行指定一个忽略规则，Git检查忽略规则的时候有多个来源，它的优先级如下（由高到低）：</span><br><span class="line">1、从命令行中读取可用的忽略规则</span><br><span class="line">2、当前目录定义的规则</span><br><span class="line">3、父级目录定义的规则，依次递推</span><br><span class="line">4、$GIT_DIR/info/exclude 文件中定义的规则</span><br><span class="line">5、core.excludesfile中定义的全局规则</span><br></pre></td></tr></table></figure>

<p><strong>.gitignore忽略规则的匹配语法</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在 .gitignore 文件中，每一行的忽略规则的语法如下：</span><br><span class="line">1、空格不匹配任意文件，可作为分隔符，可用反斜杠转义</span><br><span class="line">2、以“＃”开头的行都会被 Git 忽略。即#开头的文件标识注释，可以使用反斜杠进行转义。</span><br><span class="line">3、可以使用标准的glob模式匹配。所谓的glob模式是指shell所使用的简化了的正则表达式。</span><br><span class="line">4、以斜杠&quot;/&quot;开头表示目录；&quot;/&quot;结束的模式只匹配文件夹以及在该文件夹路径下的内容，但是不匹配该文件；&quot;/&quot;开始的模式匹配项目跟目录；如果一个模式不包含斜杠，则它匹配相对于当前 .gitignore 文件路径的内容，如果该模式不在 .gitignore 文件中，则相对于项目根目录。</span><br><span class="line">5、以星号&quot;*&quot;通配多个字符，即匹配多个任意字符；使用两个星号&quot;**&quot; 表示匹配任意中间目录，比如a/**/z可以匹配 a/z, a/b/z 或 a/b/c/z等。</span><br><span class="line">6、以问号&quot;?&quot;通配单个字符，即匹配一个任意字符；</span><br><span class="line">7、以方括号&quot;[]&quot;包含单个字符的匹配列表，即匹配任何一个列在方括号中的字符。比如[abc]表示要么匹配一个a，要么匹配一个b，要么匹配一个c；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配。比如[0-9]表示匹配所有0到9的数字，[a-z]表示匹配任意的小写字母）。</span><br><span class="line">8、以叹号&quot;!&quot;表示不忽略(跟踪)匹配到的文件或目录，即要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。需要特别注意的是：如果文件的父目录已经被前面的规则排除掉了，那么对这个文件用&quot;!&quot;规则是不起作用的。也就是说&quot;!&quot;开头的模式表示否定，该文件将会再次被包含，如果排除了该文件的父级目录，则使用&quot;!&quot;也不会再次被包含。可以使用反斜杠进行转义。</span><br></pre></td></tr></table></figure>

<p><strong>需要谨记</strong>：git对于.ignore配置文件是按行从上到下进行规则匹配的，意味着如果前面的规则匹配的范围更大，则后面的规则将不会生效；</p>
<p><strong>十分重要</strong>：如果你不慎在创建.gitignore文件之前就push了项目，那么即使你在.gitignore文件中写入新的过滤规则，这些规则也不会起作用，Git仍然会对所有文件进行版本管理。所以大家一定要养成在项目开始就创建.gitignore文件的习惯，否则一旦push，处理起来会非常麻烦。（可以通过删除暂存区文件变为Untracked状态文件再重新add和commit来解决，但是在大型项目中这种处理方式可能会受到制约）</p>
<h5 id="开源许可证和LICENSE文件"><a href="#开源许可证和LICENSE文件" class="headerlink" title="开源许可证和LICENSE文件"></a>开源许可证和LICENSE文件</h5><p> <strong>为什么需要开源许可证?</strong></p>
<p>要弄懂为什么要使用开源许可证,我觉得应该首先弄懂不使用开源许可证会怎样?</p>
<p><strong>不使用开源许可证对于开发者有何影响?</strong></p>
<blockquote>
<p>首先在没有开源许可证的情况下你对你的项目是独占版权的,这样就会造成一个问题就是别人使用你的项目比较困难, 然后就会导致没人愿意去使用你的项目,还有个问题就是 如果多人参与你的项目的开发,因为每个人都成为了这个项目的版权持有者, 你自己在没有得到团队中所有成员授权的情况下, 对项目的随意使用其实也是违法的,如果你想要很好的维护项目的其他贡献者的版权许可,那你不得不去和你的项目贡献者之间签订一个贡献者协议, 想想都是一个很头疼的事情.<br>其次还有个问题,就是当你把你的代码发布到Github的公共仓库的时候, 也就意味着你接受了Github公共仓库的一些服务条款,由于这些条款的存在 很多人可以去查看和复制你的项目仓库, 在一些特殊的情况下,部分人对于你的项目的使用可能不需要你的许可和授权.</p>
</blockquote>
<p><strong>不使用开源许可证对于项目的使用者有何影响?</strong></p>
<blockquote>
<p>如果你发现了一个软件,而这个软件没有开源许可证,那么也就意味着你没有得到作者的授权,尽管在Github上面你能够查看和复制代码,但是严格意义上你不能出于任何目的去使用,修改,和分享这个软件, 你说蛋疼不蛋疼.<br>此时作为一个项目的使用者你所能做的就是:</p>
</blockquote>
<ol>
<li>和项目的开发者沟通去加上开源许可证</li>
<li>不去使用这个没有开源许可证的项目,即使你觉得这个项目不错</li>
<li>和开发者进行私人协商,获取开发者的授权</li>
</ol>
<blockquote>
<p>总结: 为什么要使用开源许可证, 因为不用的话,会给开发者和使用者带来很多的麻烦事情, 用开源许可证是为了避免日后在项目的使用过程中一些不必要的麻烦</p>
</blockquote>
<p> <strong>Github的开源许可证如何选择,他们之间有何区别?</strong></p>
<p>这个世界上有太多的开源许可证,甚至Github的开源许可证就有很多,我相信大多数人都没有时间和精力去认证的去了解每一个开源许可证,那怎么办呢? 所以我这里把最主要的几个开源许可证的地址和允许的权力列了出来,大家首先做个粗判断, 简单判断一下自己可能会用到那个开源许可证,然后再去认真的研究, 如果真的对开源许可证非常感兴趣, 也可以先全研究几个被广为使用的开源许可证(比如 GPLv3和MIT许可证), 跟着潮流走总不会有啥大问题.</p>
<p><strong>常见的软件开源许可证(开放程度由低到高)</strong></p>
<p><a href="https://link.zhihu.com/?target=https://choosealicense.com/licenses/agpl-3.0/">GNU Affero General Public License v3.0choosealicense.com&#x2F;licenses&#x2F;agpl-3.0&#x2F;</a></p>
<p><a href="https://link.zhihu.com/?target=https://choosealicense.com/licenses/gpl-3.0/">GNU General Public License v3.0choosealicense.com&#x2F;licenses&#x2F;gpl-3.0&#x2F;</a></p>
<p><a href="https://link.zhihu.com/?target=https://choosealicense.com/licenses/lgpl-3.0/">GNU Lesser General Public License v3.0choosealicense.com&#x2F;licenses&#x2F;lgpl-3.0&#x2F;</a></p>
<p><a href="https://link.zhihu.com/?target=https://choosealicense.com/licenses/mpl-2.0/">Mozilla Public License 2.0choosealicense.com&#x2F;licenses&#x2F;mpl-2.0&#x2F;</a></p>
<p><a href="https://link.zhihu.com/?target=https://choosealicense.com/licenses/apache-2.0/">Apache License 2.0choosealicense.com&#x2F;licenses&#x2F;apache-2.0&#x2F;</a></p>
<p><a href="https://link.zhihu.com/?target=https://choosealicense.com/licenses/mit/">MIT Licensechoosealicense.com&#x2F;licenses&#x2F;mit&#x2F;</a></p>
<p><a href="https://link.zhihu.com/?target=https://choosealicense.com/licenses/bsl-1.0/">Boost Software License 1.0choosealicense.com&#x2F;licenses&#x2F;bsl-1.0&#x2F;</a></p>
<p><a href="https://link.zhihu.com/?target=https://choosealicense.com/licenses/unlicense/">The Unlicensechoosealicense.com&#x2F;licenses&#x2F;unlicense&#x2F;</a></p>
<p> <strong>常见的非软件开源许可证</strong></p>
<p><a href="https://link.zhihu.com/?target=https://choosealicense.com/licenses/cc0-1.0/">Creative Commons Zero v1.0 Universalchoosealicense.com&#x2F;licenses&#x2F;cc0-1.0&#x2F;</a></p>
<p><a href="https://link.zhihu.com/?target=https://choosealicense.com/licenses/cc-by-4.0/">Creative Commons Attribution 4.0 Internationalchoosealicense.com&#x2F;licenses&#x2F;cc-by-4.0&#x2F;</a></p>
<p><a href="https://link.zhihu.com/?target=https://choosealicense.com/licenses/cc-by-sa-4.0/">Creative Commons Attribution Share Alike 4.0 Internationalchoosealicense.com&#x2F;licenses&#x2F;cc-by-sa-4.0&#x2F;</a></p>
<p> <strong>软件开源许可证如何选择?</strong></p>
<p>我们需要一张乌克兰老铁(Paul Bagwell)画的图来帮助我们进行理解和选择 :</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="E:/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/v2-938e6acf652b680f28157383ce632acc_720w-1703605108014-3.webp" alt="img"></p>
<blockquote>
<p>由上图可以看到目前主流的开源证书主要分为两派:<br>GPL系列 和 MPL 站一派 (我简称他们A派) BSD系列, MIT 和 Apache 站一派 (我简称他们B派)<br>两派之间的主要区别就是你在原有的开源软件上做了更改之后是否允许其所使用开源证书发生变化:<br>A派的观点就是你更改开源项目之后所使用的开源证书必须和原有开源项目保持一致或者相兼容, 其实就是一个始于开源 忠于开源的思想,让大家一直开源<br>B派的观点就是原有的开源项目,如果你更改了部分代码的话那你也可以更改开源证书,这样以来对于开源项目而言,就更加的容易被商业化,<br>而GPLv3和MIT 这两个开源证书简直就是A派和B派的两个极端, 也是目前最受欢迎的两个证书,具体怎么选择大家可以看图行事, 当然更加详细的协议内容还是建议大家根据我发的协议链接找到协议原文,去仔细阅读协议原文进行了解</p>
</blockquote>
<p> <strong>非软件开源许可证如何选择?</strong></p>
<p> 数据集 视频 所使用的开源许可证</p>
<blockquote>
<p><a href="https://link.zhihu.com/?target=https://choosealicense.com/licenses/cc0-1.0/">CC0-1.0</a>, <a href="https://link.zhihu.com/?target=https://choosealicense.com/licenses/cc-by-4.0/">CC-BY-4.0</a>, 和 <a href="https://link.zhihu.com/?target=https://choosealicense.com/licenses/cc-by-sa-4.0/">CC-BY-SA-4.0</a> 这三种开源许可证就经常被用在数据集和视频 等非软件的项目上面, 有一点需要注意的就是 CC-BY-4.0 和 CC-BY-SA-4.0 这两种许可证是不建议给软件项目用的<br>CC-BY-4.0 和 CC-BY-SA-4.0非常的相似,后者比前者有一项要求就是,如果你对开源项目进行了更改, 那么更改后的版本所使用的开源协议必须和原有协议相同或者想兼容, 这里和软件开源证书的两派的思想是相同的</p>
</blockquote>
<p> 文档所使用的开源许可证</p>
<blockquote>
<p>一般情况下开源软件中所附带的开源的文档和 开源软件本身持有相同的开源许可证, 当然你也可以针对开源软件和其对应的开源文档使用两套不同的开源许可证, 但是你一定要指出文档中的 源代码示例 所使用的许可证是什么类型的</p>
</blockquote>
<p>字体使用的开源许可证</p>
<blockquote>
<p>针对开源字体常用的许可证就是 <a href="https://link.zhihu.com/?target=https://choosealicense.com/licenses/ofl-1.1/">SIL Open Font License 1.1</a> , 这个许可证可以允许别人自由的去使用它,同时保留自己的版权</p>
</blockquote>
<p> 混合工程使用的许可证</p>
<blockquote>
<p>如果你的 项目是个非常大的混合工程,包含 软件, 文档, 数据集,视频,字体等内容, 那你就需要为自己的项目准备多个许可证, 但是你需要做一个说明,用来说明你的工程的各个部分分别使用怎样的许可证 .</p>
</blockquote>
<p>如果Github上面的所有许可证都不能满足我的要求怎么办?</p>
<p>开源许可证本质上就是一个名字为LICENSE或者LICENSE.txt的文本文件 如果你将要使用的开源许可证不可以在Github上建立仓库的时候进行选择,那么你可以这么做:</p>
<ol>
<li>在选择开源许可证的时候随便选择一个,然后把自动生成的LICENSE中的文件更改为你所需要的内容</li>
<li>直接不选择开源许可证,在自己的项目文件夹中自己去创建 LICENSE&#x2F;LICENSE.txt文件 然后把自己所使用的开源许可证的协议内容粘贴进去</li>
</ol>
<h5 id="如何编写项目的Readme文件"><a href="#如何编写项目的Readme文件" class="headerlink" title="如何编写项目的Readme文件"></a>如何编写项目的Readme文件</h5><ul>
<li><p><strong>项目背景</strong></p>
</li>
<li><p><strong>上手指南</strong></p>
</li>
<li><ul>
<li>安装要求（指明项目的依赖环境）</li>
<li>安装步骤（可有可无，如果有一些特别恶心的配置还是建议写一下）</li>
</ul>
</li>
<li><ul>
<li><p><strong>测试</strong>			</p>
</li>
<li><ul>
<li><p>检查<code>依赖环境是否正常</code>的测试</p>
</li>
<li><p>如果此项目是针对什么具体业务的话提供一些基本测试用例还是必要的可以让别人快速明白这个是干嘛的</p>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><p><strong>部署</strong></p>
</li>
<li><ul>
<li>如果你的项目是可以上线的,那么如何配置部署文件也是一个很重要的内容.因为有些平台不用不知道，谁用谁知道（一用根本用不来）</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><p><strong>框架或者技术选型</strong></p>
</li>
<li><ul>
<li>方便快速识别是敌是友</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><p><strong>贡献者</strong></p>
</li>
<li><ul>
<li><p>混个脸熟以后好搞事情</p>
</li>
<li><p>对于大家的参与表示精神上的鼓励</p>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><p><strong>版本控制</strong></p>
</li>
<li><ul>
<li>告知使用了什么版本控制系统</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><p><strong>作者</strong></p>
</li>
<li><ul>
<li>让大家来膜拜你</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><p><strong>版权说明:</strong></p>
</li>
<li><ul>
<li>仅针对开源项目,内部开发没有必要</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><p><strong>鸣谢:</strong></p>
</li>
<li><ul>
<li>做一个有礼貌的人,用了别人的东西就帮别人打打广告.</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- flag of hidden posts --></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://blog.elzzach.top">Elzzach</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://blog.elzzach.top/article/52f0fd826132.html">https://blog.elzzach.top/article/52f0fd826132.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.elzzach.top" target="_blank">暮紫天地</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.elzzach.top/global-img/avatar.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Elzzach</div><div class="author-info__description">一个爱好视觉效果的(想花里胡哨却花不起来的)入门小前端</div></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/legend-cpu" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:el-zzach@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到暮紫天地！🎉<br/>博主去知识的海洋里遨游了，更新随缘哦~<br/><strong>主站点</strong>：<a href="https://blog.elzzach.top/" target="_blank">blog.elzzach.top</a><br/><strong>镜像站</strong>：<a href="https://legend-cpu.github.io/" target="_blank">Github镜像站</a><br/>作者才疏学浅，读者若发现文章有错误之处，请不吝指出！<br/><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.elzzach.top/global-img/202202241714592.gif" alt="可爱"/></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85git"><span class="toc-number">1.</span> <span class="toc-text">安装git</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8git"><span class="toc-number">2.</span> <span class="toc-text">使用git</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8C%BA%E3%80%81%E6%9A%82%E5%AD%98%E5%8C%BA%E5%92%8C%E7%89%88%E6%9C%AC%E5%BA%93"><span class="toc-number">2.1.</span> <span class="toc-text">工作区、暂存区和版本库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#git%E4%BB%93%E5%BA%93%E4%B8%AD%E6%96%87%E4%BB%B6%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="toc-number">2.2.</span> <span class="toc-text">git仓库中文件的四种状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%84%E7%A7%8D%E5%91%BD%E4%BB%A4"><span class="toc-number">2.3.</span> <span class="toc-text">各种命令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%EF%BC%9A"><span class="toc-number">2.3.1.</span> <span class="toc-text">常用命令：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%88%E6%9C%AC%E5%9B%9E%E6%BB%9A%EF%BC%9A"><span class="toc-number">2.3.2.</span> <span class="toc-text">版本回滚：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%92%A4%E9%94%80%E4%BF%AE%E6%94%B9%EF%BC%9A"><span class="toc-number">2.3.3.</span> <span class="toc-text">撤销修改：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%EF%BC%9A"><span class="toc-number">2.3.4.</span> <span class="toc-text">删除文件：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#git%E5%88%86%E6%94%AF%EF%BC%9A"><span class="toc-number">2.3.5.</span> <span class="toc-text">git分支：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%EF%BC%88Github%EF%BC%89%EF%BC%9A"><span class="toc-number">2.3.6.</span> <span class="toc-text">远程仓库（Github）：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%84%E7%95%99%E7%9F%A5%E8%AF%86"><span class="toc-number">2.4.</span> <span class="toc-text">预留知识</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Git-commit%E8%A7%84%E8%8C%83%E4%B9%8B%E4%B8%80"><span class="toc-number">2.4.1.</span> <span class="toc-text">Git commit规范之一</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Git%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86"><span class="toc-number">2.4.2.</span> <span class="toc-text">Git分支管理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Git%E6%A0%87%E7%AD%BE"><span class="toc-number">2.4.3.</span> <span class="toc-text">Git标签</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%88%E6%9C%AC%E5%BA%93-git%E6%96%87%E4%BB%B6%E5%A4%B9%E7%BB%93%E6%9E%84"><span class="toc-number">2.4.4.</span> <span class="toc-text">版本库.git文件夹结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#gitignore%E6%96%87%E4%BB%B6"><span class="toc-number">2.4.5.</span> <span class="toc-text">.gitignore文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%80%E6%BA%90%E8%AE%B8%E5%8F%AF%E8%AF%81%E5%92%8CLICENSE%E6%96%87%E4%BB%B6"><span class="toc-number">2.4.6.</span> <span class="toc-text">开源许可证和LICENSE文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E9%A1%B9%E7%9B%AE%E7%9A%84Readme%E6%96%87%E4%BB%B6"><span class="toc-number">2.4.7.</span> <span class="toc-text">如何编写项目的Readme文件</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background: rgba(255, 255, 255, 0.8)"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By Elzzach</div><div class="footer_custom_text"><div class="footer_custom_text"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a><span class="footer-separator">|</span><span>备案 </span><a href="https://beian.miit.gov.cn" target="_blank">皖ICP备2022000051号</a></div></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://npm.elemecdn.com/medium-zoom@latest/dist/medium-zoom.min.js"></script><script src="https://npm.elemecdn.com/vanilla-lazyload@latest/dist/lazyload.iife.min.js"></script><script src="https://npm.elemecdn.com/node-snackbar@latest/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://npm.elemecdn.com/pangu@latest/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script src="https://npm.elemecdn.com/ezsttcfs@latest/live2d-widget/autoload.js"></script><script src="/ext/ez.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://npm.elemecdn.com/butterfly-extsrc@latest/dist/fireworks.min.js"></script><script src="https://npm.elemecdn.com/butterfly-extsrc@latest/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script></div></body></html>