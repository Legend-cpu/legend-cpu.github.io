<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>将Windows cmd添加到右键快捷菜单中</title>
      <link href="/article/4eaa91843bcd.html"/>
      <url>/article/4eaa91843bcd.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文参考教程：<a href="https://zhuanlan.zhihu.com/p/380474966">将windows10的CMD添加到右键菜单中</a></p></blockquote><p>先上效果图：</p><p><img src="https://elzzach-src.oss-cn-hangzhou.aliyuncs.com/img/20220918/image-20220918201541032.png" alt="image-20220918201541032"></p><p>就像上面的Git Bash Here一样，可以在当前目录快速打开cmd命令行。</p><p>步骤：</p><ol><li>创建一个存放新cmd的文件夹</li></ol><p>打开cmd输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> <span class="string">&quot;%USERPROFILE%\AppData\Local\terminal&quot;</span></span><br></pre></td></tr></table></figure><p><code>%USERPROFILE%</code>就是 <code>C:\Users\你的用户名</code>这个目录。</p><ol start="2"><li><p>将 cmd.exe 复制到刚刚创建的文件夹中，cmd.exe原始文件在<code>C:\Windows\System32\cmd.exe</code>这里。</p></li><li><p>在刚创建的文件夹中放入一个ico文件用作新cmd的应用图标，我没有找到cmd的默认图标在哪里，就在<a href="https://icon-icons.com/zh/%E6%9F%A5%E6%89%BE/%E5%9B%BE%E6%A0%87/?filtro=windows+cmd&fcolor=all">网上</a>找了一个。</p></li><li><p>重命名文件为mcd.exe和mcd.ico</p></li></ol><p><img src="https://elzzach-src.oss-cn-hangzhou.aliyuncs.com/img/20220918/image-20220918202418206.png" alt="image-20220918202418206"></p><ol start="5"><li>新建一个txt文本文档并更名为1.reg，文档内写入如下内容保存，双击此文件修改注册表即可。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\Directory\Background\shell\wt]</span><br><span class="line">@=&quot;Windows terminal here&quot;</span><br><span class="line">&quot;Icon&quot;=&quot;C:\\Users\\你的用户名\\AppData\\Local\\terminal\\mcd.ico&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\Directory\Background\shell\wt\command]</span><br><span class="line">@=&quot;C:\\Users\\DELL\\你的用户名\\Local\\terminal\\mcd.exe s k pushd %V&quot;</span><br></pre></td></tr></table></figure><ol start="6"><li>右键测试一下，是不是成功了？</li></ol><p>有一点小问题就是打开我们的mcd.exe之后顶部会出现一条消息”系统无法在消息文件中为 Application 找到消息号为 0x2350 的消息文本。”，鉴于它本来的文本是”Microsoft Windows [版本号]”，我觉得就没有必要纠结这个问题了。</p>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> cmd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WinSCP如何设置用密钥登录服务器而不是密码登录</title>
      <link href="/article/9ee0e5cdfe67.html"/>
      <url>/article/9ee0e5cdfe67.html</url>
      
        <content type="html"><![CDATA[<p>用过WinSCP的都知道它默认设置是要你用密码登录的，但如果你为了安全要禁用服务器密码登录的话是不是WinSCP就用不了了呢？当然不是，WinSCP也可以使用密钥登录，但是可能要稍微折腾一下。</p><p>通常来说我们生成的服务器密钥都是用OpenSSL生成的，而WinSCP不支持这种格式的密钥，它支持的是pkk格式的密钥。所以我们要将OpenSSL格式的密钥转换为ppk格式的密钥。</p><p>首先我们需要先下载PuTTYgen工具，官网下载地址在<a href="https://www.puttygen.com/download-putty">这里</a>。</p><p>下载安装好了之后打开WinSCP，在跳出来的对话框里点开 工具 - 运行PuTTYgen：</p><p><img src="https://elzzach-src.oss-cn-hangzhou.aliyuncs.com/img/20220918/image-20220918195005468.png" alt="image-20220918195005468"></p><p>打开之后点击Load：</p><p><img src="https://elzzach-src.oss-cn-hangzhou.aliyuncs.com/img/20220918/image-20220918195058549.png" alt="image-20220918195058549"></p><p>然后选择你所要转换的私钥文件，不带pub的那个。打开的文件资源管理器里默认选择的范围是ppk文件，改成All Files不用多说了吧。</p><p>Load完了之后直接点击Save private key即可 ，不要点Generate，也不要去输密码，除非你不介意以后每次连接都需要输入一次密钥密码的话。</p><p>输入你想保存的文件名，然后保存为ppk格式的文件，这样我们就转换完成了。</p><p>然后在登录对话框界面点击“高级”，在如下界面选择你刚刚保存的ppk文件，确定退出即可。</p><p><img src="https://elzzach-src.oss-cn-hangzhou.aliyuncs.com/img/20220918/image-20220918195826644.png" alt="image-20220918195826644"></p><p>现在再试一试登录，你就发现WinSCP是直接使用密钥文件登录而不是密码登录了。</p>]]></content>
      
      
      <categories>
          
          <category> WinSCP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密钥 </tag>
            
            <tag> WinSCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用密钥登录服务器以及服务器禁用密码登录</title>
      <link href="/article/f28c8157b35f.html"/>
      <url>/article/f28c8157b35f.html</url>
      
        <content type="html"><![CDATA[<p>用密码登录服务器的时候每次都要在命令行输入服务器密码，次数多了之后难免就觉得有些麻烦，后来听说可以用密钥文件来直接免密登录，并且可以禁用服务器密码登录，安全并且便捷。所以就去尝试了一下，尝试成功之后写了一个bat文件，直接双击就可以连接服务器了，比之前命令行输命令方便了太多。</p><h2 id="创建密钥对"><a href="#创建密钥对" class="headerlink" title="创建密钥对"></a>创建密钥对</h2><p>前提：你的用户目录（有<code>AppData</code>的那个文件夹，或者说<code>Users</code>文件夹底下的某个文件夹，或者说中文版Windows可能是<code>用户</code>文件夹底下的某个文件夹）底下有<code>.ssh</code>文件夹，没有就自己创建一个；你的电脑上有OpenSSL，没有就自己搜索解决办法啦。</p><p>进入路径<code>C:\Users\你的用户名\.ssh</code>，进入命令行在当前目录下执行命令<code>ssh-keygen -t rsa -b 4096</code>：</p><p><img src="https://elzzach-src.oss-cn-hangzhou.aliyuncs.com/img/20220918/image-20220918175922962.png" alt="image-20220918175922962"></p><p>请不要在意我执行命令的路径，我是随便挑的路径，但是真正在做的时候需要在<code>.ssh</code>目录下执行。</p><p>执行完毕后在当前目录下会生成两个文件，带pub后缀的是公钥文件，不带pub后缀的是私钥文件。接下来我们需要将公钥复制一份到服务器上。</p><p>首先确认服务器上的<code>/root/.ssh/</code>目录下是否有一个<code>authorized_keys</code>文件，没有就自己新建一个。然后打开这个文件，将刚刚生成的pub公钥文件里面的内容复制粘贴到<code>authorized_keys</code>文件里，保存并退出即可。</p><p>这样就完成了，现在应该能够使用私钥免密登录服务器了，试着执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /d C:\Users\你的用户名\.ssh</span><br><span class="line">ssh -i 你的私钥文件名 root@服务器ip</span><br></pre></td></tr></table></figure><p>如果仍然需要输入密码才能登录，请确认服务器上的文件权限是否正确：.ssh文件夹的权限为700，authorized_keys文件的权限为600。如果不是请自己改一下。</p><p>当然如果你觉得虽然不用输密码了，但是每次都要输入比之前更长的命令还是很麻烦，不妨尝试写一个bat文件，双击执行直接连接服务器：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">cd</span> /d C:\Users\你的用户名\.ssh</span><br><span class="line">ssh -i 你的私钥文件名 root@服务器ip</span><br></pre></td></tr></table></figure><blockquote><p>请一定要妥善保护好你的私钥文件，尤其是在禁用密码登录之后。</p></blockquote><h2 id="禁用服务器密码登录"><a href="#禁用服务器密码登录" class="headerlink" title="禁用服务器密码登录"></a>禁用服务器密码登录</h2><div class="note danger flat"><p>务必在确认你的其他登录服务器方法可以正常使用之后再进行这一步</p></div><p>修改服务器上的<code>/etc/ssh/ssh_config</code>文件，在<code>Host *</code>下面添加一行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Host *</span><br><span class="line">    PasswordAuthentication no</span><br></pre></td></tr></table></figure><p>保存并退出即可。</p><p>其实促使我禁用服务器密码登录的契机是大概一周之前我的服务器莫名其妙被一个重庆IP给登录了（我的密码绝对是一个高强度的密码），就很离谱，然后我就改了一个密码，后来想想还是直接禁用密码登录得了。</p><p>附带一个之前看到的检查SSH端口是否被攻击的文章，原文<a href="https://www.bilibili.com/read/cv18320321">在此</a>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">btmp文件会记录SSH端口登录失败的信息，包括尝试的用户名、IP地址和时间等信息。</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">btmp为二进制文件，文件路径为/var/log/btmp。</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">1. 查看文件btmp</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">使用命令lastb可以查看文件btmp的信息，参数-n可以指定显示数量。</span></span><br><span class="line"></span><br><span class="line">lastb -n 10 | tac</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">2. 查看攻击者IP及攻击次数</span></span><br><span class="line"></span><br><span class="line">lastb | awk &#x27;&#123; print $3&#125;&#x27; | sort | uniq -c | sort -n</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">3. 查看攻击者尝试的用户名</span></span><br><span class="line"></span><br><span class="line">lastb | awk &#x27;&#123; print $1&#125;&#x27; | sort | uniq -c | sort -n</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">4. 分析攻击者</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">对攻击次数第一的IP进行分析。</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">查看攻击开始时间</span></span><br><span class="line"></span><br><span class="line">lastb | grep 137.184.155.125</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">查看攻击终止时间</span></span><br><span class="line"></span><br><span class="line">lastb | grep 137.184.155.125 | tac</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">查看IP地理位置</span></span><br><span class="line"></span><br><span class="line">curl ipinfo.io/137.184.155.125</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 服务器 </tag>
            
            <tag> 密钥 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shadow DOM和自定义元素的基本使用</title>
      <link href="/article/ac7a614ad74c.html"/>
      <url>/article/ac7a614ad74c.html</url>
      
        <content type="html"><![CDATA[<p>在开发本站的实验室页面的过程中突然想到使用自定义元素来实现那些效果展览组件，然后就想到了之前在哪个网站上看到的shadow DOM，就去MDN文档上看了一下基本教程，以下为MDN文档中shadow DOM的学习笔记，原文档在<a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_shadow_DOM">这里</a>。</p><div class="note info flat"><p>要看懂下面的内容，你需要先了解js面向对象中的类定义和类继承。</p></div><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>shadow DOM API 是Web组件的一种封装方式，能够将标记结构、样式、行为等隐藏起来，独立于页面上的其他正常DOM元素。shadow DOM API提供了将隐藏的分离DOM树附加到正常元素上的方法。这种隐藏的DOM树称为shadow tree，它除了不会影响其外部的代码之外其他操作和正常的DOM树都一模一样。</p><blockquote><p>文档原文：“请注意，shadow DOM 无论如何都不是什么新鲜事物——浏览器长期以来一直使用它来封装元素的内部结构。想想一个例子 ： <code>&lt;video&gt;</code>元素，你在 DOM 中看到的只是 <code>&lt;video&gt;</code>元素，但它在其 shadow DOM 中包含一系列按钮和其他控件。”</p></blockquote><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>首先上一个示例源码：</p><p>html代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;./css/index.css&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">popup-info</span> <span class="attr">data-text</span>=<span class="string">&quot;Your card validation code (CVC) is an extra security feature — it is the last 3 or 4 numbers on the back of your card.&quot;</span> <span class="attr">img</span>=<span class="string">&quot;img/alt.png&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./js/index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>css代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.info</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">0.8rem</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">background</span>: white;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">transition</span>: <span class="number">0.6s</span> all;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">1.2rem</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.icon</span><span class="selector-pseudo">:hover</span> + <span class="selector-class">.info</span>, <span class="selector-class">.icon</span><span class="selector-pseudo">:focus</span> + <span class="selector-class">.info</span> &#123;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>js代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PopUpInfo</span> <span class="keyword">extends</span> <span class="title class_ inherited__">HTMLElement</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// Always call super first in constructor</span></span><br><span class="line">        <span class="variable language_">super</span>();</span><br><span class="line">        <span class="comment">// write element functionality in here</span></span><br><span class="line">        <span class="keyword">const</span> shadow = <span class="variable language_">this</span>.<span class="title function_">attachShadow</span>(&#123;<span class="attr">mode</span>: <span class="string">&quot;open&quot;</span>&#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Create spans</span></span><br><span class="line">        <span class="keyword">const</span> wrapper = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;span&#x27;</span>);</span><br><span class="line">        wrapper.<span class="title function_">setAttribute</span>(<span class="string">&#x27;class&#x27;</span>, <span class="string">&#x27;wrapper&#x27;</span>);</span><br><span class="line">        <span class="keyword">const</span> icon = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;span&#x27;</span>);</span><br><span class="line">        icon.<span class="title function_">setAttribute</span>(<span class="string">&#x27;class&#x27;</span>, <span class="string">&#x27;icon&#x27;</span>);</span><br><span class="line">        icon.<span class="title function_">setAttribute</span>(<span class="string">&#x27;tabindex&#x27;</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">        <span class="keyword">const</span> info = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;span&#x27;</span>);</span><br><span class="line">        info.<span class="title function_">setAttribute</span>(<span class="string">&#x27;class&#x27;</span>, <span class="string">&#x27;info&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Take attribute content and put it inside the info span</span></span><br><span class="line">        info.<span class="property">textContent</span> = <span class="variable language_">this</span>.<span class="title function_">getAttribute</span>(<span class="string">&#x27;data-text&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Insert icon</span></span><br><span class="line">        <span class="keyword">const</span> img = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">        img.<span class="property">src</span> = <span class="string">&#x27;img/default.png&#x27;</span>;</span><br><span class="line">        icon.<span class="title function_">appendChild</span>(img);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// attach the created elements to the shadow DOM</span></span><br><span class="line">        shadow.<span class="title function_">appendChild</span>(wrapper);</span><br><span class="line">        wrapper.<span class="title function_">appendChild</span>(icon);</span><br><span class="line">        wrapper.<span class="title function_">appendChild</span>(info);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// another way to add HTML elements to the shadow DOM</span></span><br><span class="line">        shadow.<span class="property">innerHTML</span> += <span class="string">&quot;&lt;p&gt;fjdsljflkdsjfldjslfj&lt;/p&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Define the new element</span></span><br><span class="line">customElements.<span class="title function_">define</span>(<span class="string">&#x27;popup-info&#x27;</span>, <span class="title class_">PopUpInfo</span>);</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://elzzach-src.oss-cn-hangzhou.aliyuncs.com/img/20220902/image-20220902141637455.png" alt="image-20220902141637455"></p><blockquote><p>emm因为我根本没有那张图片所以图里是那个样子的，不过不影响。</p></blockquote><p>可以看到在html代码中我们直接使用了<code>&lt;popup-info&gt;</code>这个我们自定义的标签。</p><p>使用shadow DOM和自定义元素的核心和重点在于js代码，下面来解释上面的js代码。</p><p>要自定义元素，首先要定义一个继承了HTMLElement类的类，这里我们定义了一个PopUPInfo类，并继承了HTMLElement类。</p><p>类定义中只需要一个constructor构造函数即可，在构造函数中首先需要调用super()函数。</p><p>再接下来我们需要将一个shadow tree附加到我们指定的正常元素上，使用<code>element.attachShadow()</code>方法，其中element是我们要将shadow tree附加到上面的正常DOM元素。该方法接收一个对象作为参数，详细文档请见<a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/attachShadow">这里</a>，我们一般只需要写一个<code>&#123;mode: &quot;open&quot;&#125;</code>即可，代表该shadow tree是可以从外部的js来访问的。该方法将返回所附加的shadow tree的根元素（一个<code>ShadowRoot</code>对象，可以类比一下html文档的根元素）。</p><p>那么在类定义中，我们这样来附加shadow tree到我们自定义的元素上：<code>const shadow = this.attachShadow(&#123;mode:&quot;open&quot;&#125;)</code>。</p><p>剩下的代码就是用于充实shadow tree的，也就是我们要在这个shadow tree中添加各种标签、各种HTML元素来实现我们所要实现的组件。我们可以采用“<code>createElement()</code>、设置标签属性、<code>appendChild()</code>”这样的方式来给shadow tree添加子元素，也可以直接将HTML代码字符串赋值给<code>shadow.innerHTML</code>（shadow是我刚刚上面定义的那个变量）。</p><p>类定义完成了之后，如果我们要在html中实际使用这个自定义标签的话，我们还需要调用一个<code>customElements.define(&#39;自定义标签名&#39;, 该标签所继承的类)</code>方法，customElements是一个内置的对象，不是我随便编的一个变量名。</p><p>现在，我们在html代码中写入我们自定义的标签，并对其设置一些css样式（具体可以参考上面的示例），然后打开就可以看到效果了。</p><blockquote><p>如果没有看到效果，有可能是因为标签写法的问题，我没有搞懂具体原因，但是在我的测试中自定义标签需要写成那种单标签的形式，就像&lt; img &gt;标签那样，如果写成拥有闭合标签的形式就没有效果了。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> DOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使Linux的crontab定时任务以小于1分钟/次的频率执行</title>
      <link href="/article/67ca843744d2.html"/>
      <url>/article/67ca843744d2.html</url>
      
        <content type="html"><![CDATA[<p>根据cron表达式的格式我们可以知道，仅通过一个cron表达式我们能够实现的最快的执行频率是“每分钟都执行一次”，也就是 <code>* * * * *</code>这个表达式。那如果我想让一个定时任务每30秒执行一次呢？</p><p>这时候我们就要走点歪路线了，实际上我们可以设置两个执行内容相同的定时任务，但是其中一个定时任务要比另一个延迟30秒进行，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* * * * * command</span><br><span class="line">* * * * * sleep 30;command</span><br></pre></td></tr></table></figure><p>这样的话两个都是每分钟执行一次，但是第二个会比第一个晚30秒执行，由于两个任务内容一样，总体上来看这个任务就是每30秒执行了一次。</p><p>那么依次类推，20秒执行一次我们就这样写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* * * * * command</span><br><span class="line">* * * * * sleep 20;command</span><br><span class="line">* * * * * sleep 40;command</span><br></pre></td></tr></table></figure><p>15秒执行一次我们就这样写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* * * * * command</span><br><span class="line">* * * * * sleep 15;command</span><br><span class="line">* * * * * sleep 30;command</span><br><span class="line">* * * * * sleep 45;command</span><br></pre></td></tr></table></figure><p>同理，12秒一次、10秒一次、6秒一次等等，我们都可以根据上面的规律写出来。</p><p>那如果我想让一个任务每40秒执行一次呢？</p><p>也可以实现，只不过前面的cron表达式得改一下，比如可以这样写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*/2 * * * * command</span><br><span class="line">*/2 * * * * sleep 40;command</span><br><span class="line">*/2 * * * * sleep 80;command</span><br></pre></td></tr></table></figure><p>三个每两分钟执行一次的任务，但是第一个延迟40秒执行，第二个延迟80秒执行。</p><p>综上，我们可以总结出规律：</p><p>如果我们想要一个任务每n秒执行一次（n&lt;60），首先我们要找到这个n和60的最小公倍数，把这个最小公倍数的单位换算为分钟，设为a分钟；那么我们的定时任务可以这么设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*/a * * * * command</span><br><span class="line">*/a * * * * sleep n;command</span><br><span class="line">*/a * * * * sleep 2*n;command</span><br><span class="line">*/a * * * * sleep 3*n;command</span><br><span class="line">...</span><br><span class="line">*/a * * * * sleep [(a*60/n)-1]*n;command</span><br></pre></td></tr></table></figure><p>但是还有一个限制条件，就是这个只对满足与60的最小公倍数小于1800的n有效，因为超过1800的话a就会超过30，而cron表达式中比如<code>*/31 * * * *</code>指的是每小时的第0和第31分钟执行一次，不是每31分钟执行一次。不过一般来说这个解决办法可以满足多数需要执行频率小于1分钟的需求了。</p><blockquote><p>突然想到这样一行一行敲太麻烦了，可以写个脚本来根据参数生成需要对应的内容供我们直接复制粘贴 _ (:з)∠)_</p><p>想用node写一个，写好了更新上来。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> crontab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何延长服务器SSH远程连接保持时间</title>
      <link href="/article/dbfc3245bcec.html"/>
      <url>/article/dbfc3245bcec.html</url>
      
        <content type="html"><![CDATA[<p>解决一个算是痛点的问题吧，就是ssh连接云服务器的人都知道如果三分钟没有操作的话ssh连接就断开了导致终端界面卡住，只能重新连接。虽然使用密钥登录服务器代替密码登录减轻了登录服务器所用的时间成本，但是总是重连还是很烦，导致连着服务器的时候都不敢去放心干别的事情比如研究教程、写东西之类的了，所以我们有需求的话可以先延长一下ssh远程连接的保持时间。</p><p>首先打开<code>/etc/ssh/sshd_config</code>文件，然后找到这么两行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClientAliveInterval 0 # 默认为0，表示服务器每60秒发一个空数据包给客户端确认是否保持活跃，如果没有反应就判定为一次超时</span><br><span class="line">ClientAliveCountMax 3 # 允许超时的次数，默认为3次，所以三分钟不操作连接就断开了</span><br></pre></td></tr></table></figure><p>我们可以设置为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClientAliveInterval 60 # 表示服务器每60秒发一个空数据包给客户端</span><br><span class="line">ClientAliveCountMax 60 # 允许超时的次数为60次</span><br></pre></td></tr></table></figure><p>60秒 * 60次，即连接可以在无操作的情况下保持一个小时。</p><p>或者你也可以设置为120秒 * 720次，即连接可以保持24小时。</p><p>配置完之后重启一下sshd服务：<code>systemctl restart sshd</code>。</p><p>然后你可以把终端放一边放个几分钟看会不会断开，如果断开了就再确认一下配置文件写的是否正确，然后再次重启一下服务应该就好了。</p><p>配置完这个之后与该服务器相连的ssh连接时间都会延长，像终端或者WinSCP软件之类的，不用频繁重连的确方便了很多。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> SSH </tag>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx配置之日志记录、禁用IP访问和设置IP白名单</title>
      <link href="/article/565280162912.html"/>
      <url>/article/565280162912.html</url>
      
        <content type="html"><![CDATA[<p>在服务器上建成了一个网站之后，我们总想知道到底有没有人来访问我们的网站啊？虽然有一些现成的网站统计服务但是由于不知道细节，我们也不知道到底准不准确。所以，如果你的网站使用的是nginx服务器的话就可以通过Nginx的日志来解决这个问题了，Nginx会将每个它所监听的端口收到的请求的来源IP记录在日志当中。</p><h2 id="开启并配置Nginx日志记录"><a href="#开启并配置Nginx日志记录" class="headerlink" title="开启并配置Nginx日志记录"></a>开启并配置Nginx日志记录</h2><p>Nginx的日志貌似并不是默认开启的，所以你需要先查看一下你的nginx配置文件nginx.conf，在之前建站过程中已经用到它了，所以它的位置你应该记得，在nginx安装目录下的&#x2F;conf&#x2F;nginx.conf处，比如&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure><p>在文件开头位置应该能找到一个被注释掉的错误日志配置<code>error_log</code>，把#号删掉；然后在http字段里、server字段之前应该还能找到一个被注释掉的<code>log_format</code>配置和<code>access_log</code>配置，把#号删掉，这样就开启了nginx的日志记录功能。</p><p>大概长这样：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">log_format</span>  main  <span class="string">&#x27;<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] &quot;<span class="variable">$request</span>&quot; &#x27;</span></span><br><span class="line">                  <span class="string">&#x27;<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> &quot;<span class="variable">$http_referer</span>&quot; &#x27;</span></span><br><span class="line">                  <span class="string">&#x27;&quot;<span class="variable">$http_user_agent</span>&quot; &quot;<span class="variable">$http_x_forwarded_for</span>&quot; &quot;<span class="variable">$request_body</span>&quot;&#x27;</span>;</span><br><span class="line"><span class="attribute">access_log</span>  /var/log/nginx/access.log   main; <span class="comment"># 这一行被我修改过了，路径不同不要在意</span></span><br></pre></td></tr></table></figure><p>解释一下这些日志配置里的一些参数：</p><p><code>log_format</code>后面跟着的一个<code>main</code>是这个日志格式方案的名字，类似于一个变量名，你看<code>access_log</code>所在行的最后一个是不是就是main，表示应用了这个叫main的日志格式方案。当然这个名字你可以随便改。</p><p><code>$remote_addr</code>就是请求的来源IP。</p><p><code>$remote_user</code>我不太理解到底是什么，但是对于服务器外来的请求来说一般是获取不到这个值的，所以也不用太在意它。</p><p><code>$time_local</code>是本地方式表示的时间，默认是像<code>20/Aug/2022:16:11:43 +0800</code>这样的。</p><p><code>$request</code>是请求方法+请求的url+请求协议，比如像<code>GET / HTTP/1.1</code>，这就说明用HTTP1.1版本中的GET方法请求了你网站的首页。</p><p><code>$status</code>是请求的状态码。</p><p><code>$body_bytes_sent</code> 是返回的响应的响应体的字节数。</p><p><code>$http_referer</code>对应着请求头中的referer字段。</p><p><code>$http_user_agent</code>对应着请求头中的user-agent字段。</p><p><code>$http_x_forwarded_for</code>对应着请求头中的x-forwarded-for字段，用来表示HTTP请求端真实IP，同时会记录请求经过的中间代理的IP。</p><p><code>$retuest_body</code>就是请求体。</p><p>此外还有一个比较有用的<code>$http_host</code>，对应着请求头中的host字段。</p><p>虽然<code>log_format</code>后面的三个字符串分布在三行，但是实际记录的时候它们是在一行里面的，并且中间没有空格。</p><p><code>access_log</code>后面的路径是日志文件的路径，如果你指定的路径暂时还不存在的话最好先去创建一下文件夹。</p><blockquote><p>千万别忘记了nginx配置文件语句的末尾要有分号。</p></blockquote><p>知道了这些参数都是什么意思之后我们就可以自定义自己看起来比较舒服的日志格式，当然也可以保持默认的。</p><p>我的日志格式写成这样了：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">log_format</span> main <span class="string">&#x27;<span class="variable">$remote_addr</span> [<span class="variable">$time_local</span>]: &quot;<span class="variable">$http_host</span>&quot; &quot;<span class="variable">$request</span>&quot; <span class="variable">$status</span> &quot;<span class="variable">$http_referer</span>&quot; &quot;<span class="variable">$http_user_agent</span>&quot; <span class="variable">$http_x_forwarded_for</span>&#x27;</span>;</span><br></pre></td></tr></table></figure><p>尽量保持简洁，不要有过多的除引号、方括号、连字符外的其他符号，否则后面使用Goaccess分析的时候匹配日志格式可能会莫名其妙地失败。</p><p>实际的日志像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">17.6.8.20 [20/Aug/2022:16:11:43 +0800]: &quot;blog.elzzach.top&quot; &quot;GET / HTTP/1.1&quot; 200 &quot;-&quot; &quot;Mozilla/5.0 (Android 10; Mobile; rv:103.0) Gecko/103.0 Firefox/103.0&quot; -</span><br></pre></td></tr></table></figure><p>这条日志中没有获取到$http_referer和$http_x_forwarded_for，所以用 - 表示。</p><p>日志格式配置完毕之后保存并退出nginx.conf文件，然后重启nginx（仅重载配置可能不会生效）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/nginx/sbin</span><br><span class="line">ps -ef|grep nginx //查看nginx进程的pid</span><br><span class="line"><span class="built_in">kill</span> -QUIT pid</span><br><span class="line">./nginx -c /usr/local/nginx/conf/nginx.conf //以指定配置文件打开nginx服务</span><br><span class="line">./nginx -s reload //重载配置</span><br><span class="line">./nginx -s reopen //重新打开日志文件</span><br></pre></td></tr></table></figure><p>然后访问一下你的网站，再前往你指定的日志文件所在处看有没有日志文件生成，如果没有就再重启一遍（ 。。。）。</p><p>像我使用密钥登录服务器的话还可以本地写一个bat文件执行之后自动远程下载服务器上的日志文件到本地供我查看，省得每次都要登录服务器看。</p><h2 id="Goaccess日志分析工具"><a href="#Goaccess日志分析工具" class="headerlink" title="Goaccess日志分析工具"></a>Goaccess日志分析工具</h2><p>日志看着看着可能就会萌生了将日志中的各种信息统计一下汇总出一些表格之类的想法，当然可以自己写脚本了，不过比较麻烦，这里推荐一个叫Goaccess的日志分析工具，它可以根据你的服务器日志生成相应的可视化图表，尤其是它能生成非常炫酷的html数据可视化页面：</p><p><img src="https://elzzach-src.oss-cn-hangzhou.aliyuncs.com/img/20220821/image-20220821095109826.png" alt="image-20220821095109826"></p><p>Goaccess是安装在服务器上的，在安装它之前首先要安装它的依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install ncurses-devel geoip-devel libmaxminddb-devel tokyocabinet-devel openssl-devel</span><br></pre></td></tr></table></figure><p>然后我仍然是习惯于将一些软件包安装在&#x2F;opt&#x2F;tools里：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt/tools</span><br><span class="line">wget https://tar.goaccess.io/goaccess-1.3.tar.gz</span><br><span class="line">tar -xzvf goaccess-1.3.tar.gz</span><br><span class="line"><span class="built_in">cd</span> goaccess-1.3</span><br><span class="line">./configure --enable-utf8 --enable-geoip=legacy //第一个参数是开启utf8编码支持，第二个参数是使用 GeoIP 数据库</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>编译安装成功之后可以输入<code>goaccess -V</code>看一下版本信息，有就是真的成功了。</p><p>然后我们需要配置一下日志格式，没错，又要配置日志格式了，我们需要让goaccess的日志匹配模式和我们的nginx日志格式配置一样它才能成功解析出结果。</p><p>首先找一找goaccess的默认配置文件路径，可使用<code>goaccess --dcf</code>命令查看，如果显示没有就只能自己指定了，可以去<code>/usr/local/etc/</code>目录看看底下有没有<code>/goaccess/goaccess.conf</code>文件，如果有，以后执行命令的时候使用<code>-p</code>参数指定该路径即可。</p><p>现在只需要打开这个文件，然后在里面找到这么几行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Apache/NGINX&#x27;s log formats below.</span><br><span class="line">#</span><br><span class="line">time-format %H:%M:%S</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"># Apache/NGINX&#x27;s log formats below.</span><br><span class="line">#</span><br><span class="line">date-format %d/%b/%Y</span><br></pre></td></tr></table></figure><p><code>time-format</code>和<code>date-format</code>默认是被注释的，把注释去掉就行了。另外只要你的nginx日志中的<code>$time_local</code>的格式是我刚说的那样，这两个值就不用改。</p><p>然后在里面再找到下面这些：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">######################################</span><br><span class="line"># Log Format Options (required)</span><br><span class="line">######################################</span><br><span class="line">#</span><br><span class="line"># The log-format variable followed by a space or \t for</span><br><span class="line"># tab-delimited, specifies the log format string.</span><br><span class="line">#</span><br><span class="line"># NOTE: If the time/date is a timestamp in seconds or microseconds</span><br><span class="line"># %x must be used instead of %d &amp; %t to represent the date &amp; time.</span><br><span class="line"></span><br><span class="line"># NCSA Combined Log Format</span><br><span class="line">#log-format %h %^[%d:%t %^] &quot;%r&quot; %s %b &quot;%R&quot; &quot;%u&quot;</span><br><span class="line"></span><br><span class="line"># NCSA Combined Log Format with Virtual Host</span><br><span class="line">#log-format %v:%^ %h %^[%d:%t %^] &quot;%r&quot; %s %b &quot;%R&quot; &quot;%u&quot;</span><br><span class="line"></span><br><span class="line"># Common Log Format (CLF)</span><br><span class="line">#log-format %h %^[%d:%t %^] &quot;%r&quot; %s %b</span><br><span class="line"></span><br><span class="line"># Common Log Format (CLF) with Virtual Host</span><br><span class="line">#log-format %v:%^ %h %^[%d:%t %^] &quot;%r&quot; %s %b</span><br><span class="line"></span><br><span class="line"># W3C</span><br><span class="line">#log-format %d %t %h %^ %^ %^ %^ %r %^ %s %b %^ %^ %u %R</span><br><span class="line"></span><br><span class="line"># Squid native log format</span><br><span class="line">#log-format %^ %^ %^ %v %^: %x.%^ %~%L %h %^/%s %b %m %U</span><br><span class="line"></span><br><span class="line"># AWS | Amazon CloudFront (Download Distribution)</span><br><span class="line">#log-format %d\t%t\t%^\t%b\t%h\t%m\t%^\t%r\t%s\t%R\t%u\t%^</span><br><span class="line"></span><br><span class="line"># Google Cloud Storage</span><br><span class="line">#log-format &quot;%x&quot;,&quot;%h&quot;,%^,%^,&quot;%m&quot;,&quot;%U&quot;,&quot;%s&quot;,%^,&quot;%b&quot;,&quot;%D&quot;,%^,&quot;%R&quot;,&quot;%u&quot;</span><br><span class="line"></span><br><span class="line"># AWS | Elastic Load Balancing</span><br><span class="line">#log-format %dT%t.%^ %^ %h:%^ %^ %T %^ %^ %^ %s %^ %b &quot;%r&quot; &quot;%u&quot;</span><br><span class="line"></span><br><span class="line"># AWSS3 | Amazon Simple Storage Service (S3)</span><br><span class="line">#log-format %^[%d:%t %^] %h %^&quot;%r&quot; %s %^ %b %^ %L %^ &quot;%R&quot; &quot;%u&quot;</span><br><span class="line"></span><br><span class="line"># Virtualmin Log Format with Virtual Host</span><br><span class="line">#log-format %h %^ %v %^[%d:%t %^] &quot;%r&quot; %s %b &quot;%R&quot; &quot;%u&quot;</span><br><span class="line"></span><br><span class="line">#Custom Log Format</span><br><span class="line">log-format %h [%d:%t %^]: &quot;%v&quot; &quot;%r&quot; %s &quot;%R&quot; &quot;%u&quot; %^</span><br></pre></td></tr></table></figure><p>其中最后一个Custom Log Format是我自己加上的，为的是对应我自己设置的nginx日志格式。</p><p><code>log-format</code>字段中各个参数的意义在<a href="https://www.goaccess.cc/">这里</a>的“自定义 日志&#x2F;日期 格式”一节中有讲，读者请自行研究。</p><p>如果nginx日志格式是保持了默认的话，那么<code>log-format</code>应该这么写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log-format %h %^[%d:%t %^] &quot;%r&quot; %s %b &quot;%R&quot; &quot;%u&quot;</span><br></pre></td></tr></table></figure><p>而对于我自定义的nginx日志格式<code>log_format main &#39;$remote_addr [$time_local]: &quot;$http_host&quot; &quot;$request&quot; $status &quot;$http_referer&quot; &quot;$http_user_agent&quot; $http_x_forwarded_for&#39;;</code>，<code>log-format</code>应该这么写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log-format %h [%d:%t %^]: &quot;%v&quot; &quot;%r&quot; %s &quot;%R&quot; &quot;%u&quot; %^</span><br></pre></td></tr></table></figure><p>一定要严格匹配，不然就会出错。另外nginx日志格式配置的最好普通一点，减少匹配错误的发生率。还有就是有一些该用<code>%^</code>忽略的就忽略，强行匹配也很可能会导致失败。</p><p>配置完毕之后我们就可以试试能不能生效了，在任意位置执行<code>goaccess -f /var/log/nginx/access.log -p /usr/local/etc/goaccess/goaccess.conf -o /var/log/nginx/accesslog.html -o /var/log/nginx/accesslog.json</code>命令（路径按自己的来），<code>-f</code>参数表示以后面的文件名为指定nginx日志文件，<code>-p</code>参数是指定配置文件的位置，<code>-o</code>是指将结果输出为后面的文件格式，可以输出为csv、html或者json文件，如果同时需要输出为两种格式需要两个<code>-o</code>参数，我这里是输出为html和json格式。</p><p>我们可以把输出的html文件远程下载到本地，然后浏览器打开查看，就会看到这一节开头的图片上的效果。</p><p>如果我们想进行实时html分析结果输出，按官方说法我们可以在执行命令的时候加入<code>--real-time-html</code>参数和<code>--daemonize</code>参数，但是我自己实践了之后发现html并没有实时更新，不知道是怎么回事，即使使用了nohup命令也没有用，所以我只好借助crontab定时任务来解决了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0-59 * * * * goaccess -f /var/log/nginx/access.log -p /usr/local/etc/goaccess/goaccess.conf -o /var/log/nginx/accesslog.html -o /var/log/nginx/accesslog.json</span><br></pre></td></tr></table></figure><p>即每分钟执行一次日志分析并输出html和json结果。</p><p>和上一节一样，如果用密钥登录服务器的话可以写一个bat文件执行时将输出的html文件和json文件远程下载到本地，然后可以用浏览器打开查看。</p><p>官方手册里还有更多玩法，读者可以自己去研究研究。</p><blockquote><p>日志证明，除了我自己，并没有人来访问这个网站（悲）</p></blockquote><h2 id="Nginx设置禁用IP访问"><a href="#Nginx设置禁用IP访问" class="headerlink" title="Nginx设置禁用IP访问"></a>Nginx设置禁用IP访问</h2><p>在goaccess工具生成的html页面中我们可以清楚地看到有哪些ip访问了我们的网站，可以去nginx日志文件中查看更加详细的信息。然后我发现，有很多来自国外的ip地址对我的服务器发起了一些奇奇怪怪的请求，有些甚至直接对着我的服务器ip而不是域名来请求的，所以我觉得或许应该设置一下不允许直接ip访问。</p><p>打开nginx.conf文件新添两个server节点，一个80的，一个443的（只有开了https的网站才需要443的）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen 80 default_server;</span><br><span class="line">        server_name _;</span><br><span class="line">        return 403 &quot;Access Denied&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>443的只要把你原来的443的server节点复制一下然后改一下<code>listen 443 ssl default_server;</code>和<code>server_name _;</code>以及最后加一个<code>return 403 &quot;Access Denied&quot;</code>就行了。</p><p>然后重载配置，再试着用ip去访问网站，应该就访问不了了。</p><h2 id="Nginx设置IP白名单"><a href="#Nginx设置IP白名单" class="headerlink" title="Nginx设置IP白名单"></a>Nginx设置IP白名单</h2><p>除了禁用IP直接访问外，我们还可以设置一个IP白名单，只允许大陆IP访问，其他IP统统返回403。</p><p>不设置黑名单是因为第一“宁可错封不可错放”（🥰），第二白名单的量比较少一些。</p><p>在nginx.conf文件的同级目录下新建一个ip-whitelist.conf文件（想叫什么都可以），然后往里面写入你的IP白名单，最后一行写一个<code>deny all;</code>：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">allow</span> xx.xx.xx.xx/<span class="number">10</span>;</span><br><span class="line"><span class="attribute">allow</span> xx.xx.xx.xx/<span class="number">11</span>;</span><br><span class="line">......</span><br><span class="line"><span class="attribute">deny</span> all;</span><br></pre></td></tr></table></figure><p>也就是除了allow里写的IP网段外其余的全部拒绝掉。</p><p>当然仿照这个你如果想写黑名单的话也可以。</p><p>至于大陆IP库我推荐一个<a href="https://github.com/wendellouyang/geolite2_china_ip_list">Github仓库</a>，找里面的chnip.txt即可，然后你可以在VSCode里面编辑这份文件，在每一行IP网段的开头加一个allow和空格，行末加一个分号，以及最后一行加一个<code>deny all;</code>，如果会使用VSCode里的正则表达式搜索替换的话这些都是很快完成的事。</p><p>白名单文件完成了之后打开nginx.conf，在http字段中添加一行include即可：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line"><span class="attribute">include</span> ip-whitelist.conf;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后可能需要按照上面的方法重启一下nginx，然后重载配置才会生效。</p><p>禁用IP访问和IP白名单设置完之后再看看日志，一堆奇奇怪怪的请求通通抱着403回家啦🥰</p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Nginx </tag>
            
            <tag> GoAccess </tag>
            
            <tag> IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Node.js发送电子邮件并部署到CentOS7服务器上</title>
      <link href="/article/27d32ade3fef.html"/>
      <url>/article/27d32ade3fef.html</url>
      
        <content type="html"><![CDATA[<p>再过一个星期就要开学了，学校要求提交返校申请的时候要有7天健康打卡记录，但是呢，有时候就确实一整天都没想起来打卡，这不，我昨天的就忘了。要想凑够7天打卡的话从今天起得一天不落了，所以想想能不能敲个自动发邮件通知的程序然后放服务器上设置定时任务让它定点提醒我呢，刚好对怎么用代码发送电子邮件这事已经好奇很久了，所以就折腾了一下。</p><blockquote><p>本文所用的是QQ邮箱，其他邮箱可能需要自己去注意一下代码中一些参数的修改。</p></blockquote><h2 id="使用第三方包nodemailer发送电子邮件"><a href="#使用第三方包nodemailer发送电子邮件" class="headerlink" title="使用第三方包nodemailer发送电子邮件"></a>使用第三方包nodemailer发送电子邮件</h2><p>Node不像Python那样有一个smtp标准库可以用来发电子邮件，Node要发邮件的话只能依靠第三方包来实现。目前有一个叫nodemailer的包在电子邮件这块还是做的不错的，所以本文就使用它来实现电子邮件的发送了。</p><p>首先，我是在我自己的Windows电脑上来写代码的，因此我采用了全局安装包的方式来安装nodemailer：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install nodemailer -g</span><br></pre></td></tr></table></figure><p>实际上写Node项目的时候安装包最好的方式还是局部安装，也就是不要加-g参数，这样的话一个项目有自己独立的依赖，便于管理，并且后面我们将项目部署到服务器上的时候如果也是在服务器上全局安装包的话运行的时候会出现<code>Cannot find modules</code>报错的情况，只有局部安装包才能够正常运行。官方也有一个推荐的做法：“如果你的包是用来require的，就局部安装；如果你的包是要用在命令行运行的，那就全局安装。”</p><p>安装好之后就可以敲代码了，新建一个index.js文件然后在里面写下如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nodemailer = <span class="built_in">require</span>(<span class="string">&quot;nodemailer&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">    <span class="attr">host</span>: <span class="string">&#x27;smtp.qq.com&#x27;</span>, </span><br><span class="line">    <span class="attr">port</span>: <span class="number">465</span>, </span><br><span class="line">    <span class="attr">secure</span>: <span class="literal">true</span>, <span class="comment">// 官方文档里的说明：465端口就写true，其他端口就写false</span></span><br><span class="line">    <span class="attr">auth</span>: &#123;</span><br><span class="line">        <span class="attr">user</span>: <span class="string">&#x27;xxxxxxxx@qq.com&#x27;</span>, <span class="comment">// 发件人邮箱</span></span><br><span class="line">        <span class="attr">pass</span>: <span class="string">&#x27;xxxxxxxxxxxxxxx&#x27;</span>  <span class="comment">// 授权码或者密码，对于QQ邮箱来说需要生成授权码</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = nodemailer.<span class="title function_">createTransport</span>(config)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下为邮件配置</span></span><br><span class="line"><span class="keyword">const</span> mailConfig = &#123;</span><br><span class="line">    <span class="attr">from</span>: <span class="string">&#x27;xxxxxxxx@qq.com&#x27;</span>, <span class="comment">// 发件人邮箱</span></span><br><span class="line">    <span class="attr">to</span>: <span class="string">&#x27;xxxxxxxx@qq.com&#x27;</span>, <span class="comment">// 收件人邮箱，这里我是自己发给自己所以两个是一样的</span></span><br><span class="line">    <span class="attr">subject</span>: <span class="string">&quot;健康打卡提醒&quot;</span>, <span class="comment">// 邮件标题</span></span><br><span class="line">    <span class="attr">text</span>: <span class="string">&#x27;不要忘记今天的健康打卡哦&#x27;</span>,  <span class="comment">// 文本内容的邮件</span></span><br><span class="line">    <span class="comment">// html: &quot;&lt;h1&gt;我是大标题&lt;/h1&gt; &lt;div&gt;我是内容&lt;/div&gt;&quot;,  // 这是html内容的邮件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始发送邮件</span></span><br><span class="line">server.<span class="title function_">sendMail</span>(mailConfig, <span class="keyword">function</span>(<span class="params">err, msg</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;发送失败&quot;</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;发送成功&quot;</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>同时你的QQ邮箱需要如下设置：</p><ol><li>点进QQ邮箱的设置-账户一栏中，找到下面部分并开启IMAP&#x2F;SMTP服务，你也可以选择开启POP3&#x2F;SMTP服务，这两种服务的区别可以自己搜索一下，我选择了IMAP&#x2F;SMTP。<img src="https://elzzach-src.oss-cn-hangzhou.aliyuncs.com/img/20220817/image-20220817214418058.png" alt="image-20220817214421889"></li><li>点击图中的“生成授权码”，发短信验证后获得授权码，并填入上面代码中的pass处。这就相当于你邮箱的密码了，以后但凡涉及到用代码来登录QQ邮箱需要密码的话就使用这个授权码就行了，授权码可以多次生成，因此没必要记住它。</li></ol><p>都弄好以后可以尝试着运行一下这个js文件，应该就可以成功发送并接收到自己给自己发的邮件了。</p><h2 id="部署到CentOS7服务器上"><a href="#部署到CentOS7服务器上" class="headerlink" title="部署到CentOS7服务器上"></a>部署到CentOS7服务器上</h2><p>首先你的服务器上需要安装有node，安装教程可以看<a href="https://blog.csdn.net/qq_37955704/article/details/113395046">这个</a>。</p><p>然后我在&#x2F;var&#x2F;目录下新建一个scripts文件夹用于存放在服务器上运行的脚本文件，然后把刚刚写好的js文件用WinSCP软件上传过去，最后我的js文件的路径是这样的：&#x2F;var&#x2F;scripts&#x2F;nodejs&#x2F;health-clock-in-reminder&#x2F;index.js。</p><p>然后我们还需要在我们的服务器上再安装一个nodemailer包，因为服务器上没有。在上文中我们也说了，需要采用局部安装的方式，如果全局安装的话运行js文件时会出现<code>Cannot find modules</code>的报错。所以在&#x2F;var&#x2F;scripts&#x2F;nodejs&#x2F;health-clock-in-reminder目录下执行命令<code>npm install nodemailer</code>，安装完后可以尝试着运行<code>node /var/scripts/nodejs/health-clock-in-reminder/index.js</code>命令，接收到邮件就说明部署基本成功了。</p><p>接下来的任务是设置定时任务让这个脚本自动定时执行。Linux设置定时任务的工具是crontabs，可以先按以下步骤检查一下自己服务器上的crontabs工具是否准备就绪：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum list installed | grep crontabs</span><br><span class="line">// 没特别提示没安装就是安装了 ）</span><br><span class="line">systemctl status crond.service</span><br><span class="line">// 看到有一个绿色的active（running）就是启动了</span><br></pre></td></tr></table></figure><p>没安装就运行<code>yum install crontabs</code>，没启动就运行<code>systemctl start crond.service</code>。</p><p>如果crontabs准备就绪，使用它设置定时任务主要涉及到<code>crontab -e</code>（编辑定时任务文件）和<code>crontab -l</code>（查看已经设置的定时任务）两个命令。对于本文，我们需要设置一个定时任务让服务器到时自动执行<code>node /var/scripts/nodejs/health-clock-in-reminder/index.js</code>命令，至于具体的时间，我选择设置为“每天的21点整”，因此我要执行<code>crontab -e</code>命令，然后在打开的文件中按i键进入编辑模式（没错，和vim操作一样，所以我就不详细说了），新起一行输入<code>0 21 * * * node /var/scripts/nodejs/health-clock-in-reminder/index.js </code>，然后按esc键退出编辑模式并输入:wq保存并退出。</p><blockquote><p><code>0 21 * * *</code>是一个cron表达式，表示“每天的21点”。cron表达式的语法这里也不多说了，读者可自行搜索研究一下，并不难。另外推荐一个网站：<a href="https://crontab.guru/">Cronitor</a>，这个网站可以帮助我们检查自己的cron表达式是否达到了我们预期的定时效果。</p></blockquote><p>这样我们的定时任务就设置好了，接下来就是静待晚上21点它会不会自动发邮件了。但是事实是并没有，于是我又登录服务器手动执行了一遍<code>node /var/scripts/nodejs/health-clock-in-reminder/index.js</code>命令，发现成功发送了邮件，然后又执行了一遍<code>crontab -l</code>命令，发现我的定时任务也确实是设置了。这时我发现终端提示我在&#x2F;var&#x2F;spool&#x2F;mail&#x2F;root位置有新邮件，于是我执行了<code>vim /var/spool/mail/root</code>命令打开该文件，发现里面是一些日志记录，翻到最后，发现了21点的时候出现的一条日志，主要内容为<code>/bin/sh: node: command not found</code>。</p><p>嗯？看起来像是没有配置环境变量的时候会出现的错误。但是我的node命令可以在任何目录下运行啊，为什么会找不到呢？</p><p>后来经过一番搜索资料之后发现是由于crontab的执行环境变量与用户环境变量不同。我们用<code>whereis node</code>命令查询得到的node安装位置在&#x2F;usr&#x2F;local&#x2F;bin&#x2F;node处，但是crontab的执行环境变量里（在你查看&#x2F;var&#x2F;spool&#x2F;mail&#x2F;root文件里的日志的时候可以注意一下有一行的内容是<code>X-Cron-Env: &lt; PATH=/usr/bin:/bin &gt;</code>，这意味着它只会尝试着去&#x2F;usr&#x2F;bin目录或者&#x2F;bin目录里去寻找node，当然是找不到的）没有&#x2F;usr&#x2F;local&#x2F;bin这个路径，所以会出现<code>/bin/sh: node: command not found</code>的错误。</p><p>该问题的解决办法是将node所在目录的路径添加到crontab的执行环境变量中。最简单的添加方法是直接执行<code>crontab -e</code>命令，在打开的这份文件的开头依次添加以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SHELL=/bin/bash</span><br><span class="line">PATH=/usr/local/bin:/bin:/usr/bin</span><br><span class="line">MAILTO=root</span><br><span class="line">HOME=/</span><br></pre></td></tr></table></figure><p>可以看到在PATH的值中除了它默认的两个目录之外我将node所在目录&#x2F;usr&#x2F;local&#x2F;bin也添加进去了。</p><p>这样问题就解决了，我将cron表达式暂时改为<code>0-59 * * * *</code>，即每隔一分钟就执行一次任务，保存并退出，果然它开始每隔一分钟就发出一份邮件了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>复制粘贴node发送电子邮件的模板代码，安装好nodemailer包，准备好发信邮箱地址、发信邮箱密码&#x2F;授权码、收信邮箱地址等变量值，就可以成功用程序发送一封电子邮件了。</li><li>部署到服务器的时候一要注意局部安装nodemailer包，二要注意如果crontab的执行环境变量中没有node所在路径的话要执行<code>crontab -e</code>然后按上文所述在文件开头添加几个环境变量值，并在PATH值中将node所在路径添加进去。</li></ol><h2 id="附：使用Python的smtp标准库发送电子邮件"><a href="#附：使用Python的smtp标准库发送电子邮件" class="headerlink" title="附：使用Python的smtp标准库发送电子邮件"></a>附：使用Python的smtp标准库发送电子邮件</h2><p>顺便发一个python版的发电子邮件的代码，python由于自身具有smtp标准库，所以不像node那样需要依赖第三方包。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">from</span> email.utils <span class="keyword">import</span> formataddr</span><br><span class="line"></span><br><span class="line">sender = <span class="string">&#x27;xxxxx@qq.com&#x27;</span> <span class="comment"># 必填，发件人邮箱地址</span></span><br><span class="line">receiver = <span class="string">&#x27;xxxxxxx@qq.com&#x27;</span> <span class="comment"># 必填，收件人邮箱地址</span></span><br><span class="line">password = <span class="string">&#x27;xxxxx&#x27;</span> <span class="comment"># 必填，邮箱登录密码，有些邮箱可能smtp发件服务用的是独立的密码，对于qq邮箱而言需要生成授权码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mail</span>():</span><br><span class="line">    ret = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        msg = MIMEText(<span class="string">&quot;别忘了健康打卡！&quot;</span>, <span class="string">&#x27;plain&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>) <span class="comment"># 第一个字符串是邮件的正文内容</span></span><br><span class="line">        msg[<span class="string">&#x27;From&#x27;</span>] = formataddr([<span class="string">&#x27;Myself&#x27;</span>, sender]) <span class="comment"># 设置发件人名称，可以随便填</span></span><br><span class="line">        msg[<span class="string">&#x27;To&#x27;</span>] = formataddr([<span class="string">&#x27;Also Myself&#x27;</span>, receiver]) <span class="comment"># 设置收件人名称，可以随便填</span></span><br><span class="line">        msg[<span class="string">&#x27;Subject&#x27;</span>] = <span class="string">&#x27;健康打卡提醒&#x27;</span> <span class="comment"># 邮件标题</span></span><br><span class="line"></span><br><span class="line">        server = smtplib.SMTP_SSL(<span class="string">&#x27;smtp.qq.com&#x27;</span>, <span class="number">465</span>) <span class="comment"># 这是qq邮箱所用参数</span></span><br><span class="line">        server.login(sender, password)</span><br><span class="line">        server.sendmail(sender,[receiver],msg.as_string())</span><br><span class="line">        server.quit()</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        ret = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">ret = mail()</span><br><span class="line"><span class="keyword">if</span> ret:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;邮件发送成功&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;邮件发送失败&#x27;</span>)</span><br></pre></td></tr></table></figure><p>————————<strong>End</strong>🎉————————</p>]]></content>
      
      
      <categories>
          
          <category> Node.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
            <tag> Linux </tag>
            
            <tag> 发送电子邮件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为了在PTA上用JavaScript做题，如何利用 Node.js 进行输入输出？</title>
      <link href="/article/fb3ad4d9de42.html"/>
      <url>/article/fb3ad4d9de42.html</url>
      
        <content type="html"><![CDATA[<div class="note info mordern flat"><p>本文为我2021年10月11日在CSDN上发的第三篇文章，现在稍加改动并搬运到本站上来。</p><p>不过说来惭愧，当初这篇文章本来是后面打算接一些PTA乙级题目的js版题解的，但是。。刷了几道之后我发现太花时间了，没时间做，所以后来就没做过了。不过这篇在PTA做题的时候如何使用Node.js进行输入输出还是可以看的。</p></div><h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p>在PTA上做题需要进行读取输入以及输出的操作，而JavaScript本来是没有标准输入输出这种东西的，后来出现的Node.js使之变成了现实。尽管如此，现在网上也不太容易找到一篇专门讲解为了在PTA上用JavaScript做题，输入输出到底应该怎么做的教程，而这恰恰是很多用JavaScript刷PTA的新手的困惑之处。因此这篇文章就是来做这件事，详细讲解为了在PTA上用JavaScript做题，如何利用 Node.js 进行输入输出？</p><p>开始之前，假定读者使用的代码编写工具为vscode。因为<del>这是一款颜值高、体验好的轻量级代码编辑器</del> —— 因为用它来写JavaScript代码还是很方便的，可以配置单独运行JavaScript文件的环境（只要简简单单安装个node还有Code Runner插件就行了，node安装教程推荐<a href="https://blog.csdn.net/Small_Yogurt/article/details/104968169">这个</a>）。</p><p>同时建议用vscode运行js代码时放到“终端”一栏输出，因为在“输出”那一栏输出的话有时候会出现中文乱码的情况，而且没有终端输出体验好。</p><h2 id="如何输入"><a href="#如何输入" class="headerlink" title="如何输入"></a>如何输入</h2><h3 id="基本输入操作"><a href="#基本输入操作" class="headerlink" title="基本输入操作"></a>基本输入操作</h3><p>现在正式开始，先把Node.js读取输入的最好用的模板放出来：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> readline = <span class="built_in">require</span>(<span class="string">&#x27;readline&#x27;</span>); <span class="comment">//引入readline模块</span></span><br><span class="line"><span class="keyword">const</span> rl = readline.<span class="title function_">createInterface</span>(&#123;</span><br><span class="line"><span class="attr">input</span>: process.<span class="property">stdin</span>,</span><br><span class="line"><span class="attr">output</span>: process.<span class="property">stdout</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">rl.<span class="title function_">on</span>(<span class="string">&#x27;line&#x27;</span>, <span class="keyword">function</span>(<span class="params">line</span>)&#123;</span><br><span class="line"><span class="comment">//做题的主体代码</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>头两个const声明可以说是定式了，用的时候直接复制粘贴过去就行。</p><p>重点在于那个on方法。代码执行到on方法时程序将开始持续按行接受输入（控制台输入，放到PTA上就是接受它给出的输入用例）。注意它是按行接受输入，也就是说当它读取输入时碰到换行符（是敲回车产生的看不见的换行符，不是打出来看得见的\n）时就认为这一行输入结束了，然后将这一行输入以字符串的形式赋值给on方法的第二个参数——一个带有一个参数的函数表达式——的参数（这个函数表达式如果对js比较熟的话应该知道它叫回调函数？），也就是上面代码中的函数参数line，不是引号括起来的那个哦，那个是表示line事件。所以line变量就是最终读取的输入的字符串形式：<br><img src="https://img-blog.csdnimg.cn/ca90ded1cc764c8d8fd5f40f520868c4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXVtaW5nZ3VpY2Fp,size_16,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>on方法每接受一行输入（碰到换行符认为一行输入完毕时）就会暂停接受输入，转而去执行on方法的第二个参数——回调函数。</p><p>如果回调函数内部没有写<code>rl.close();</code>来结束接受输入的话就会接着处于接受输入的状态，再接受一行输入，就像上面那样执行完一遍回调函数后下一行仍然会出现等待输入的光标。然后接受一行输入完毕后再整个执行一遍回调函数，反复循环：</p><blockquote><p>如果对node比较熟的话应该知道on方法其实是用于注册事件监听器的方法，而这里的<code>rl.on(&#39;line&#39;, function&#123;&#125;)</code>其实是给rl变量注册了一个监听line事件的监听器，每当读取到换行符时即触发这个line事件，然后被监听器监听到，然后就会执行一遍该监听器所携带的回调函数。如果没有用rl.close()方法结束接收输入的话，监听器将持续监听line事件，一旦事件被触发就会执行一遍回调函数，所以会反复循环。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/4bf559495958427ea639b9b8dc5b219f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXVtaW5nZ3VpY2Fp,size_16,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>除非回调函数内部写了<code>rl.close();</code>，那样的话回调函数碰到这一行代码就会立即停止执行，同时也不会再接受新的输入，程序就结束了：<br><img src="https://img-blog.csdnimg.cn/def2b24bccaf46e4aa29171d05d4115f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXVtaW5nZ3VpY2Fp,size_16,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><blockquote><p>对了，回调函数中的这个参数line其实是任意命名的，就像其他任何函数参数一样，比如你把它命名成data、inputs什么的都可以。</p></blockquote><h3 id="何时使用rl-close-方法"><a href="#何时使用rl-close-方法" class="headerlink" title="何时使用rl.close()方法"></a>何时使用rl.close()方法</h3><p>关于on方法还有一点需要注意的。上面说做题的主体代码需要放在回调函数里面（除了变量声明部分可以放在外面，我也推荐将变量声明部分放在外面），那么放在外面行不行呢？不行！看下面的图：<br><img src="https://img-blog.csdnimg.cn/390be99faa49499ca5fb7d0272328a26.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXVtaW5nZ3VpY2Fp,size_17,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>发现了吗？所有放在on方法外面的代码，即使是放在on方法后面的代码都会先于on方法执行，on方法本身放到最后执行。在PTA中所有的主体代码都是基于输入进行操作的，还没有输入就执行了处理代码，这算什么呢？所以一定要将做题的主体代码放在回调函数里面，但同时我推荐将所有用到的变量的声明都放在外面，这样当我们遇到多行输入的情况、回调函数被反复执行时不会将某些变量反复声明或者初始化，从而出现bug。可以看一下我后面的题目的题解代码，变量声明都是放在on方法外面的。</p><blockquote><p>额，如果有了解js异步编程的话应该知道像on方法注册的事件监听器这种就是一种异步，这个监听器注册完就会被放在一边放着持续监听事件，然后程序会将其他非异步的代码放在一起先执行掉，异步代码比如事件监听器只有当事件触发时才会执行。这是个比较粗浅的解释，详细的可以自己有时间去了解一下异步编程。</p></blockquote><p>回归正题，何时使用<code>rl.close()</code>方法呢？Emm。。。其实不用也可以，虽然这样会让程序在所有代码执行完后仍然处于等待输入状态，但是对于PTA而言只要输入完了也都处理完了也都输出完了，那就可以评判结果了，所以说不用也可以，没有影响。但是作为强迫症的我是一定要想办法结束输入从而彻底结束整个程序的，而且这里可以顺便一提多行输入时要注意的点。办法也很简单：<strong>把<code>rl.close();</code>放到整个程序执行的过程里的最后一步，注意不是指回调函数里代码的最后一行</strong>！因为只要在程序执行过程中碰到了<code>rl.close();</code>,整个程序就结束了（on方法会放到最后执行），而在一些多行输入的过程中回调函数会被执行多次，如果直接把<code>rl.close();</code>放在回调函数里的最后一行，那么回调函数第一次执行完整个程序就结束了，根本没有去读取接下来几行的输入的机会，对吧？</p><p>当然很明显这种影响也只有在多行输入的时候才会有，如果只有一行输入的话<code>rl.close();</code>肯定是直接放在回调函数里的最后一行了。那么多行输入时将<code>rl.close();</code>放在哪里呢（当然是整个程序执行的过程里的最后一步！！！）？看下面的代码：<br><img src="https://img-blog.csdnimg.cn/f8baf2aeadf44a3fbf9e8d869f4c3169.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXVtaW5nZ3VpY2Fp,size_15,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>这里在on方法外（也必须在on方法外！）声明了一个lineNumber变量来存储输入行的行号（从0开始，当然你想从1开始也可以），假设我们知道这个程序只接受4行的输入（实际上在PTA做题时多数需要多行输入的题目都是事先知道需要接受多少行输入的），那么上图中的 if 语句和<code>lineNumber++;</code>配合起来就能标记当前是第几行输入，对于每一行应当做什么样的处理（很多题目需要对多行输入中的不同行做不同的处理，比如第一行作为数字处理，其他行作为字符串处理），以及如果到了最后一行时在 if 里放一个<code>rl.close();</code>就行了，这样才算是将其放在了整个程序的结束处。这样我们就能处理多行输入的情况了。</p><p>关于多行输入还有一个小技巧，就是我们在vscode上自己调试程序时如果在控制台手动一行一行输入的话是很麻烦的，即使是一行一行复制粘贴也是很麻烦的，我推荐在当前js文件的同级位置新建一个文本文件，将多行输入的内容放在里面，输入时可以直接将一整个多行的内容复制粘贴进控制台里，这样跟你一行一行输入进去的效果是一样的。</p><p>对了，最后再提一点：在vscode中断点调试js代码时，on方法内部的代码是无法调试的（可能是因为它是异步代码吧），调试到on方法时会直接跳过去。想要调试其内部代码的话就要把它们拎出来新建一个文件单独调试了。</p><p>关于用Node.js读取输入就讲这么多了，想要用得熟练就要在实战中慢慢练习了。</p><h3 id="Node-js获取输入微总结"><a href="#Node-js获取输入微总结" class="headerlink" title="Node.js获取输入微总结"></a>Node.js获取输入微总结</h3><blockquote><p>1.回调函数的参数（可命名为line、data等）就是输入的字符串形式。<br>2.每次只接受一行输入，一行输入完毕就会将回调函数整个执行一遍。<br>3.多行输入时需借助lineNumber变量来标记当前是第几行输入，便于对不同行进行不同的处理以及将<code>rl.close()</code>方法放在合适的位置。别忘了<code>lineNumber++</code>这行代码！<br>4.自己本地调试程序时快速多行输入的小技巧。</p></blockquote><h2 id="如何输出"><a href="#如何输出" class="headerlink" title="如何输出"></a>如何输出</h2><p>输出其实很简单，即<code>console.log();</code>。不过只会这个的话就会有点问题，因为PTA的输出格式是要求非常严格的，比如末尾不能有多余的空格、空行等等，否则就会报“格式错误”的错误。而<code>console.log();</code>的输出会在最后面自动加一个换行符，也就是说会让最后一行输出后面多一个空行。为了解决这个问题，如果想要输出不带换行符的输出（类似于C语言中的<code>printf </code>函数那样），可以用<code>process.stdout.write()</code>方法来替代<code>console.log()</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">process.<span class="property">stdout</span>.<span class="title function_">write</span>(<span class="string">&#x27;hello!&#x27;</span>);</span><br><span class="line">process.<span class="property">stdout</span>.<span class="title function_">write</span>(<span class="string">&#x27;hi!&#x27;</span>);</span><br><span class="line">process.<span class="property">stdout</span>.<span class="title function_">write</span>(<span class="string">&#x27;hey!&#x27;</span>);</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//hello!hi!hey!</span></span><br></pre></td></tr></table></figure><p>只要是用node运行的js代码都可以直接使用这个方法。</p><p>有一点要特别注意！就是这个<code>process.stdout.write()</code>方法的参数必须是字符串类型，不然会报错！如果你的代码报了像下面这样的错误：</p><p><img src="https://img-blog.csdnimg.cn/771b656ad7bc44eea81265cccdee2892.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXVtaW5nZ3VpY2Fp,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>就要认真检查一下你的<code>process.stdout.write()</code>方法的参数是不是有问题了。</p><p>好了，关于 Node.js 如何输入输出就到这里，剩下的就要靠大家自己去实战练习了。</p>]]></content>
      
      
      <categories>
          
          <category> Node.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Python的 you-get 库 + FFmpeg 工具下载B站视频</title>
      <link href="/article/28b1fd971f7a.html"/>
      <url>/article/28b1fd971f7a.html</url>
      
        <content type="html"><![CDATA[<div class="note info mordern flat"><p>本文为我2021年10月8日在CSDN上发的第二篇文章，现在稍加改动并搬运到本站上来。</p></div><p>电脑系统环境：Windows 10</p><h2 id="准备阶段（安装you-get和FFmpeg）"><a href="#准备阶段（安装you-get和FFmpeg）" class="headerlink" title="准备阶段（安装you-get和FFmpeg）"></a>准备阶段（安装you-get和FFmpeg）</h2><p>安装非常简单，出现问题可以在网上参考其他资料。</p><p>you-get：直接命令行<code>pip install you-get</code>即可。</p><p>FFmpeg：这个要去其官网下载，我在这里把链接贴出来：<a href="https://www.gyan.dev/ffmpeg/builds/#release-builds">FFmpeg Windows版下载链接</a></p><p>在relase-builds那一块的latest-release（最新版）或者previous-release（历史版本）中，找一个zip压缩包即可。7z压缩包或许也可，反正我下的是zip。</p><p>反正解压完之后文件夹里面是这样的就对了：<br><img src="https://img-blog.csdnimg.cn/3509d21aafed403d91d8458e125db2c1.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXVtaW5nZ3VpY2Fp,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>文件夹路径应该不一样，这个是我自己设置的，我喜欢搞成这样，看着舒服一点。。。</p><p>至此安装阶段结束。</p><h2 id="配置环境阶段"><a href="#配置环境阶段" class="headerlink" title="配置环境阶段"></a>配置环境阶段</h2><p>you-get没什么好配置的，主要是FFmpeg，我们在这一步把它的路径加到环境变量里面去就可以了。</p><p>添加环境变量的流程基本相同，这里再说明一下：</p><p>在“此电脑”上右击，点击属性，再找到高级系统设置，点进去，找环境变量，点进去：</p><p><img src="https://img-blog.csdnimg.cn/9334a5d08eb14664821108678e74cfb0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXVtaW5nZ3VpY2Fp,size_9,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/f7368405282b4192a72b0fb724480c4b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXVtaW5nZ3VpY2Fp,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="E:/MyProjects/blog/source/_posts/2022081502.assets/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXVtaW5nZ3VpY2Fp,size_16,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"><br>点进去用户变量中的Path：</p><p><img src="https://img-blog.csdnimg.cn/aa3611133aa04446bdf1d6aba69a95ca.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXVtaW5nZ3VpY2Fp,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>点击“新建”，新建一个环境变量，把自己的这个bin文件夹的路径复制粘贴进去就行了：<br><img src="https://img-blog.csdnimg.cn/025ba6b56b52406ea5438858fc87f117.png" alt="在这里插入图片描述"><br>至此配置完成，可以打开cmd命令行（不用多说了吧），然后输入<code>ffmpeg -version</code>，查看版本，若看到差不多是这样：<br><img src="https://img-blog.csdnimg.cn/57d9a192e38b4573b6a9fe7d5ae43b9b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXVtaW5nZ3VpY2Fp,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>就说明添加环境变量已经成功了。</p><p>至此配置阶段结束。</p><h2 id="开始下载B站视频"><a href="#开始下载B站视频" class="headerlink" title="开始下载B站视频"></a>开始下载B站视频</h2><p>大家下载you-get的时候可能已经知道了这个东西可以下载现在网上大多数主流视频网站的视频，但是为什么还要安装这个ffmpeg呢?下面会有说明。</p><p>首先随便打开一个B站视频，我选择了这个：<a href="https://www.bilibili.com/video/BV1JV411t7ow?p=1">中科大郑烇、杨坚全套《计算机网络（自顶向下方法 第7版，James F.Kurose，Keith W.Ross）》（P1 课程目标）</a></p><p>然后我们打开命令行，此处最好是新建一个你准备放置下载的视频的文件夹，然后将命令行的工作目录转到此文件夹，因为you-get视频默认下载位置就是命令行当前的工作目录。</p><p>如下：<br><img src="https://img-blog.csdnimg.cn/8194f31a223743dc82e6857165553234.png" alt="在这里插入图片描述"><br>然后就像上面那样输入<code>you-get -i [视频url地址]</code>，稍等片刻，等它的解析结果出来，差不多是这个样子的：<br><img src="https://img-blog.csdnimg.cn/b53109334f3e4218b8cb0a7ed68f22fd.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXVtaW5nZ3VpY2Fp,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>视频站点、视频名称、视频大小、清晰度等等都给我们列出来了。看到下面的两大部分没？DASH和DEFAULT，这两个部分里面都是可下载的视频格式，其中DASH中下载的是MP4的视频格式，DEFAULT中下载的是flv的视频格式。flv格式的视频无法直接播放，这时候就需要用我们刚刚安装的FFmpeg工具来转换格式了，这也是我们为什么要安装FFmpeg的原因之一。</p><p>将flv视频转换为MP4格式视频方法如下（不过我在使用的时候出了一点小问题）：<br><img src="https://img-blog.csdnimg.cn/2eeddb59c2944015941479f4b40823f2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXVtaW5nZ3VpY2Fp,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>DASH或者DEFAULT中每一项都给出了可下载视频的清晰度和下载命令（#download-with字段)，清晰度建议下载720P或者1080P的，下载命令只要把 [URL] 替换为实际视频的网址就行了。</p><p>建议使用DASH中的命令下载MP4格式视频，第一这样省去了我们手动转换格式的麻烦，尤其是我们在下载时可以在视频网址前面加上–playlist命令把这个视频所在的那一全套的视频都一次性下载下来（但是得当你解析视频信息完成后看到一条可以使用–playlist命令的提示之后才能这么做，一般能这么干的都是B站上的分P视频），如果下载flv格式视频一个个转换还是比较麻烦的（据说可以写C语言程序来自动转换，不过我不会，可参考其他资料)，第二，我在把用DEFAULT中命令下载下来的flv视频转换之后没有视频，只有音频，这个问题我也不知道是怎么回事，也还没有进行进一步研究，反正我觉得用DASH 中的指令下载比较好。</p><p>这里就要提到我们为什么要安装FFmpeg的原因之二了。如果视频大小比较大的话you-get会将它分成两部分下载——视频和音频，也就是说如果没有安装FFmpeg的话你把一个视频下载下来会发现有两个mp4文件，一个是视频（没有声音），一个是音频（没有图像），当然如果你就是想搞一个音视频分离的这也可以，但是正常情况下我们需要它们俩合二为一，也就是安装FFmpeg并配置完成之后you-get将视频的两部分下载下来之后会自动将它们俩合成一个视频（有声音有图像）：<br><img src="https://img-blog.csdnimg.cn/f2bcc5fb14274f439c57251a64ffefff.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXVtaW5nZ3VpY2Fp,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>就是这个Merging的过程。</p><p>这样我们就把B站的视频下载下来了。然后下载的同时you-get会在下载目录里生成一些xml文件，这些是可以删除的。可以直接删除，或者太多了不想手动删也可以用命令行指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del *.xml</span><br></pre></td></tr></table></figure><p>至此就完成了you-get + FFmpeg下载B站视频的任务了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用Python的you-get库结合FFmpeg来下载B站视频的方法总结起来如下：</p><ol><li>如果你已经准备好了you-get库和FFmpeg工具并配置好了FFmpeg的环境变量，你需要去复制一下你要下载的B站视频的网址，然后在你要保存视频的目录下进入命令行，输入<code>you-get -i 视频网址</code>来解析视频信息，看看有哪些清晰度可供下载；</li><li>解析完毕后你可以查看DEFAULT和DASH中的每一项，选择你满意的一个清晰度然后输入#download-with字段中介绍的命令来下载相应的视频，推荐使用DASH中的命令来下载mp4视频。不过要注意清晰度越大视频越大，下载时间可能就越长，网络不佳的时候尤其要注意；</li><li>下载完成后可以手动清除目录里的xml文件。</li></ol><p>可以看出主要步骤只有两步，即解析和下载。</p><p>当然，you-get还可以下载其他一些视频网站上面的视频（VIP视频什么的大概还是没戏吧），而FFmpeg的用处也绝不止上面提到的那样，它们的其他用途大家就自己去慢慢探索了。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> you-get库 </tag>
            
            <tag> FFmpeg </tag>
            
            <tag> 下载视频 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用urllib.robotparser模块解析某些网站的robots文件时本应返回True的结果却返回了False是怎么回事？</title>
      <link href="/article/87e42dc57f76.html"/>
      <url>/article/87e42dc57f76.html</url>
      
        <content type="html"><![CDATA[<div class="note info mordern flat"><p>本文为我2021年5月29日在CSDN上发的第一篇文章，现在稍加改动并搬运到本站上来。</p></div><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>用以下代码尝试分析简书网站的robots文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.robotparser <span class="keyword">import</span> RobotFileParser</span><br><span class="line">rp = RobotFileParser(<span class="string">&#x27;https://www.jianshu.com/robots.txt&#x27;</span>)</span><br><span class="line">rp.read()</span><br><span class="line"><span class="built_in">print</span>(rp.can_fetch(<span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;https://www.jianshu.com/mobile/campaign/day_by_day/join?from=home&#x27;</span>))</span><br></pre></td></tr></table></figure><p>通过观察简书的robots文件推断这里的代码返回结果应该是True，但实际执行时却返回了False。</p><h2 id="原因探索"><a href="#原因探索" class="headerlink" title="原因探索"></a>原因探索</h2><p>首先要了解can_fetch（）方法返回True或False的逻辑是什么样的。在Pycharm中查看can_fetch()方法的部分源码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">can_fetch</span>(<span class="params">self, useragent, url</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;using the parsed robots.txt decide if useragent can fetch url&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> self.disallow_all:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> self.allow_all:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>可见该方法会首先判断disallow_all属性的值，若为True就将返回False。而这个属性在RobotFileParser类中的默认值是False，也就是说在程序执行过程中它的值被修改为True了。而前面只有一个read（）方法可能修改了它的值，所以来看看read（）方法的源码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">read</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Reads the robots.txt URL and feeds it to the parser.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        f = urllib.request.urlopen(self.url)</span><br><span class="line">    <span class="keyword">except</span> urllib.error.HTTPError <span class="keyword">as</span> err:</span><br><span class="line">        <span class="keyword">if</span> err.code <span class="keyword">in</span> (<span class="number">401</span>, <span class="number">403</span>):</span><br><span class="line">            self.disallow_all = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> err.code &gt;= <span class="number">400</span> <span class="keyword">and</span> err.code &lt; <span class="number">500</span>:</span><br><span class="line">            self.allow_all = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        raw = f.read()</span><br><span class="line">        self.parse(raw.decode(<span class="string">&quot;utf-8&quot;</span>).splitlines())</span><br></pre></td></tr></table></figure><p>可以看到read（）方法的本质就是先用urlopen()方法打开上面传入给类的网址，如果这个过程中出现了401或403的HTTPError异常就把disallow_all属性修改为True。如果没有异常的话就会执行else语句块中的代码。</p><p>所以我们就直接用urlopen（）方法打开一下那个网址看会发生什么(下面代码默认已经导入了urllib库及相关模块)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(urllib.request.urlopen(<span class="string">&#x27;http://www.jianshu.com/robots.txt&#x27;</span>))</span><br></pre></td></tr></table></figure><p>返回是这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;input&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">&quot;D:\Program Files\Python\Python38\lib\urllib\request.py&quot;</span>, line <span class="number">222</span>, <span class="keyword">in</span> urlopen</span><br><span class="line">    <span class="keyword">return</span> opener.<span class="built_in">open</span>(url, data, timeout)</span><br><span class="line">  File <span class="string">&quot;D:\Program Files\Python\Python38\lib\urllib\request.py&quot;</span>, line <span class="number">531</span>, <span class="keyword">in</span> <span class="built_in">open</span></span><br><span class="line">    response = meth(req, response)</span><br><span class="line">  File <span class="string">&quot;D:\Program Files\Python\Python38\lib\urllib\request.py&quot;</span>, line <span class="number">640</span>, <span class="keyword">in</span> http_response</span><br><span class="line">    response = self.parent.error(</span><br><span class="line">  File <span class="string">&quot;D:\Program Files\Python\Python38\lib\urllib\request.py&quot;</span>, line <span class="number">563</span>, <span class="keyword">in</span> error</span><br><span class="line">    result = self._call_chain(*args)</span><br><span class="line">  File <span class="string">&quot;D:\Program Files\Python\Python38\lib\urllib\request.py&quot;</span>, line <span class="number">502</span>, <span class="keyword">in</span> _call_chain</span><br><span class="line">    result = func(*args)</span><br><span class="line">  File <span class="string">&quot;D:\Program Files\Python\Python38\lib\urllib\request.py&quot;</span>, line <span class="number">755</span>, <span class="keyword">in</span> http_error_302</span><br><span class="line">    <span class="keyword">return</span> self.parent.<span class="built_in">open</span>(new, timeout=req.timeout)</span><br><span class="line">  File <span class="string">&quot;D:\Program Files\Python\Python38\lib\urllib\request.py&quot;</span>, line <span class="number">531</span>, <span class="keyword">in</span> <span class="built_in">open</span></span><br><span class="line">    response = meth(req, response)</span><br><span class="line">  File <span class="string">&quot;D:\Program Files\Python\Python38\lib\urllib\request.py&quot;</span>, line <span class="number">640</span>, <span class="keyword">in</span> http_response</span><br><span class="line">    response = self.parent.error(</span><br><span class="line">  File <span class="string">&quot;D:\Program Files\Python\Python38\lib\urllib\request.py&quot;</span>, line <span class="number">569</span>, <span class="keyword">in</span> error</span><br><span class="line">    <span class="keyword">return</span> self._call_chain(*args)</span><br><span class="line">  File <span class="string">&quot;D:\Program Files\Python\Python38\lib\urllib\request.py&quot;</span>, line <span class="number">502</span>, <span class="keyword">in</span> _call_chain</span><br><span class="line">    result = func(*args)</span><br><span class="line">  File <span class="string">&quot;D:\Program Files\Python\Python38\lib\urllib\request.py&quot;</span>, line <span class="number">649</span>, <span class="keyword">in</span> http_error_default</span><br><span class="line">    <span class="keyword">raise</span> HTTPError(req.full_url, code, msg, hdrs, fp)</span><br><span class="line">urllib.error.HTTPError: HTTP Error <span class="number">403</span>: Forbidden</span><br></pre></td></tr></table></figure><p>看最后一行！发生了403错误。</p><p>至此就圆上了，那么为什么本该返回True的结果却返回了False就很清楚了。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>解决方法可能不止一种，我这里给出我思考后得出的方案。</p><p>要解决这个问题，首先要避免403错误的发生。</p><p>这里的403错误产生原因可能是发送请求时没有加上请求头信息，或者至少是没有加上User-Agent信息。所以如果我们发送请求时加入自己的User-Agent信息就好了。</p><p>如何利用浏览器获取自己的User-Agent信息请自行上网搜索，此处不再赘述。</p><p>但是这样有个问题，RobotFileParser类中没有哪个方法是可以让你发送加入User-Agent信息的请求的，有一个能发送请求的read（）方法，但没办法这么用。</p><p>但是，观察上面的read（）方法源码发现它其实就是urlopen()方法打开网址，然后如果不发生异常的话就用读取文件的那个python内置的read()方法读取结果，然后再调用这个类中的parse（）方法。所以can_fetch()方法的返回结果其实主要是依赖于parse()方法的解析结果的。</p><p>所以！思路就出来了~</p><p>我们直接手动编写代码代替原来直接调用read()方法的这一部分，即发送加入User-Agent信息的请求然后得到返回结果，然后直接把结果手动发送给parse（）方法，即调用RobotFileParser对象的parse方法，这样的话一切就能正常运行了。</p><p>所以最终方案如下：</p><p>（怎么加入User-Agent信息然后发送请求这个也可以自己去搜索，一般有build_opener()和add_header()两种思路，这里用第一个）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">from</span> urllib.robotparser <span class="keyword">import</span> RobotFileParser</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://jianshu.com/robots.txt&#x27;</span></span><br><span class="line">headers = (<span class="string">&#x27;User-Agent&#x27;</span>, <span class="keyword">pass</span>)  <span class="comment"># pass处是自己的User-Agent字符串</span></span><br><span class="line">opener = urllib.request.build_opener()</span><br><span class="line">opener.addheaders = [headers]</span><br><span class="line">data = opener.<span class="built_in">open</span>(url).read().decode(<span class="string">&#x27;utf-8&#x27;</span>).splitlines()  <span class="comment"># 参考read（）方法源码的最后一行</span></span><br><span class="line"></span><br><span class="line">rp = RobotFileParser(url)</span><br><span class="line">rp.parse(data)  <span class="comment"># 这里就代替了read()方法的最后一行的功能</span></span><br><span class="line"><span class="built_in">print</span>(rp.can_fetch(<span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;https://www.jianshu.com/mobile/campaign/day_by_day/join?from=home&#x27;</span>))</span><br></pre></td></tr></table></figure><p>运行一下，结果得到了True，搞定。</p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>建站记录系列（二）——正式建站</title>
      <link href="/article/2601d0bcdbb7.html"/>
      <url>/article/2601d0bcdbb7.html</url>
      
        <content type="html"><![CDATA[<p>买好服务器之后可以进入“云服务器ECS”控制台页面来查看自己服务器的情况以及对它进行各种操作。最重要的是，你现在可以知道你的服务器的公网ip地址。</p><h2 id="SSH登录服务器"><a href="#SSH登录服务器" class="headerlink" title="SSH登录服务器"></a>SSH登录服务器</h2><p>首先如果是win10的电脑的话，可以查看一下有没有自带的一个叫openssh的工具，可以在命令行输入命令<code>ssh -V</code>回车查看，有openssh的版本信息就是有该工具，可以直接登录了。如果没有，就自己下一个好了_(:з)∠) _，或者看一看有什么其他的比较中意的ssh工具，我这里用的就是我的win10电脑自带的openssh。</p><p>ssh连接服务器的命令：<code>ssh root@你的服务器公网IP</code>，root表示以root用户身份登录服务器，root用户是有最高权限的用户。</p><p>输入完该命令回车之后需要输入服务器密码，由于Linux系统中输入密码屏幕上不会有任何反应，所以不要以为出了什么bug，就安心把密码正确输入就行了，然后回车，就以root用户身份登录到服务器上了。</p><blockquote><p>ssh登录到服务器之后如果一段时间不操作就会断连无响应，这时只能等待它自动退出或者直接关闭命令行窗口再重新连接一下。</p></blockquote><h2 id="CentOS7系统安装nginx"><a href="#CentOS7系统安装nginx" class="headerlink" title="CentOS7系统安装nginx"></a>CentOS7系统安装nginx</h2><p>本文采用命令行操作方式进行nginx软件的安装。</p><h3 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h3><p>首先去<a href="https://nginx.org/en/download.html">nginx官网下载页面</a>下载“Stable version”中中间的那个文件：</p><p><img src="https://elzzach-src.oss-cn-hangzhou.aliyuncs.com/img/20220806/image-20220723163159459.png" alt="image-20220723163159459"></p><p>下载下来是一个带有<code>.tar.gz</code>后缀名的压缩文件。然后我们要把这个文件上传到服务器的文件夹中，我选择的是上传到&#x2F;opt&#x2F;tools文件夹中，tools文件夹是我新建的。</p><h3 id="上传到服务器"><a href="#上传到服务器" class="headerlink" title="上传到服务器"></a>上传到服务器</h3><p>上传有两种方式：下载WinSCP软件用可视化界面来传输文件以及管理服务器文件，这样比较方便。或者使用scp命令将该文件复制到相应的远程目录中。我选择的是使用winscp软件，软件的下载安装和使用方法都很容易解决。</p><h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><p>将nginx安装包上传到&#x2F;opt&#x2F;tools目录中后用cd命令进入该目录中，然后运行解压命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf nginx-1.22.0.tar.gz</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>这时该目录下就会出现一个叫nginx-1.22.0的目录，用cd命令进入该目录下，然后执行配置命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --with-http_stub_status_module --with-http_ssl_module</span><br></pre></td></tr></table></figure><p>这条命令后面两个参数是为了以后服务器安装ssl证书做准备的，不然只执行<code>./configure</code>命令的话之后安装ssl证书会提示缺少ssl模块，到时还要重新编译安装比较麻烦（没错就是我踩的坑），所以现在就安装好。</p><p>这条命令执行之后对云服务器来说一般不会有什么问题，但假如出现了一些报错则解决方案如下：</p><p>报错1：<code>error: the HTTP rewrite module requires the PCRE library.</code></p><p>解决方案：在当前工作目录下接着执行<code>yum -y install pcre-devel</code>命令安装所需依赖即可，然后将配置命令再执行一遍。</p><p>报错2：<code>error: SSL modules require the OpenSSL library.</code></p><p>解决方案：在当前工作目录下接着执行<code>yum -y install openssl openssl-devel</code>命令安装所需依赖即可，然后将配置命令再执行一遍。</p><p>其他报错的话自己将报错信息复制粘贴去搜索引擎搜索一下。</p><p>这两个报错是我在自己电脑上的VMware虚拟机的Linux系统里安装nginx时遇到的，当初在云服务器上安装nginx并没有碰到这两个问题，应该是服务器自带了这些依赖。</p><p>出现下图这种输出时就说明配置成功了：</p><p><img src="https://elzzach-src.oss-cn-hangzhou.aliyuncs.com/img/20220806/image-20220723180517257.png" alt="image-20220723180517257"></p><h3 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h3><p>配置成功之后依次执行以下两条命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>等待约二三十秒后安装完成，出现类似于下面的输出：</p><p><img src="https://elzzach-src.oss-cn-hangzhou.aliyuncs.com/img/20220806/image-20220723181008997.png" alt="image-20220723181008997"></p><p>这样的话我们的nginx就算安装好了，接下来我们需要启动它一下来验证安装成功以及配置环境变量。</p><h3 id="启动并访问80端口"><a href="#启动并访问80端口" class="headerlink" title="启动并访问80端口"></a>启动并访问80端口</h3><p><img src="https://elzzach-src.oss-cn-hangzhou.aliyuncs.com/img/20220806/image-20220723181410004.png" alt="image-20220723181410004"></p><p>在上面的输出中红框区域告诉了我们nginx被安装在了哪个目录下，即&#x2F;usr&#x2F;lcoal&#x2F;nginx&#x2F;是我们nginx的所在目录。或者也可以在命令行执行<code>whereis nginx</code>命令来查看。</p><p>以此为例，用cd命令进入&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin目录中，然后执行<code>./nginx</code>命令来启动nginx。</p><p>启动之后我们可以用浏览器访问<code>http://服务器公网ip</code>来看看是否出现了nginx的欢迎页面：</p><p><img src="https://elzzach-src.oss-cn-hangzhou.aliyuncs.com/img/20220806/image-20220723181822290.png" alt="image-20220723181822290"></p><p>出现了就说明启动成功。可能的情况是服务器80端口未开放或者被防火墙挡住了。一般来说阿里云服务器买来之后80端口默认是开放的，可以在<strong>服务器安全组配置</strong>中查看自己服务器的端口开放情况以及通过增减安全组规则来增加开放端口或关闭端口。</p><p>当安全组规则配置好后仍不能访问可能是服务器防火墙问题，可以用如下命令查看并解决：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看防火墙放开的端口</span></span><br><span class="line">firewall-cmd --zone=public --list-ports</span><br><span class="line"><span class="comment"># 放开指定端口</span></span><br><span class="line">firewall-cmd --zone=public --add-port=80/tcp --permanent</span><br><span class="line"><span class="comment"># 配置立即生效</span></span><br><span class="line">firewall-cmd --reload</span><br><span class="line"><span class="comment"># 关闭指定端口</span></span><br><span class="line">firewall-cmd --zone=public --remove-port=4000/tcp --permanent</span><br></pre></td></tr></table></figure><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打开环境变量配置文件</span></span><br><span class="line">vim /etc/profile</span><br><span class="line"><span class="comment"># 在文件末尾加入nginx的位置，即上面whereis命令告诉我们的位置</span></span><br><span class="line"><span class="built_in">export</span> NGINX_HOME=/usr/local/nginx</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$NGINX_HOME</span>/sbin</span><br><span class="line"><span class="comment"># 使配置生效</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br><span class="line"><span class="comment"># 校验配置是否成功，查看nginx版本</span></span><br><span class="line">nginx -v</span><br></pre></td></tr></table></figure><p>到此我们的nginx的安装就正式完成了。</p><h2 id="本地部署hexo"><a href="#本地部署hexo" class="headerlink" title="本地部署hexo"></a>本地部署hexo</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>本地部署hexo需要先安装nodejs包和git，安装方法请自行搜索。</p><p>Windows安装git可以看廖雪峰老师的教程所说的：</p><p><img src="https://elzzach-src.oss-cn-hangzhou.aliyuncs.com/img/20220806/image-20220730090839398.png" alt="image-20220730090839398"></p><h3 id="部署hexo"><a href="#部署hexo" class="headerlink" title="部署hexo"></a>部署hexo</h3><h4 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h4><p>如果nodejs环境变量已经配置好，那么直接进入命令行输入命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全局安装hexo-cli包</span></span><br><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><h4 id="初始化博客目录"><a href="#初始化博客目录" class="headerlink" title="初始化博客目录"></a>初始化博客目录</h4><p>为博客新建一个文件夹，例如<code>E:\\MyProjects\\blog</code>，下文将用“博客根目录”或“hexo根目录”称呼这个地址。</p><p>将命令行工作目录切到博客根目录下，输入命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><p>稍等片刻你的博客根目录下就会出现一些文件夹了，目录结构及每个文件夹、文件的作用请看<a href="https://hexo.io/zh-cn/docs/setup">官方文档</a>。</p><p>这时就可以在博客根目录下输入预览命令<code>hexo s</code>然后等待片刻访问它给你的本地地址就可以看到初始效果了。</p><h4 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h4><p>本站使用的是butterfly主题，主题官网：<a href="https://butterfly.js.org/">https://butterfly.js.org/</a></p><p>主题安装方法：<a href="https://butterfly.js.org/posts/21cfbf15/">https://butterfly.js.org/posts/21cfbf15/</a></p><p>实际上hexo主题的安装基本都是这样，在hexo根目录下用git clone命令将相应的主题仓库克隆过来即可，然后就会在themes文件夹里找到相应的主题文件夹了。</p><p>安装好之后记得打开hexo根目录下的hexo配置文件_config.yml找到其中的theme字段将其改成hexo-theme-butterfly以应用主题。其他的工作就需要参考主题文档了，例如对于butterfly主题而言还需要安装两个插件才能渲染出来。</p><p>所有工作完成以后在hexo根目录下执行<code>hexo s</code>预览命令即可看到主题默认效果。</p><blockquote><p>搭建博客过程中要勤看hexo文档和主题文档，认真研读，会发现很多的东西。</p></blockquote><h2 id="服务器部署hexo"><a href="#服务器部署hexo" class="headerlink" title="服务器部署hexo"></a>服务器部署hexo</h2><h3 id="本地配置ssh密钥"><a href="#本地配置ssh密钥" class="headerlink" title="本地配置ssh密钥"></a>本地配置ssh密钥</h3><p>以win10为例，如果用过Github并且进行过远程仓库的推送的话那么在用户目录底下应该有一个.ssh目录，以及目录下应该有一个id_rsa和id_rsa.pub文件。如果没有，在命令行里执行<code>ssh-keygen -t rsa -C &quot;邮箱地址&quot;</code>命令生成ssh密钥即可。</p><h3 id="服务器安装git"><a href="#服务器安装git" class="headerlink" title="服务器安装git"></a>服务器安装git</h3><p>登录服务器，直接执行<code>yum install git</code>命令即可。</p><h3 id="创建专门用于hexo推送的用户并设置权限"><a href="#创建专门用于hexo推送的用户并设置权限" class="headerlink" title="创建专门用于hexo推送的用户并设置权限"></a>创建专门用于hexo推送的用户并设置权限</h3><p>这一步的目的是创建一个专门用于hexo推送的用户并设置相关的权限，然后通过配置ssh密钥使本地电脑能够，所需要执行的命令总结如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先以root用户身份登录服务器</span></span><br><span class="line">adduser git <span class="comment"># 创建一个叫git的新用户</span></span><br><span class="line"><span class="built_in">chmod</span> 740 /etc/sudoers <span class="comment"># 设置权限使得git用户能够读写sudoers文件</span></span><br><span class="line">vim /etc/sudoers <span class="comment"># 用vim编辑器打开sudoers文件</span></span><br></pre></td></tr></table></figure><p>进入vim编辑器界面后先敲i键进入编辑模式将光标移到以下内容位置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">## Allow root to run any commands anywhere</span><br><span class="line">root    ALL=(ALL)     ALL</span><br></pre></td></tr></table></figure><p>在下面新建一行输入以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git     ALL=(ALL)     ALL</span><br></pre></td></tr></table></figure><p>即为git用户设置能够执行sudo命令的权限。</p><p>然后按esc键退出编辑模式，并依次输入:wq来保存并退出vim。</p><p>然后：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 400 /etc/sudoers <span class="comment"># 将git用户对该文件的权限设置为只读</span></span><br><span class="line">sudo passwd git <span class="comment"># 设置git账户的密码，Linux输入密码是不显示的，输入完直接回车就行</span></span><br><span class="line">su git <span class="comment"># 切换至git用户</span></span><br><span class="line"><span class="built_in">mkdir</span> /root/.ssh <span class="comment"># 在root目录下创建.ssh文件夹，当然创建之前可以先确认一下root目录下有没有该文件夹，可以用ls -a命令查看</span></span><br><span class="line">vim /root/.ssh/authorized_keys <span class="comment"># 用vim打开该文件，没有的会直接新建</span></span><br></pre></td></tr></table></figure><p>按i键进入编辑模式，然后在本地电脑上用记事本打开刚刚提到的id_rsa.pub文件，将其中的公钥内容复制到authorized_keys文件中（如果是用命令行登录服务器的话，粘贴是点击鼠标右键粘贴而不是ctrl+v，我不清楚这个是不是随不同品牌电脑而变化的），然后退出编辑模式并保存文件退出vim。</p><p>然后：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 600 /home/git/.ssh/authorized_keys <span class="comment"># 将这个文件权限设置为可读写</span></span><br><span class="line"><span class="built_in">chmod</span> 700 /home/git/.ssh <span class="comment"># 将这个目录权限设置为可进入、查看和修改</span></span><br></pre></td></tr></table></figure><p>这时候我们本地电脑应该就能免密登录git用户了，可以在本地执行命令<code>ssh git@服务器ip</code>看是不是不需要输入密码就能登录了。</p><blockquote><p>我是很顺利就成功了，如果碰到报错，请自行搜索并凭借自身的linux知识解决。。。</p></blockquote><blockquote><p>另外通过这一步我们可以看出对于hexo博客而言我们只能在我们部署的这台电脑上写文章推送，因为只有这台电脑上有相应的公钥和密钥，如果换了电脑，就要重新生成公钥和密钥并修改服务器上的authorized_keys文件或者将原来的公钥、密钥文件迁移到新电脑上。</p></blockquote><h3 id="仓库创建及相关配置"><a href="#仓库创建及相关配置" class="headerlink" title="仓库创建及相关配置"></a>仓库创建及相关配置</h3><p>在服务器上新建一个文件夹用作Git仓库的目录，例如&#x2F;var&#x2F;repo这个目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先将当前用户切换回到root用户</span></span><br><span class="line"><span class="built_in">mkdir</span> /var/repo</span><br></pre></td></tr></table></figure><p>然后：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chown</span> -R git:git /var/repo <span class="comment"># 将仓库目录的所有者设置为git用户</span></span><br><span class="line"><span class="built_in">chmod</span> -R 755 /var/repo <span class="comment"># 赋予对目录的进入、查看、修改权限</span></span><br></pre></td></tr></table></figure><p>再新建一个文件夹作为网站目录，例如&#x2F;var&#x2F;hexo这个目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /var/hexo</span><br><span class="line"><span class="built_in">chown</span> -R git:git /var/hexo</span><br><span class="line"><span class="built_in">chmod</span> -R 755 /var/hexo</span><br></pre></td></tr></table></figure><p>然后初始化git仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /var/repo</span><br><span class="line">git init --bare hexo.git</span><br></pre></td></tr></table></figure><p>创建Git钩子用于自动部署：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /var/repo/hexo.git/hooks/post-receive</span><br></pre></td></tr></table></figure><p>按i键然后输入以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">git --work-tree=/var/hexo --git-dir=/var/repo/hexo.git checkout -f</span><br></pre></td></tr></table></figure><p>然后修改所有者和权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chown</span> -R git:git /var/repo/hexo.git/hooks/post-receive</span><br><span class="line"><span class="built_in">chmod</span> +x /var/repo/hexo.git/hooks/post-receive</span><br></pre></td></tr></table></figure><p>这样就行了，然后修改一下本地hexo配置文件_config.yml，将deploy字段中的type字段值写为git，然后将repo字段值写为<code>git@服务器ip:/var/repo/hexo.git</code>，服务器ip可以等域名解析到服务器上后改为域名；branch字段值为master。</p><p>这样服务器上hexo的部署就基本成功了，可以在博客根目录执行<code>hexo clean</code>、<code>hexo g</code>、<code>hexo d</code>命令来看是否能够部署成功。</p><p>可能会出现权限相关的问题，多试几次或者自行查阅资料解决，因为我当初没碰到什么问题 :D。</p><h2 id="网站对外提供访问"><a href="#网站对外提供访问" class="headerlink" title="网站对外提供访问"></a>网站对外提供访问</h2><h3 id="Nginx添加站点"><a href="#Nginx添加站点" class="headerlink" title="Nginx添加站点"></a>Nginx添加站点</h3><p>这一步只需要修改nginx的配置文件即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure><p>找到第一个你看到的具有“listen 80”字段的server节点，修改其中的location字段里的root字段，将它默认的值改为你网站的真实根目录，比如&#x2F;var&#x2F;hexo。</p><p>然后我们需要重载一下配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/nginx/sbin/</span><br><span class="line">./nginx -s reload</span><br></pre></td></tr></table></figure><p>然后在本地博客根目录执行一下<code>hexo clean</code>、<code>hexo g</code>、<code>hexo d</code>三件套命令进行推送，推送完访问一下你的服务器ip地址看看是否出现了正常的hexo+butterfly主题的页面。</p><h3 id="域名DNS解析"><a href="#域名DNS解析" class="headerlink" title="域名DNS解析"></a>域名DNS解析</h3><p>这一步是在阿里云的云解析DNS控制台完成的。</p><p>首先进入阿里云云解析DNS控制台，然后点击一个叫“添加域名”的按钮，然后将你当初购买的二级域名填进去，按提示操作即可。</p><p>接下来如果你想直接使用该二级域名作为你博客的域名的话在它里面添加一个A类型记录即可，主机记录直接填写@，记录值填写服务器的ip地址，解析线路和TTL值都保持默认。如果你想像本站一样使用一个三级域名作为博客域名，那还需要再点击一下添加域名按钮，然后填写你想使用的三级域名，例如<code>blog.example.com</code>，注意这里它可能会提示你要添加子域需要先进行TXT授权校验，点击它的提示获得主机记录（一般是alidnscheck）、记录值等信息，然后在自己刚刚的二级域名底下添加一条TXT类型的记录即可，主机记录和记录值填写你刚刚获取的（即alidnscheck和一条长长的乱七八糟的字符串）。等TXT校验成功之后就可以添加三级域名了，然后在该三级域名底下添加一条A记录，记录值填服务器ip地址。主机记录填写时要注意填写的是@而不是blog，因为输入框后面给出来的是你的三级域名，你需要让你填写的主机记录和后面给出的域名连起来读是你所需要的三级域名，@表示直接解析后面的域名。这一点在以后添加主机记录时也要注意，即并不是页面提示你添加哪个主机记录你就直接照搬，视你所添加记录的域名而定。</p><p>等待片刻记录生效之后就可以访问域名看看是否正常显示网站了。</p><p>如果有什么问题的话，可以多参考阿里云官方文档。</p><h3 id="安装SSL证书"><a href="#安装SSL证书" class="headerlink" title="安装SSL证书"></a>安装SSL证书</h3><p>这个不用多说，看这个<a href="https://help.aliyun.com/document_detail/98728.htm">官方教程</a>就够了。</p><p>总结起来就是：首先在阿里云SSL证书控制台为自己的域名申请免费证书，然后下载nginx服务器用的证书到本地，解压后获得pem文件和key文件，然后在服务器上nginx安装目录中的conf目录下新建cert目录（即&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;cert），将刚刚下载的两个证书文件上传到这个cert目录中，然后打开nginx配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure><p>添加一个server节点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#以下属性中，以ssl开头的属性表示与证书配置有关。</span><br><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    #配置HTTPS的默认访问端口为443。</span><br><span class="line">    #如果未在此处配置HTTPS的默认访问端口，可能会造成Nginx无法启动。</span><br><span class="line">    #如果您使用Nginx 1.15.0及以上版本，请使用listen 443 ssl代替listen 443和ssl on。</span><br><span class="line">    server_name yourdomain; # 你的域名</span><br><span class="line">    root html;</span><br><span class="line">    index index.html index.htm;</span><br><span class="line">    ssl_certificate cert/cert-file-name.pem;  # pem文件名</span><br><span class="line">    ssl_certificate_key cert/cert-file-name.key; # key文件名</span><br><span class="line">    ssl_session_timeout 5m;</span><br><span class="line">    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line">    #表示使用的加密套件的类型。</span><br><span class="line">    ssl_protocols TLSv1.1 TLSv1.2 TLSv1.3; #表示使用的TLS协议的类型，您需要自行评估是否配置TLSv1.1协议。</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line">    location / &#123;</span><br><span class="line">        root html;  #Web网站程序存放目录，依本文的例子就是/var/hexo</span><br><span class="line">        index index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重载配置即可。</p><p>如果想要配置http请求强制跳转https，那就再添加一个server节点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name yourdomain; #需要将yourdomain替换成证书绑定的域名。</span><br><span class="line">    rewrite ^(.*)$ https://$host$1; #将所有HTTP请求通过rewrite指令重定向到HTTPS。</span><br><span class="line">    location / &#123;</span><br><span class="line">        index index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>到这里一个hexo+butterfly主题的博客网站就搭好了，现在可以自己去探索一下hexo的配置文件和butterfly的配置文件看一看如何搭配自己喜欢的功能，如果想要美化甚至魔改的话那就多参考大佬们的博客站以及发挥自己的创意咯。</p><blockquote><p>本文在hexo服务器部署部分参考了该文章：<a href="https://blog.laoda.de/archives/hexo-building.html">将Hexo部署到阿里云轻量服务器（保姆级教程）</a>，自己当初也是看着这篇文章建成的网站，这里把部分内容抄过来做一下笔记，感谢大佬</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 建站记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搭建hexo博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>建站记录系列（一）——前言及准备工作</title>
      <link href="/article/02c95d658b91.html"/>
      <url>/article/02c95d658b91.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本站建站过程实际起始于2021年11月下旬，1月15日使用wordpress框架搭好了一个雏形，<del>然后就一个寒假再也没管过</del>。到了2月下旬我开学的时候，我看到了hexo框架和它的butterfly主题，深为蝴蝶主题的外观感到惊艳，再加上自己是主修前端的，基于node.js的hexo框架自然是深得我心，所以果断将wordpress换成了hexo，主题当然使用的是butterfly。折腾了一段时间才搭建成功，然后后面的几个月我基本就有时间就来看看有什么可以魔改的地方，奈何本人想象力实在贫乏，看着小冰akilar一众大佬的博客乱秀但自己完全无从下手，改了几个月也才改成你们现在（2022年7月）看到的这个样子，。。。</p><p>总之，目前来说看着还凑合，然后就是五个月了，终于决定动手开始写博客了。_ (:з)∠) _</p><p>本文仅仅作为本人hexo建站过程的记录，并不是一份详细的新手向教程，但是可以作为hexo建站的一份参考资料。</p><p>另外由于实在是拖得太久（五个月），有些地方真的不是太想写了😶，所以可能写的有<strong>亿点点马虎</strong>，不过一些重难点都写清楚了，emm……假如有时间会再回来看看然后改改的。</p><blockquote><p>本文不涉及宝塔面板，一切采用Linux命令行操作。弃用宝塔面板是因为它的ssl证书功能在我这失效了，解决不了，结果手动命令行方式安装好了证书，干脆也不再需要宝塔面板了。</p></blockquote><p>建站原材料：</p><ol><li><strong>200多块钱</strong>：用于购买域名及服务器，因此本过程并非是一个免费的过程。想免费可以试试GitHub pages或者vercel等一些静态网页托管服务，比如本站的镜像站就是在Github pages上面。</li><li><strong>一些基础的前端及命令行知识&#x2F;bug定位能力和能折腾的耐心</strong>：搭建hexo博客还是挺折腾的，需要一些技术基础。如果中间没有认真看文档或者某些原因出了错误，最好是能靠自己的定位bug能力分析出来，如果没有那个能力，嗯。。。一言难尽了。你可以跑到主题群里问人，但如果是自己一些基础知识&#x2F;能力没有的话还是会很难受。</li></ol><h2 id="准备工作：域名、服务器、ICP备案"><a href="#准备工作：域名、服务器、ICP备案" class="headerlink" title="准备工作：域名、服务器、ICP备案"></a>准备工作：域名、服务器、ICP备案</h2><p>众所周知要想搭建一个网站我们需要一个服务器和域名，目前本站所使用的是阿里云的云服务器，域名也是从阿里云购买的。这里就不写什么域名、服务器购买教程了，只简单回忆一下步骤：</p><h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3><blockquote><p>该步骤用时：3~5天，经济消耗：9元（对我来说）</p></blockquote><p>先去阿里云官网注册一个账号，然后在<a href="https://wanwang.aliyun.com/">阿里云万网</a>上寻找域名，先想好自己想要一个什么样的域名，然后在万网的搜索框里搜索看有没有被别人注册过，如果没有，那就再根据价格等因素来选择一个自己喜欢的域名后缀，比如本站当初选择的域名就是elzzach.top，top域名还是很便宜的，首年只需9元（2021.11月价格），后面每年续费只需29元（每年都要续费一次哦），像什么com、cn这样的域名是比较贵的，都要好几十块钱来着。在购买域名确认订单的时候你可能会发现它提示你需要一个验证过邮箱的信息模板，你可以点击“创建新的信息模板”然后填写自己的一些相关信息，最重要的是你的邮箱要经过验证，验证完邮箱之后你的这个个人信息模板就可以用来确认订单了，接下来支付宝付款即可，这样一个域名就到手了。</p><blockquote><p>域名后缀不要选一些过于奇怪的后缀，比如汉字之类的，这样的域名多数在后面无法完成工信部ICP备案。</p></blockquote><p>到手了之后我们可以在阿里云官网上进入一个叫“域名控制台”的地方，在“域名列表”里我们可以看到自己刚刚购买的域名，然后我们会发现域名状态是“未实名认证”。点击这个未实名认证的链接，会跳转到实名认证界面，我们会发现有两种认证方式，一种是快速认证，即使用已经实名认证的信息模板来认证，但是我们是刚刚注册的账号，信息模板只验证了邮箱并没有实名认证，所以这种方式用不了，那就只能用第二种方法：普通认证。普通认证需要你上传你的身份证的人像面图片，请提前准备好，顺便准备一下身份证国徽面照片，并且将这两张照片保存一段时间，后面ICP备案时会用到。</p><p>实名认证大概需要三到五个工作日，我当初就是四天完成的，完成后会收到邮件通知。</p><h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><blockquote><p>该步骤用时：几分钟，经济消耗：约174元（假如我当初没加钱的话）</p></blockquote><p>域名实名认证是为了能够解析到服务器上，不然是不能解析的。现在实名认证完成了之后就可以着手准备服务器了。</p><p>服务器仍然是选择在阿里云购买。国内比较好的云服务器厂商有阿里云、腾讯云、百度云、华为云等等，我推荐优先考虑阿里和腾讯。</p><p>首先进入<a href="https://www.aliyun.com/product/ecs">阿里云官网的云服务器购买页面</a>，然后挑选自己心仪的服务器。我所购买的是ECS共享型n4服务器，1核2G1M带宽40G云盘的那种，并且由于是新用户有优惠，买三年只要174元（2021.12月价格），要知道如果不是新用户的话一年就已经需要上千的费用了😰。至于配置的话，我上面说的这个对于单纯的hexo博客网站而言已经足够了，尤其是存储空间是大大的溢出，因为一个hexo博客站初期文件夹大小都只有几M到几十M，完全是够的（猜猜是哪个冤种当初加了二十块钱买了50G的）。唯一可能不太够的就是1M的带宽是有些略小，假如有很多人来访问的话，但是一般而言并发数少的话是没问题的。</p><p>还有就是流量这块，阿里云像这种包年的套餐是相当于无限流量的，所以你不用担心什么网站被打了然后一个月下来流量账单爆炸，但是刚刚也说了带宽不大，假如真被打了虽然不用担心欠费，但是占你带宽让别人无法访问什么的还是可以的。</p><p>选择好了服务器之后点击立即购买，然后选一下服务器所在的地域，一般选一个离自己比较近的地方吧（），或者选一个自己喜欢的随便什么地方，另外再选择一下服务器的操作系统，一般对新手而言服务器会选择CentOS7的系统，如果你对Linux有比较深刻的理解的话就自己选自己的，我选择的是CentOS7.9。请不要选择CentOS8，因为这个版本很早之前已经停止维护了。其他的都保持默认配置即可。接下来就是确认订单并付款啦，这样一台云服务器也就到手了。</p><h3 id="ICP备案"><a href="#ICP备案" class="headerlink" title="ICP备案"></a>ICP备案</h3><blockquote><p>此步骤用时：3-10天，可能更长；经济消耗：0</p></blockquote><p>我没有将我ICP备案的过程进行录屏，然后现在时间有点久了，就只能回忆一下大概过程了。</p><p>ICP备案是任何国内网站都要完成的一道步骤，或者说是服务器在国内的网站，只有在工信部完成了ICP备案才能够对外提供访问，如果网站服务器在港澳台或国外是不需要ICP备案的。</p><p>首先你需要在阿里云官网上找一找ICP备案的相关规定，尤其是你所在地区的规定。如果有不清楚的地方可以询问阿里云客服，客服工作时间一般是早上八点（还是九点来着，而且我还忘了他们一周工作几天来着）到晚上六点，且中午十二点会休息一会。备案过程中遇到问题都可以去问备案方面的客服。</p><p>备案在阿里云官网上进行，但是建议下载阿里云手机app，提交资料会方便一点。一般来说个人网站备案都只需要填写提交服务器IP、一些身份证两面照片、自己手持身份证照片等等资料即可，按照备案过程中的要求来。备案时还需要你给你的网站起一个名字，记住网站名称不可以带有“博客”、“论坛”等字眼，否则申请会在阿里云初审阶段被退回。当你提交了你的备案材料之后记得一定要注意接听电话，阿里云客服工作时间随时会给你来电确认你的身份，就是问一些你的姓名、身份证号码、网站名称、网站用途之类这样的问题。像我当初是上午提交的备案申请，下午两点多就给我打电话来了，但当时我在上课没时间接，结果它就给我把备案申请退回来了，理由是按照提交的电话号码打电话无人接听，无法确认该号码是否属实。然后我下午四点多又提交了一遍，然后几十分钟后就又打电话来了。所以一定要注意接电话。</p><p>接完电话就说明通过了阿里云的初审，你的备案资料将会提交到管局进行审核，这时应该会有一条短信提醒你在工信部备案管理系统上完成短信核验，就是你用它发给你在备案信息中填写的手机号码的验证码去访问它进行核验，就算核验完成了。然后就是等待管局审核你的资料，时间一般在三到十个工作日左右，仍然要注意接听电话，因为我的是第四天它就给我打电话来了，但我没听到，然后它又等了四天才给我再打了一次电话，所以我的备案用时总共是八天。</p><p>这次接电话仍然是确认你的身份和网站信息之类的，之后就算是你的审核通过了，通过之后你应该会收到短信或者邮件的通知，然后登录阿里云账号，你可以看到你的备案网站里面给了你一个备案号，这就是你的ICP备案号了，你需要在搭好你的网站之后将备案号放在网站首页的最下方并链接到<a href="https://beian.miit.gov.cn/">工信部网站</a>，否则被查到的话会处以罚款的。这就是为什么你需要一点前端知识的原因😬。（但是对于hexo的butterfly主题来说即使不会前端也很简单）</p><p>到这里准备工作就结束了，接下来开始正式建站。</p>]]></content>
      
      
      <categories>
          
          <category> 建站记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搭建hexo博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
