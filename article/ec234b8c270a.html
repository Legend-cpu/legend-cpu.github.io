<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>JavaScript学习笔记3 | 暮紫天地</title><meta name="robots" content="noindex"><meta name="keywords" content="前端, 设计"><meta name="author" content="Elzzach"><meta name="copyright" content="Elzzach"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="变量、作用域与内存原始值与引用值动态属性保存原始值的变量是按值访问的，保存引用值的变量是按引用访问的。 原始值不能有属性，尽管尝试给原始值添加属性不会报错。 只有引用值可以动态添加后面可以使用的属性。 复制值在通过变量把一个原始值赋值到另一个变量时，原始值会被复制到新变量的位置，两个值完全互相独立，互不干扰，复制值是原值的副本。 在把引用值从一个变量赋给另一个变量时，存储在变量中的值也会被复制到新">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript学习笔记3">
<meta property="og:url" content="https://blog.elzzach.top/article/ec234b8c270a.html">
<meta property="og:site_name" content="暮紫天地">
<meta property="og:description" content="变量、作用域与内存原始值与引用值动态属性保存原始值的变量是按值访问的，保存引用值的变量是按引用访问的。 原始值不能有属性，尽管尝试给原始值添加属性不会报错。 只有引用值可以动态添加后面可以使用的属性。 复制值在通过变量把一个原始值赋值到另一个变量时，原始值会被复制到新变量的位置，两个值完全互相独立，互不干扰，复制值是原值的副本。 在把引用值从一个变量赋给另一个变量时，存储在变量中的值也会被复制到新">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.elzzach.top/rgba(0,%200,%200,%200)">
<meta property="article:published_time" content="2023-12-28T09:17:32.000Z">
<meta property="article:modified_time" content="2023-12-28T09:47:04.226Z">
<meta property="article:author" content="Elzzach">
<meta property="article:tag" content="前端, 设计">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.elzzach.top/rgba(0,%200,%200,%200)"><link rel="shortcut icon" href="https://blog.elzzach.top/global-img/favicon.webp"><link rel="canonical" href="https://blog.elzzach.top/article/ec234b8c270a.html"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://npm.elemecdn.com/@fortawesome/fontawesome-free@latest/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/node-snackbar@latest/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"https://npm.elemecdn.com/ezsttcfs@latest/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"距离本文上次更新已经过去了","messageNext":"天，文章中的内容有可能已经过时。如果过时，请联系作者尝试更新为最新版。"},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":null},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#c449f5","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://npm.elemecdn.com/flickr-justified-gallery@latest/dist/fjGallery.min.js',
      css: 'https://npm.elemecdn.com/flickr-justified-gallery@latest/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JavaScript学习笔记3',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-12-28 17:47:04'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" /><meta http-equiv="Cache" content="no-cache"><meta http-equiv="Pragma" content="no-cache" /><meta http-equiv="Expires" content="0" /><link rel="stylesheet" href="/ext/ez.css"><meta name="generator" content="Hexo 6.0.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.elzzach.top/global-img/avatar.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">16</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">35</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo/"><i class="fa-fw fas fa-ellipsis"></i><span> 碎碎念</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img nav-fixed nav-visible" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">暮紫天地</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo/"><i class="fa-fw fas fa-ellipsis"></i><span> 碎碎念</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">JavaScript学习笔记3</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-12-28T09:17:32.000Z" title="发表于 2023-12-28 17:17:32">2023-12-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-12-28T09:47:04.226Z" title="更新于 2023-12-28 17:47:04">2023-12-28</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">37.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>130分钟</span></span></div></div></div><article class="post-content" id="article-container"><h2 id="变量、作用域与内存"><a href="#变量、作用域与内存" class="headerlink" title="变量、作用域与内存"></a>变量、作用域与内存</h2><h3 id="原始值与引用值"><a href="#原始值与引用值" class="headerlink" title="原始值与引用值"></a>原始值与引用值</h3><h4 id="动态属性"><a href="#动态属性" class="headerlink" title="动态属性"></a>动态属性</h4><p>保存原始值的变量是<strong>按值</strong>访问的，保存引用值的变量是<strong>按引用</strong>访问的。</p>
<p><strong>原始值不能有属性</strong>，尽管尝试给原始值添加属性不会报错。</p>
<p><strong>只有引用值可以动态添加后面可以使用的属性。</strong></p>
<h4 id="复制值"><a href="#复制值" class="headerlink" title="复制值"></a>复制值</h4><p>在通过变量把一个原始值赋值到另一个变量时，原始值会被复制到新变量的位置，<strong>两个值完全互相独立，互不干扰</strong>，复制值是原值的副本。</p>
<p>在把引用值从一个变量赋给另一个变量时，存储在变量中的值也会被复制到新变量所在的位置。区别在于，<strong>这里复制的值实际上是一个指针</strong>，它指向存储在堆内存中的对象。操作完成后，两个变量实际上指向同一个对象，因此<strong>一个对象上面的变化会在另一个对象上反映出来</strong>。</p>
<h4 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h4><p>ECMAScript 中所有函数的参数都是<strong>按值传递</strong>的，没有按引用传递。这意味着<strong>函数外的值会被复制到函数内部的参数</strong>中，就像从一个变量复制到另一个变量一样。如果是原始值，那么就跟原始值变量的复制一样，如果是引用值，那么就跟引用值变量的复制一样。</p>
<blockquote>
<p>上一节说到在把引用值从一个变量赋给另一个变量时，存储在变量中的值也会被复制到新变量所在的位置。区别在于，<strong>这里复制的值实际上是一个指针</strong></p>
</blockquote>
<p>当传入原始值时，原始值的值被复制到函数的参数——一个局部变量中，与全局变量互相独立互不干扰；当传入引用值时，对值的引用被复制到函数参数中，这时函数参数和传入的引用都指向内存中的同一个对象，因此此时函数内部对局部变量的修改（按引用访问值）会反映到全局变量上，但这不能说明这是按引用传参的，仍然是按值传参。若将函数参数的引用改指向内存中另一个引用值，它与全局变量就会互相独立互不干扰了。</p>
<p><strong>局部变量在函数执行完毕后就会销毁</strong>。</p>
<h4 id="确定类型"><a href="#确定类型" class="headerlink" title="确定类型"></a>确定类型</h4><p><strong><code>typeof</code> 操作符最适合用来判断一个变量是否为原始类型</strong>。更确切地说，它是判断一个变量是否为字符串、数值、布尔值或 undefined 的最好方式。如果值是对象或 null，那么<code>typeof</code>返回”object”。它对引用值的用处不大。</p>
<p>我们通常不关心一个值是不是对象， 而是想知道它是什么类型的对象。为了解决这个问题，ECMAScript 提供了 <strong><code>instanceof</code> 操作符</strong>，语法如下： <code>result = variable instanceof constructor</code> 如果变量是给定引用类型（由其原型链决定）的实例，则 <code>instanceof</code> 操作符返回 true。</p>
<p>按照定义，所有引用值都是 Object 的实例，因此通过 <code>instanceof</code> 操作符检测任何引用值和 Object 构造函数都会返回 true。</p>
<blockquote>
<p>typeof 操作符在用于检测函数时也会返回”function”。当在 Safari（直到 Safari 5） 和 Chrome（直到 Chrome 7）中用于检测正则表达式时，由于实现细节的原因，typeof 也会返回”function”。ECMA-262 规定，任何实现内部[[Call]]方法的对象都应该在 typeof 检测时返回”function”。因为上述浏览器中的正则表达式实现了这个方法，所 以 typeof 对正则表达式也返回”function”。在 IE 和 Firefox 中，typeof 对正则表达式返回”object”。</p>
</blockquote>
<h3 id="执行上下文与作用域"><a href="#执行上下文与作用域" class="headerlink" title="执行上下文与作用域"></a>执行上下文与作用域</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><strong>执行上下文</strong>（以下简称“上下文”）的概念在JavaScript中是颇为重要的。变量或函数的上下文决定了它们可以访问哪些数据，以及它们的行为。</p>
<p><strong>变量对象</strong>：每个上下文都有一个关联的变量对象（variable object），而这个上下文中定义的所有变量和函数都存在于这个对象上。虽然无法通过代码访问变量对象，但后台处理数据会用到它。</p>
<p><strong>全局上下文：</strong>全局上下文是最外层的上下文。根据ECMAScript实现的宿主环境，表示全局上下文的对象可能不一样。<strong>在浏览器中，全局上下文就是我们常说的window对象。因此所有通过var定义的全局变量和函数都会成为window对象的属性和方法</strong>，使用<code>let</code>和<code>const</code>的顶级声明不会定义在全局上下文中（即使是在全局中定义的也不会），但在作用域链解析上效果是一样的。<strong>上下文在其所有代码都执行完毕后会被销毁</strong>，包括定义在它上面的所有变量和函数（全局上下文在应用程序退出前才会被销毁，比如关闭网页或退出浏览器）。</p>
<p><strong>函数上下文和上下文栈：</strong>每个函数调用都有自己的上下文。当代码执行流进入函数时，函数的上下文被推到一个上下文栈上。在函数执行完之后，上下文栈会弹出该函数上下文，将控制权返还给之前的执行上下文。ECMAScript程序的执行流就是通过这个上下文栈进行控制的。</p>
<p><strong>作用域链：</strong>上下文中的代码在执行的时候，会创建变量对象的一个作用域链（scope chain）。这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。<strong>代码正在执行的上下文的变量对象始终位于作用域链的最前端。</strong>如果上下文是函数，则其活动对象（activation object）用作变量对象。活动对象最初只有一个定义变量：arguments（全局上下文中没有这个变量）。</p>
<p><strong>作用域链顺序：</strong>作用域链中的下一个变量对象来自包含上下文，再下一个对象来自再下一个包含上下文。以此类推直至全局上下文；<strong>全局上下文的变量对象始终是作用域链的最后一个变量对象。</strong></p>
<p><strong>作用域链解析：</strong>代码执行时的标识符解析是通过沿作用域链逐级搜索标识符名称完成的。搜索过程始终从作用域链的最前端开始，然后逐级往后，直到找到标识符。（如果没有找到标识符，那么通常会报错。）</p>
<p><strong>上下文之间的连接：</strong>内部上下文可以通过作用域链访问外部上下文中的一切，但外部上下文无法访问内部上下文中的任何东西。上下文之间的连接是线性的、有序的。<strong>每个上下文都可以到上一级上下文中去搜索变量和函数，但任何上下文都不能到下一级上下文中去搜索。</strong></p>
<p><strong>注意函数参数被认为是当前上下文中的变量</strong>，因此也跟上下文中的其他变量遵循相同的访问规则。</p>
<h4 id="作用域链增强"><a href="#作用域链增强" class="headerlink" title="作用域链增强"></a>作用域链增强</h4><p>虽然执行上下文主要有全局上下文和函数上下文两种（<code>eval()</code>调用内部存在第三种上下文），但有其他方式来增强作用域链。某些语句会导致在作用域链前端临时添加一个上下文，这个上下文在代码执行后会被删除。通常在两种情况下会出现这个现象，即代码执行到下面任意一种情况时：</p>
<ul>
<li><code>try/catch</code>语句的<code>catch</code>块</li>
<li><code>with</code>语句</li>
</ul>
<p>这两种情况下，都会在作用域链前端添加一个变量对象。对<code>with</code>语句来说，会向作用域链前端添加指定的对象；对<code>catch</code>语句而言，则会创建一个新的变量对象，这个变量对象会包含要抛出的错误对象的声明。</p>
<h4 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h4><h5 id="1-使用var的函数作用域声明"><a href="#1-使用var的函数作用域声明" class="headerlink" title="1.使用var的函数作用域声明"></a>1.使用var的函数作用域声明</h5><p><strong>在使用var声明变量时，变量会被自动添加到最接近的上下文。在函数中，最接近的上下文就是函数的局部上下文。在with语句中，最接近的上下文也是函数上下文。如果变量未经声明就被初始化了，那么它就会自动被添加到全局上下文。</strong></p>
<p>注意未经声明而初始化变量是JavaScript编程中一个非常常见的错误，会导致很多问题。为此，读者在初始化变量之前一定要先声明变量。在严格模式下，未经声明就初始化变量会报错。</p>
<p>var声明会被拿到函数或全局作用域的顶部，位于作用域中所有代码之前。这个现象叫作“提升”（hoisting）。提升让同一作用域中的代码不必考虑变量是否已经声明就可以直接使用。</p>
<h5 id="2-使用let的块级作用域声明"><a href="#2-使用let的块级作用域声明" class="headerlink" title="2.使用let的块级作用域声明"></a>2.使用let的块级作用域声明</h5><p>ES6新增的<code>let</code>关键字跟<code>var</code>很相似，但它的作用域是块级的，这也是JavaScript中的新概念。<strong>块级作用域由最近的一对包含花括号{}界定</strong>。换句话说，<code>if</code>块、<code>while</code>块、<code>function</code>块，甚至连单独的块（就是单独的一个大括号里的内容，有点像但不是对象字面量）也是let声明变量的作用域。</p>
<p><code>let</code>与<code>var</code>的另一个不同之处是在同一作用域内不能声明两次。重复的<code>var</code>声明会被忽略，而重复的<code>let</code>声明会抛出<code>SyntaxError</code>。</p>
<p><code>let</code>的行为非常适合在循环中声明迭代变量。使用<code>var</code>声明的迭代变量会泄漏到循环外部，这种情况应该避免。</p>
<p>严格来讲，<code>let</code>在JavaScript运行时中也会被提升，但由于“暂时性死区”（temporal deadzone）的缘故，实际上不能在声明之前使用<code>let</code>变量。因此，从写JavaScript代码的角度说，<code>let</code>的提升跟<code>var</code>是不一样的。</p>
<h5 id="3-使用const的常量声明"><a href="#3-使用const的常量声明" class="headerlink" title="3.使用const的常量声明"></a>3.使用const的常量声明</h5><p>除了<code>let</code>，ES6同时还增加了<code>const</code>关键字。使用<code>const</code>声明的变量必须同时初始化为某个值。一经声明，在其生命周期的任何时候都不能再重新赋予新值。</p>
<p><code>const</code>除了要遵循以上规则，其他方面与<code>let</code>声明是一样的。</p>
<p><code>const</code>声明只应用到顶级原语或者对象。换句话说，赋值为对象的<code>const</code>变量不能再被重新赋值为其他引用值<strong>，但对象的键则不受限制</strong>。如果想让整个对象都不能修改，可以使用<code>Object.freeze()</code>，这样再给属性赋值时虽然不会报错，但会静默失败。</p>
<p>由于<code>const</code>声明暗示变量的值是单一类型且不可修改，JavaScript运行时编译器可以将其所有实例都替换成实际的值，而不会通过查询表进行变量查找。谷歌的V8引擎就执行这种优化。</p>
<p>注意：开发实践表明，如果开发流程并不会因此而受很大影响，就<strong>应该尽可能地多使用<code>const</code>声明</strong>，除非确实需要一个将来会重新赋值的变量。这样可以从根本上保证提前发现重新赋值导致的bug。</p>
<h5 id="4-标识符查找"><a href="#4-标识符查找" class="headerlink" title="4.标识符查找"></a>4.标识符查找</h5><p>当在特定上下文中为读取或写入而引用一个标识符时，必须通过搜索确定这个标识符表示什么。搜索开始于作用域链前端，以给定的名称搜索对应的标识符。如果在局部上下文中找到该标识符，则搜索停止，变量确定；如果没有找到变量名，则继续沿作用域链搜索。（注意，作用域链中的对象也有一个原型链，因此搜索可能涉及每个对象的原型链。）这个过程一直持续到搜索至全局上下文的变量对象。如果仍然没有找到标识符，则说明其未声明。</p>
<blockquote>
<p>标识符查找并非没有代价。访问局部变量比访问全局变量要快，因为不用切换作用域。不过，JavaScript 引擎在优化标识符查找上做了很多工作，将来这个差异可能就微不足道了。</p>
</blockquote>
<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><h5 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h5><p>JavaScript是使用垃圾回收的语言，也就是说执行环境负责在代码执行时管理内存。</p>
<p>JavaScript通过自动内存管理实现内存分配和闲置资源回收。基本思路很简单：确定哪个变量不会再使用，然后释放它占用的内存。</p>
<p><strong>这个过程是周期性的，即垃圾回收程序每隔一定时间（或者说在代码执行过程中某个预定的收集时间）就会自动运行。</strong></p>
<p>垃圾回收过程是一个近似且不完美的方案，因为某块内存是否还有用，属于“不可判定的”问题，意味着靠算法是解决不了的。垃圾回收程序必须跟踪记录哪个变量还会使用，以及哪个变量不会再使用，以便回收内存。如何标记未使用的变量也许有不同的实现方式。不过，在浏览器的发展史上，用到过两种主要的标记策略：标记清理和引用计数。</p>
<h5 id="标记清理"><a href="#标记清理" class="headerlink" title="标记清理"></a>标记清理</h5><p>JavaScript最常用的垃圾回收策略是<strong>标记清理</strong>（mark-and-sweep）。标记过程的实现并不重要，关键是策略。垃圾回收程序运行的时候，会标记内存中存储的所有变量（记住，标记方法有很多种）。然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉。在此之后再被加上标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了。随后垃圾回收程序做一次内存清理，销毁带标记的所有值并收回它们的内存。到了2008年，IE、Firefox、Opera、Chrome和Safari都在自己的JavaScript实现中采用标记清理（或其变体），只是在运行垃圾回收的频率上有所差异。</p>
<h5 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h5><p>另一种没那么常用的垃圾回收策略是<strong>引用计数</strong>（reference counting）。其思路是对每个值都记录它被引用的次数。声明变量并给它赋一个引用值时，这个值的引用数为1。如果同一个值又被赋给另一个变量，那么引用数加1。类似地，如果保存对该值引用的变量被其他值给覆盖了，那么引用数减1。当一个值的引用数为0时，就说明没办法再访问到这个值了，因此可以安全地收回其内存了。垃圾回收程序下次运行的时候就会释放引用数为0的值的内存。</p>
<p>引用计数最早由Netscape Navigator3.0采用，但很快就遇到了严重的问题：<strong>循环引用</strong>。所谓循环引用，就是对象A有一个指针指向对象B，而对象B也引用了对象A。这会导致循环引用涉及到的变量的引用数永远不会为0，从而可能导致大量内存无法释放。</p>
<h5 id="内存管理（待二刷）"><a href="#内存管理（待二刷）" class="headerlink" title="内存管理（待二刷）"></a>内存管理（待二刷）</h5><p>将内存占用量保持在一个较小的值可以让页面性能更好。优化内存占用的最佳手段就是保证在执行代码时只保存必要的数据。<strong>如果数据不再必要，那么把它手动设置为 null，从而释放其引用</strong>。这也可以叫作<strong>解除引用</strong>。这个建议最适合<strong>全局变量和全局对象的属性</strong>。局部变量在超出作用域后会被自动解除引用。不过要注意，解除对一个值的引用并不会自动导致相关内存被回收。解除引用的关键在于确保相关的值已经不在上下文里了，因此它在下次垃圾回收时会被回收。</p>
<h6 id="1-通过let和const声明提升性能"><a href="#1-通过let和const声明提升性能" class="headerlink" title="1.通过let和const声明提升性能"></a>1.通过let和const声明提升性能</h6><p>因为 const 和 let 都以块（而非函数）为作用域，所以相比于使用 var，使用这两个新关键字可能会更早地让垃圾回收程序介入，尽早回收应该回收的内存。在块作用域比函数作用域更早终止的情况下，这就有可能发生。</p>
<h6 id="2-隐藏类和删除操作"><a href="#2-隐藏类和删除操作" class="headerlink" title="2.隐藏类和删除操作"></a>2.隐藏类和删除操作</h6><h6 id="3-内存泄漏"><a href="#3-内存泄漏" class="headerlink" title="3.内存泄漏"></a>3.内存泄漏</h6><h6 id="4-静态分配与对象池"><a href="#4-静态分配与对象池" class="headerlink" title="4.静态分配与对象池"></a>4.静态分配与对象池</h6><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><h4 id="基本属性和方法"><a href="#基本属性和方法" class="headerlink" title="基本属性和方法"></a>基本属性和方法</h4><p>首先介绍一些每个对象都具有的属性和方法：</p>
<h5 id="查看当前对象是哪个构造函数创建的"><a href="#查看当前对象是哪个构造函数创建的" class="headerlink" title="查看当前对象是哪个构造函数创建的"></a>查看当前对象是哪个构造函数创建的</h5><p>constructor: 用于创建当前对象的函数。</p>
<h5 id="判断当前对象实例-不是原型-上是否存在给定的属性"><a href="#判断当前对象实例-不是原型-上是否存在给定的属性" class="headerlink" title="判断当前对象实例(不是原型)上是否存在给定的属性"></a>判断当前对象实例(不是原型)上是否存在给定的属性</h5><p>hasOwnProperty(propertyName): 要检查的属性名必须是字符串(如o.hasOwnProperty ( “name”))或符号。</p>
<h5 id="判断当前对象是否为另一个对象的原型"><a href="#判断当前对象是否为另一个对象的原型" class="headerlink" title="判断当前对象是否为另一个对象的原型"></a>判断当前对象是否为另一个对象的原型</h5><p>isPrototypeOf(object):用于判断当前对象是否为另一个对象的原型。</p>
<h5 id="判断给定的属性是否可以使用for-in语句枚举"><a href="#判断给定的属性是否可以使用for-in语句枚举" class="headerlink" title="判断给定的属性是否可以使用for-in语句枚举"></a>判断给定的属性是否可以使用for-in语句枚举</h5><p>propertyIsEnumerable(propertyName): 与hasOwnProperty ()一样，属性名必须是字符串。</p>
<h5 id="返回对象的字符串表示"><a href="#返回对象的字符串表示" class="headerlink" title="返回对象的字符串表示"></a>返回对象的字符串表示</h5><p>toLocaleString ( ): 返回对象的字符串表示，该字符串反映对象所在的本地化执行环境。</p>
<p>toString ( ): 返回对象的字符串表示。</p>
<h5 id="返回对象对应的字符串、数值或布尔值表示"><a href="#返回对象对应的字符串、数值或布尔值表示" class="headerlink" title="返回对象对应的字符串、数值或布尔值表示"></a>返回对象对应的字符串、数值或布尔值表示</h5><p>valueOf( ): 返回对象对应的字符串、数值或布尔值表示。通常与toString()的返回值相同。</p>
<h4 id="对象的基本操作"><a href="#对象的基本操作" class="headerlink" title="对象的基本操作"></a>对象的基本操作</h4><p>存储属性：属性的键必须是字符串（引号可省略，其他类型如数字会被转换为字符串）或Symbol；值可以是任何类型。属性键不像变量名那般受到不能为保留字的限制，可以取’for’、’let’这样的属性键。</p>
<p>访问属性：点语法（不能有引号）；中括号语法（必须有引号）。还可以将属性键名字符串赋值给变量，用中括号语法通过该变量（不加引号）来访问属性，点语法不能这么操作。另外JavaScript中可以访问对象的任何属性，如果属性不存在也可以访问，得到的是undefined。</p>
<p>删除属性：<code>delete obj.prop</code>。</p>
<p>检查是否存在指定键的属性：<code>&#39;key&#39; in obj</code>。</p>
<p>遍历对象：<code>for(let key in obj)&#123;&#125;</code>for-in循环。</p>
<p><strong>题目：检查空对象</strong></p>
<p>写一个 <code>isEmpty(obj)</code> 函数，当对象没有属性的时候返回 <code>true</code>，否则返回 <code>false</code>。</p>
<p>记住JavaScript空对象与空对象是不相等的，所以不能通过比较对象是否与<code>&#123;&#125;</code>相等来判断。可以使用for-in循环，如果对象是没有属性的话代码执行就不会进入循环中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isEmpty</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="comment">// 如果进到循环里面，说明有属性。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="对象引用和复制"><a href="#对象引用和复制" class="headerlink" title="对象引用和复制"></a>对象引用和复制</h4><p>对象是一个引用值，可以认为是对象所在的内存地址。</p>
<p>记住，只有当两个变量引用同一对象时它们才相等，否则如果分别赋值了两个即使看起来一模一样的变量，也会由于内存地址不同而被判断为两个不相等的对象。</p>
<h5 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h5><p>如果想要完全复制一个对象（复制它的值而不仅仅只是引用），可以用for-in循环遍历对象，将其所有属性克隆到新创建的空对象中；或者使用扩展操作符，即<code>clone=&#123;...src&#125;</code>来拷贝属性；或者直接使用<code>Object.assign()</code>方法达到相同的效果。</p>
<p><code>Object.assign(dest, [src1, src2, ...])</code></p>
<p>dest是目标对象，src是克隆源对象，可以是一个或多个。这个方法将后面所有源对象的所有属性拷贝到dest目标对象当中，然后返回这个目标对象。如果被拷贝的属性已存在，那么会被覆盖掉。</p>
<h5 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h5><p>上面的方法都是浅拷贝，也就是说如果对象中有一个属性也是一个对象的话，那么浅拷贝将复制这个对象的引用而不是这个对象的值。如果要复制属性对象的值（深拷贝），可以使用递归实现一个拷贝循环，检查源对象中的每个属性，如果是一个对象那就也复制它的结构。或者使用现成的库也可以。</p>
<p>自己实现的一个简单的针对手动创建的对象的深拷贝：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">cloneObj</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> clone = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj[key] <span class="keyword">instanceof</span> <span class="title class_">Object</span>) &#123;</span><br><span class="line">            clone[key] = <span class="title function_">cloneObj</span>(obj[key]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            clone[key] = obj[key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="属性类型及其内部特性"><a href="#属性类型及其内部特性" class="headerlink" title="属性类型及其内部特性"></a>属性类型及其内部特性</h4><p>JavaScript中对象的属性分为两种类型：数据属性和访问器属性。每个属性根据其类型的不同，具有不同的内部特性，这些特性是无法直接访问的。</p>
<h5 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h5><p>数据属性保存一个数据值，它有四个内部特性：</p>
<ol>
<li>[[Configurable]]，表示属性是否可以通过 delete 删除并重新定义，是否可以修改它的特性，以及是否可以把它改为访问器属性。默认情况下，所有直接定义在对象上的属性的这个特性都是 true。</li>
<li>[[Enumerable]]：表示属性是否可以通过 for-in 循环返回。默认情况下，所有直接定义在对象上的属性的这个特性都是 true。</li>
<li>[[Writable]]：表示属性的值是否可以被修改。默认情况下，所有直接定义在对象上的属性的这个特性都是 true。</li>
<li>[[Value]]：包含属性实际的值。这就是前面提到的那个读取和写入属性值的位置，也就是说，当你获取这个属性的值时，实际上读取的是这个属性的[[Value]]特性的值，如果改变这个特性的值使其和你定义的值不同，获取的值就和你定义的不同。这个特性的默认值为 undefined。</li>
</ol>
<p>也就是说，给对象定义了一个属性之后，这个属性默认是可删除、可修改、可枚举的，且其[[Value]]特性值将被设置为属性值。</p>
<p>这些特性是不能直接访问的，如果要修改这些属性就要通过Object.defineProperty()方法。这个方法接收 3 个参数： 要给其添加属性的对象、属性的名称（要写字符串形式）和一个描述符对象（即一个包含前面那些特性中的一个或多个的对象）。最后一个参数，即描述符对象上的属性可以包含：configurable、enumerable、writable 和 value，跟相关特性的名称一一对应。根据要修改的特性，可以设置其中一个或多个值。</p>
<p>在调用 Object.defineProperty()时，configurable、enumerable 和 writable 的值如果不指定，则都默认为 false。</p>
<blockquote>
<p>注意，如果使用Object.defineProperty()方法将一个属性变成了不可配置的属性，就没办法再变成可配置的了。</p>
</blockquote>
<h5 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h5><p>访问器属性不包含数据值，而是包含一个获取函数（getter）和一个设置函数（setter），不过这两个函数不是必须的。但如果有的话，这两个函数的名字一定是叫做 get() 和 set() ，否则不会被认为是获取函数和设置函数。</p>
<p>在读取访问器属性时会调用获取函数来返回一个有效的值；在写入访问器属性时会调用设置函数来传入新的值。</p>
<p>访问器属性也有四个内部特性：</p>
<ol>
<li>[[Configurable]]和[[Enumerable]]和上面是一样的。</li>
<li>[[Get]]，获取函数，在读取属性时调用，默认值为undefined。</li>
<li>[[Set]]，设置函数，在写入属性时调用，默认值为undefined。</li>
</ol>
<p>访问器属性的特性同样可以通过Object.defineProperty()方法来修改，此处第三个参数的描述符对象中的[[Get]]和[[Set]]特性应该写成方法的形式。</p>
<p>访问器属性的用处：更好地控制数据，在读写数据时可以进行其他额外的操作；实现数据的私有化；以比函数更简洁的方式解耦。</p>
<h5 id="同时修改多个属性的内部特性"><a href="#同时修改多个属性的内部特性" class="headerlink" title="同时修改多个属性的内部特性"></a>同时修改多个属性的内部特性</h5><p>如果要同时修改多个属性的内部特性，可以使用更方便的Object.defineProperties()方法，该方法接收两个参数，第一个是要为之添加属性的对象，第二个是一个嵌套对象，该对象的属性名是要添加的属性的名字，属性值是该属性要设置的描述符对象。用法与Object.defineProperties()基本相同，只不过是同时定义了多个属性。</p>
<h5 id="读取属性的内部特性"><a href="#读取属性的内部特性" class="headerlink" title="读取属性的内部特性"></a>读取属性的内部特性</h5><p>使用 Object.getOwnPropertyDescriptor()方法可以取得指定属性的属性描述符。这个方法接收两个参数：属性所在的对象和要取得其描述符的属性名（字符串形式）。返回值是一个对象，即该属性的描述符对象。</p>
<p>ES2017新增了Object.getOwnPropertyDescriptors()方法，接收一个对象作为参数，返回一个对象，包含了参数对象上所有属性的描述符对象。</p>
<h4 id="Mixin模式（与多重继承和设计模式有关，学完类继承再来看）"><a href="#Mixin模式（与多重继承和设计模式有关，学完类继承再来看）" class="headerlink" title="Mixin模式（与多重继承和设计模式有关，学完类继承再来看）"></a>Mixin模式（与多重继承和设计模式有关，学完类继承再来看）</h4><h4 id="对象相等判定"><a href="#对象相等判定" class="headerlink" title="对象相等判定"></a>对象相等判定</h4><p>全等操作符 &#x3D;&#x3D;&#x3D; 会认为 +0 与 -0 相等，-0 与 0 相等，NaN与NaN不等（isNaN（）函数才能判定出正确结果）。为改善这类情况，ES6新增了Object.is()方法，接收要进行比较的两个参数，并返回比较结果的布尔值。通过它可以得出正确的判定结果。</p>
<h4 id="增强的对象语法"><a href="#增强的对象语法" class="headerlink" title="增强的对象语法"></a>增强的对象语法</h4><h5 id="属性值简写"><a href="#属性值简写" class="headerlink" title="属性值简写"></a>属性值简写</h5><p>将变量添加给对象做属性时经常会发现属性名和变量名是一样的，这时候就可以只写属性名且不需要写冒号。但如果找不到同名变量就会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name=<span class="string">&quot;matt&quot;</span>;</span><br><span class="line"><span class="comment">//传统的写法</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: name，</span><br><span class="line">    <span class="attr">age</span>:<span class="number">18</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//简写属性名</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">	name, <span class="comment">//前面必须要定义了这个变量，否则报错</span></span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="可计算属性"><a href="#可计算属性" class="headerlink" title="可计算属性"></a>可计算属性</h5><p>对象字面量中本来是不可以动态命名属性的，也就是直接把属性键给写成一个变量名（或者表达式），即动态属性名。有了可计算属性就可以在对象字面量中写出动态属性名了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fruit = <span class="title function_">prompt</span>(<span class="string">&quot;Which fruit to buy?&quot;</span>, <span class="string">&quot;apple&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bag = &#123;</span><br><span class="line">  [fruit]: <span class="number">5</span>, <span class="comment">// 属性名是从 fruit 变量中得到的</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( bag.<span class="property">apple</span> ); <span class="comment">// 5 如果 fruit=&quot;apple&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="简写方法名"><a href="#简写方法名" class="headerlink" title="简写方法名"></a>简写方法名</h5><p>原本定义方法的写法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line"> <span class="attr">sayName</span>: <span class="keyword">function</span>(<span class="params">name</span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`My name is <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>简写写法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line"> <span class="title function_">sayName</span>(<span class="params">name</span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`My name is <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>简写方法对获取函数和设置函数也可用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line"> <span class="attr">name_</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line"> <span class="keyword">get</span> <span class="title function_">name</span>() &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name_</span>;</span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="keyword">set</span> <span class="title function_">name</span>(<span class="params">name</span>) &#123;</span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">name_</span> = name;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;; <span class="comment">//get 和 set 是必须的前缀，name才是函数名</span></span><br></pre></td></tr></table></figure>

<p>简写方法名还可与可计算属性搭配使用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line"> [methodKey](name) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`My name is <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h4><h5 id="最朴素的方式"><a href="#最朴素的方式" class="headerlink" title="最朴素的方式"></a>最朴素的方式</h5><p>一个个创建对象并为其赋予属性和方法。</p>
<h5 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h5><p>一个个创建对象并赋值太麻烦啦，如果是要创建一群类似的对象就更麻烦啦，干脆写一个函数吧：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createPerson</span>(<span class="params">name, age, job</span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"> o.<span class="property">name</span> = name;</span><br><span class="line"> o.<span class="property">age</span> = age;</span><br><span class="line"> o.<span class="property">job</span> = job;</span><br><span class="line"> o.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = <span class="title function_">createPerson</span>(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>, <span class="string">&quot;Software Engineer&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>工厂模式解决了创建多个类似对象的问题，但是没有解决标识新创建的对象是什么类型的问题（都是Object类型）。</p>
<h5 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, job</span>)&#123;</span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">job</span> = job;</span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line"> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>, <span class="string">&quot;Software Engineer&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>构造函数模式与工厂模式的区别：</p>
<ol>
<li>没有显式创建对象；</li>
<li>属性和方法直接赋值给了this（因为没有显式创建对象，肯定不能直接赋给对象了）</li>
<li>没有return回一个对象。</li>
<li>按照惯例，构造函数名字首字母是大写的。</li>
<li>构造函数调用时要使用 new 操作符。</li>
</ol>
<p>使用new操作符调用构造函数时执行了如下操作：</p>
<ol>
<li>在内存中新建一个对象；</li>
<li>这个新对象的[[Prototype]]特性被赋值为构造函数的prototype属性；</li>
<li>构造函数内部的this指向这个新对象；</li>
<li>执行构造函数内部代码；</li>
<li>如果构造函数用return语句返回了一个对象，则返回该对象；否则返回刚刚创建的新对象。</li>
</ol>
<p>构造函数也可以写成相应的函数表达式的形式。</p>
<p>构造函数本质就是普通函数，任何函数只要使用new操作符调用了就是构造函数，否则就是普通函数。</p>
<p>构造函数的主要问题在于它定义的方法会在每个实例上都创建一遍，也就是每个实例都有自己的一个方法，当实例较多时就会占用大量内存。</p>
<h5 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h5><p>每个函数都有一个prototype属性，这个属性是一个包含了应该由特定引用类型的实例共享的属性和方法的对象，叫做<strong>原型对象</strong>，在这个对象上定义的方法和属性可以被对象实例共享，从而解决了构造函数模式的每个实例都有自己的方法从而占用内存的缺点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125; <span class="comment">//构造函数体中什么也没有</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">29</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">job</span> = <span class="string">&quot;Software Engineer&quot;</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">person1.<span class="title function_">sayName</span>(); <span class="comment">// &quot;Nicholas&quot; </span></span><br></pre></td></tr></table></figure>

<p>写成函数表达式的形式也可以。</p>
<p>原型模式之所以重要，不仅体现在自定义类型上，而且还因为它也是实现所有原生引用类型的模式。</p>
<h6 id="理解原型"><a href="#理解原型" class="headerlink" title="理解原型"></a>理解原型</h6><p>函数在被创建时就被赋予了一个prototype属性，而这个原型对象则会自动获得一个constructor属性，该属性指回相应的构造函数。所以<code>func.prototype.constructor</code>指向的就是<code>func</code>。</p>
<blockquote>
<p>注意，只有在浏览器控制台中打印prototype属性才会出现内容，node.js环境下打印出来是个空对象。</p>
</blockquote>
<p>当调用构造函数创建一个新的实例时，这个实例的内部的[[Prototype]]指针就会被赋值为构造函数的原型对象。一些浏览器在每个对象上暴露了一个__ proto __属性，通过这个属性可以访问对象的原型。关键在于理解原型模式中实例与构造函数直接没有直接关系，而与构造函数原型之间有。</p>
<blockquote>
<p>实例通过__ proto __属性链接到原型，实际上是通过[[Prototype]]特性来访问的；构造函数通过prototype属性链接到原型，而其原型对象的constructor属性又指回构造函数。</p>
</blockquote>
<p>对某个原型对象调用isPrototypeOf（）方法可以确定这个原型对象是否是参数对象的原型。</p>
<p>Object.getPrototypeOf（）方法可以获取参数对象内部的[[Prototype]]的值，即可以方便地取得一个对象的原型，这在通过原型实现继承时很重要。</p>
<p>要重写一个对象的原型继承关系可以使用Object.setPrototypeOf（）方法可以向[[Prototype]]特性写入一个新值，但这个方法可能会严重影响性能。解决方法：用Object.create（）方法，该方法接收一个对象作为参数，这个对象是其原型要被继承的对象。这个方法会创建一个以参数对象的原型为原型的对象并返回，将其赋给一个变量，这就改写了对象的原型继承关系。</p>
<h6 id="原型层级"><a href="#原型层级" class="headerlink" title="原型层级"></a>原型层级</h6><p>在通过对象访问属性时，会按照这个属性的名称开始搜索。搜索开始于对象实例本身。如果在这个实例上发现了给定的名称，则返回该名称对应的值。如果没有找到这个属性，则搜索会沿着指针进入原型对象，然后在原型对象上找到属性后，再返回对应的值。这就是原型用于在多个对象实例间共享属性和方法的原理。</p>
<p>通过实例只能读取原型对象上的值，不能重写它们。如果在实例上添加了一个与原型对象中同名的属性，那就会在实例上创建这个属性，这个属性就会遮蔽（shadow）原型对象上的同名属性，也就是虽然不会修改它，但会屏蔽对它的访问。即使在实例上把这个属性设置为 null，也不会恢复它和原型的联系。不过，使用 delete 操作符可以完全删除实例上的这个属性，从而让标识符解析过程能够继续搜索原型对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> obj.<span class="property">prop</span>;</span><br></pre></td></tr></table></figure>

<p>可以用hasOwnProperty()方法确定某个属性是在实例上还是在原型上，该方法接收一个属性名字符串作为参数。当属性存在于调用它的对象上时返回true，如果在原型上就会返回false。</p>
<h6 id="其他原型语法"><a href="#其他原型语法" class="headerlink" title="其他原型语法"></a>其他原型语法</h6><p>前面的原型写法每次定义一个属性和方法时都要重写一遍“Person.prototype”，十分麻烦。更简单、封装性更好的写法是直接将一个对象字面量赋值给原型：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line"> <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line"> <span class="attr">age</span>: <span class="number">29</span>,</span><br><span class="line"> <span class="attr">job</span>: <span class="string">&quot;Software Engineer&quot;</span>,</span><br><span class="line"> <span class="title function_">sayName</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样写只有一个问题：完全重写默认的原型对象会导致原型对象的constructor属性将不再指向Person而是指向了Object，那我们就不能使用constructor来识别类型了。解决方法：在重写默认原型对象时手动给它添加一个constructor属性并使其指向相应的构造函数。</p>
<p>但是这样的解决方法还有一个问题：手动添加的这个constructor属性的[[Enumerable]]特性为true，而其默认值应该为false。所以可以改为使用Object.defineProperty()方法来为原型对象添加constructor属性，同时将其[[Enumerable]]特性设置为false，还有[[Value]]特性值设置为相应构造函数名称。</p>
<h6 id="原型的动态性"><a href="#原型的动态性" class="headerlink" title="原型的动态性"></a>原型的动态性</h6><p>原型的动态性是指在原型上所做的修改会在与它有联系的所有实例上反映出来，无论这个实例存在于修改原型之前还是之后，因为实例通过指针时时刻刻链接到原型，访问实例对象上的属性需要进行查找，而查找就会通过指针查找到被修改后的原型上。只有一种情况除外，那就是上面提到的完全重写整个原型。</p>
<p>完全重写原型会切断最初的原型（被重写之前的原型）与构造函数的关系，即构造函数将链接到重写后的新原型，但在重写原型之前创建的实例仍然引用的是最初的原型，因为实例的[[Prototype]]指针即使重写原型也不会改变。所以这时就很有可能导致错误。</p>
<p>当然如果重写原型之前没有创建任何实例的话那也没什么问题。</p>
<h6 id="原型模式存在的问题"><a href="#原型模式存在的问题" class="headerlink" title="原型模式存在的问题"></a>原型模式存在的问题</h6><p>原型模式也不是没有问题。</p>
<p>首先，它弱化了向构造函数传递初始化参数的能力，会导致所有实例默认都取得相同的属性值。虽然这会带来不便，但还不是原型的最大问题。</p>
<p>原型的最主要问题源自它的共享特性。 我们知道，原型上的所有属性是在实例间共享的，这对方法来说比较合适。另外包含原始值的属性也还好，可以通过在实例上添加同名属性来简单地遮蔽原型上的属性。真正的问题来自包含引用值的属性：如果修改了一个实例对象上的引用值属性，由于属性是在同一构造函数下不同实例之间共享的，这份修改也会在其他的实例上反映出来。如果这是有意在多个实例间共享，那没什么问题。但一般来说，不同的实例应该有属于自己的属性副本。这就是实际开发中通常不单独使用原型模式的原因。</p>
<blockquote>
<p>注：“修改”指的是对原型属性进行了某种操作而修改，不是重新赋值，重新赋值不叫修改，这是直接遮蔽了原型上的属性。</p>
</blockquote>
<h6 id="原型和in操作符"><a href="#原型和in操作符" class="headerlink" title="原型和in操作符"></a>原型和in操作符</h6><p>in 操作符可以用于判定某属性是否可以通过对象访问，无论该属性是在实例上还是在原型上。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prop <span class="keyword">in</span> obj</span><br></pre></td></tr></table></figure>

<p>这个表达式会返回一个布尔值结果。</p>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><h5 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h5><p>ECMA-262 把原型链定义为 ECMAScript 的主要继承方式。其基本思想就是通过原型继承多个引用类型的属性和方法。</p>
<p>重温一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型有一个属性指回构造函数；而实例有一个内部指针指向原型。如果原型是另一个类型的实例呢？那就意味着这个原型也有一个内部指针指向另一个原型，这样就在实例和原型之间构造了一条原型链。这就是原型链的基本构想。</p>
<p>原型链代码实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义父类，并为父类定义自己的一个实例属性和一个原型方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">property</span> = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getSuperValue</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">property</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义子类，并为子类定义自己的一个实例属性和一个原型方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">subproperty</span> = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 让子类继承父类，使其可以调用存在于父类上的方法，并且还能具有父类实例对象的属性</span></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">SuperType</span>();</span><br><span class="line"><span class="comment">// 为什么子类原型方法要放在这里定义？因为上面在继承时重写了子类的原型，如果将原型方法定义放在重写之前的话重写之后就没有这个方法了</span></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getSubValue</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">subproperty</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 子类对象拥有父类上的方法和属性</span></span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> <span class="title class_">SubType</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance.<span class="title function_">getSuperValue</span>()); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance.<span class="property">property</span>); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 注：子类和父类原型的constructor属性都将指向父类构造函数</span></span><br></pre></td></tr></table></figure>

<h6 id="默认原型"><a href="#默认原型" class="headerlink" title="默认原型"></a>默认原型</h6><p>实际上，原型链中还有一环。默认情况下，所有引用类型都继承自 Object，这也是通过原型链实现的。任何函数的默认原型都是一个 Object 的实例（即“原型属性是一个对象”），这意味着这个实例有一个内部指针指向 Object.prototype。这也是为什么自定义类型能够继承包括 toString()、valueOf()在内的所有默认方法的原因。</p>
<h6 id="技巧：给定一个对象，如何快速查找其父类、父类的父类、父类的父类的父类…？"><a href="#技巧：给定一个对象，如何快速查找其父类、父类的父类、父类的父类的父类…？" class="headerlink" title="技巧：给定一个对象，如何快速查找其父类、父类的父类、父类的父类的父类…？"></a>技巧：给定一个对象，如何快速查找其父类、父类的父类、父类的父类的父类…？</h6><p>用<code>console.log()</code>将这个对象输出到控制台，然后打开这个对象看它的[[Prototype]]属性值，这就是它的父类，那么接下来可以接着打开这个[[Prototype]]属性的内容来查看它的[[Prototype]]属性值，这就是父类的父类，依此类推。</p>
<p>或者用代码来查找：<code>subType.prototype.constructor.name</code>就是子类的父类的名称，<code>subType.prototype.__proto__.constructor.name</code>就是父类的父类的名称，<code>subType.prototype.__proto__.__proto__.constructor.name</code>就是父类的父类的父类的名称，依此类推。</p>
<p>可以写成循环：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">obj = <span class="title class_">HTMLDocument</span>;<span class="comment">//先用obj.__proto__来检测出实例对象所在的类再使用本循环</span></span><br><span class="line"><span class="keyword">while</span> (obj !== <span class="title class_">Object</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span>.<span class="property">constructor</span>.<span class="property">name</span>); </span><br><span class="line">obj = obj.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span>.<span class="property">constructor</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="实例的继承关系"><a href="#实例的继承关系" class="headerlink" title="实例的继承关系"></a>实例的继承关系</h6><ol>
<li>instanceof 操作符，如果实例的原型链中出现了该构造函数，就会返回true。</li>
<li>isPrototypeOf（）方法，如果实例的原型链中出现了该原型，那就会返回true。</li>
</ol>
<h6 id="关于方法"><a href="#关于方法" class="headerlink" title="关于方法"></a>关于方法</h6><p>记住，子类无论是覆盖父类方法还是增加子类没有的方法或者是子类本身具有的方法（这里指原型方法），都要放在继承之后再来定义这些方法，否则重写原型会导致在这之前定义的原型方法全部消失。</p>
<p>另外添加方法时不要使用对象字面量的形式定义，这样也相当于重写原型，会导致继承无效。</p>
<h6 id="原型链的问题"><a href="#原型链的问题" class="headerlink" title="原型链的问题"></a>原型链的问题</h6><p>原型链继承的问题和原型模式创建对象的问题非常相似。</p>
<p>如果父类的属性是在构造函数中定义的（即实例属性），子类通过原型链继承父类之后由于子类的原型成为了父类的实例，那么子类的原型就会具有父类定义的实例属性（因此子类的实例对象就会通过子类原型得到这个父类的实例属性并在不同子类实例之间共享），也就相当于<strong>这个实例属性实际上变成了原型属性</strong>，这样的话如果这个属性的值是引用值的话，那么对其中一个子类实例对象上这个属性的改变也就会在其他的子类实例对象上反映出来。</p>
<h5 id="盗用构造函数继承（又称对象伪装）"><a href="#盗用构造函数继承（又称对象伪装）" class="headerlink" title="盗用构造函数继承（又称对象伪装）"></a>盗用构造函数继承（又称对象伪装）</h5><p>盗用构造函数继承的思路是：在子类构造函数中用apply（）或call（）方法调用父类的构造函数。</p>
<p>盗用构造函数的代码实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">colors</span> = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="comment">// 继承 SuperType</span></span><br><span class="line"> <span class="title class_">SuperType</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> instance1 = <span class="keyword">new</span> <span class="title class_">SubType</span>();</span><br><span class="line">instance1.<span class="property">colors</span>.<span class="title function_">push</span>(<span class="string">&quot;black&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance1.<span class="property">colors</span>); <span class="comment">// &quot;red,blue,green,black&quot;</span></span><br><span class="line"><span class="keyword">let</span> instance2 = <span class="keyword">new</span> <span class="title class_">SubType</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance2.<span class="property">colors</span>); <span class="comment">// &quot;red,blue,green&quot;</span></span><br></pre></td></tr></table></figure>

<p>这样的话，使用new操作符调用SubType构造函数创建对象时会先将构造函数内部的this指向这个新创建的对象，然后执行里面的SuperType.call(this)这行代码，即调用SuperType构造函数并将SuperType构造函数的this改为指向SubType函数里的this（从而指向了子类新创建的对象），那么这样就会给SubType的对象赋值一个color属性了，并且这个属性不是通过原型获得的，是一个实例属性，也就是说不同子类实例的引用值属性color是它们自己独有的，不会再共享了。</p>
<p>盗用构造函数的一个优点是可以在子类构造函数里面用apply（）或call（）方法调用父类构造函数时顺便传一些参数进去。另外注意如果要给子类添加父类没有的属性的话，和原型链继承时一样，为防止继承时覆盖了自己的属性，要放在继承之后再添加子类自己的属性。</p>
<p>盗用构造函数的缺点和构造函数模式创建对象相似，即以这种模式定义的方法不能重用，在每个子类对象上都会定义一遍。另外由于没有原型链，子类也无法访问父类原型上定义的方法。</p>
<h5 id="组合继承（最终方式）"><a href="#组合继承（最终方式）" class="headerlink" title="组合继承（最终方式）"></a>组合继承（最终方式）</h5><p>根据上面两节内容很容易想到将二者综合起来，使用原型链继承原型上的属性和方法，用盗用构造函数继承实例属性，这样既实现了方法重用，又实现了每个子类对象都有自己的属性。这就是<strong>组合继承</strong>。</p>
<p>组合继承的代码实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义父类时将属性写在构造函数里，将方法写在原型上</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params">name</span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">colors</span> = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params">name, age</span>) &#123; <span class="comment">//父类参数+子类参数</span></span><br><span class="line">   <span class="comment">// 继承父类实例属性</span></span><br><span class="line">   <span class="title class_">SuperType</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name); <span class="comment">//this+父类参数</span></span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">age</span> = age; <span class="comment">// 子类独有的属性</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承父类原型方法</span></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">SuperType</span>();</span><br><span class="line"><span class="comment">//子类独有的方法</span></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayAge</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>组合继承弥补了原型链和盗用构造函数的不足，是 JavaScript 中使用最多的继承模式。而且组合继承也保留了 instanceof 操作符和 isPrototypeOf()方法识别合成对象的能力。</p>
<p>组合继承要说有问题的话就在于效率的问题，因为在组合继承的过程中父类构造函数会被调用两次。</p>
<p>有一种更佳的继承方式叫寄生式组合继承，不过在看它之前先来看看原型式继承和寄生式继承。</p>
<h5 id="不需要单独建立构造函数时的两种继承方式"><a href="#不需要单独建立构造函数时的两种继承方式" class="headerlink" title="不需要单独建立构造函数时的两种继承方式"></a>不需要单独建立构造函数时的两种继承方式</h5><h4 id="ES6类"><a href="#ES6类" class="headerlink" title="ES6类"></a>ES6类</h4><h5 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h5><p>类定义有两种方式：类声明和类表达式。</p>
<p>类声明：<code>class Name&#123;&#125;</code></p>
<p>类表达式：<code>const variable = class &#123;&#125;;</code>或者<code>const variable = class Name &#123;&#125;;</code> </p>
<p>创建类的实例：<code>new ClassName();</code></p>
<p>类声明与函数声明的一个区别就是类声明不会像函数声明那样提升。</p>
<p>另一个区别在于非严格模式下如果一个块作用域中同时有一个函数和一个类，那么在块作用域外部可以引用到这个函数，但引用这个类时会报错。</p>
<h5 id="类的构成"><a href="#类的构成" class="headerlink" title="类的构成"></a>类的构成</h5><p>类可以包含构造函数方法、实例方法、获取函数、设置函数和静态类方法，但这些都不是必需的。 空的类定义照样有效。</p>
<p><strong>在类构造函数中定义的属性和方法相当于实例属性，即不同实例对象之间不会共享；在类块之内、类构造函数之外定义的属性和方法会定义在类的原型上，相当于原型方法，会在不同实例间共享。</strong>所以我们一般将属性写在类构造函数里，相当于ES5中使用构造函数时将属性写在构造函数中；将方法写在类中和类构造函数同级的位置，相当于ES5中使用构造函数时将方法定义在构造函数的prototype原型上。</p>
<p>但是不能给类的原型添加原始值或者对象，只能定义方法。且在定义方法的时候要写成<code>functionName() &#123;&#125;</code>的形式，不能使用键值对的形式，都会报错。不过方法名也可以使用符号或者可计算属性键来写。</p>
<p>类也可以使用get 和 set 关键字来定义获取访问器和设置访问器：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">//set访问器函数至少需要一个参数</span></span><br><span class="line"> <span class="keyword">set</span> <span class="title function_">name</span>(<span class="params">newName</span>) &#123;</span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">name_</span> = newName;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">get</span> <span class="title function_">name</span>() &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name_</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>类上也可以定义静态方法，即通常用于执行不特定于实例的操作，也不要求存在类的实例的方法。</p>
<p>定义静态方法时要用static关键字作为前缀。静态方法中的this引用类自身。原型方法是定义在类的原型上的，而静态方法是定义在类本身上的。故原型方法调用时类名和方法名中间要加一层prototype；而调用静态方法时用类名直接调用即可。</p>
<p>刚刚虽然说不能在类的原型或者类上添加原始值等数据成员，但可以在类定义的外部通过类名手动添加。</p>
<p>类还支持在原型和类上定义生成器方法。</p>
<p>默认情况下，类定义中的代码都在严格模式下执行。 </p>
<p>与函数构造函数一样，多数编程风格都建议类名的首字母要大写，以区别于通过它创建的实例。</p>
<p>类和函数一样，也可以通过 name 属性取得类表达式的名称字符串。但不能在类表达式作用域外部访问这个标识符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">Person</span> = <span class="keyword">class</span> <span class="title class_">PersonName</span> &#123;</span><br><span class="line">  <span class="title function_">identify</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property">name</span>, <span class="title class_">PersonName</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">p.<span class="title function_">identify</span>(); <span class="comment">// PersonName PersonName</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property">name</span>); <span class="comment">// PersonName</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">PersonName</span>); <span class="comment">// ReferenceError: PersonName is not defined </span></span><br></pre></td></tr></table></figure>

<h5 id="类构造函数"><a href="#类构造函数" class="headerlink" title="类构造函数"></a>类构造函数</h5><p>constructor 关键字用于在类定义块内部创建类的构造函数。方法名 constructor 会告诉解释器在使用 new 操作符创建类的新实例时，应该调用这个函数。构造函数的定义不是必需的，不定义构造函数相当于将构造函数定义为空函数。</p>
<p>语法如下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person ctor&#x27;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br></pre></td></tr></table></figure>

<p>当使用new操作符实例化一个类的时候所进行的操作和用new调用一个构造函数是一样的。</p>
<p>类实例化时传入的参数会用作构造函数的参数。如果不需要参数，则类名后面的括号也是可选的。</p>
<p>默认情况下，类构造函数会在执行之后返回 this 对象。构造函数返回的对象会被用作实例化的对象。不过，如果返回的不是 this 对象，而是其他对象，那么这个对象不会通过 instanceof 操作符检测出跟类有关联（即返回值为false）。</p>
<p>类构造函数与构造函数的主要区别是，调用类构造函数必须使用 new 操作符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以这样new</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="comment">// 也可以这样new</span></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> p1.<span class="title function_">constructor</span>(<span class="params"></span>);</span><br></pre></td></tr></table></figure>

<p>调用类构造函数时如果忘了使用 new 则会抛出错误。</p>
<h5 id="类是一种特殊函数"><a href="#类是一种特殊函数" class="headerlink" title="类是一种特殊函数"></a>类是一种特殊函数</h5><p>用typeof检测一个被声明的类，返回的结果是’function’。这表示类就是一种特殊的函数。因此类标识符也有 prototype 属性，而这个原型也有一个 constructor 属性指向类自身。</p>
<p>可以使用instanceof操作符检测一个对象是不是一个类的实例。前面有说过“instanceof 操作符：如果实例的原型链中出现了该构造函数，就会返回true”，对类也是一样，这里检测的就是类中构造函数是否出现在实例的原型链中，只不过此处的类构造函数要用类名代替：<code>p instanceof Person</code>。既然是检测构造函数，那为什么不用constructor方法呢？因为虽然这个方法相当于构造函数，但类本身在使用new调用时就会被当成构造函数，而类中定义的constructor方法不会被当成构造函数，用instanceof直接检测constructor方法的话会返回false。</p>
<p>除非，在创建实例的时候new的方法是<code>new Person.constructor()</code>这种，那么instanceof检测的时候会返回true。</p>
<p>和函数一样，类也可以作为参数，可以在任何地方定义；类也可以立即实例化：<code>let p = new class &#123;&#125;;</code>。</p>
<h5 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h5><p>ES6类的继承使用extends关键字，可以继承ES6类，也可以继承普通的构造函数。</p>
<p><code>class SubType extends SuperType &#123;&#125;</code></p>
<h6 id="super（）"><a href="#super（）" class="headerlink" title="super（）"></a>super（）</h6><p>在类构造函数中使用super关键字可以调用父类构造函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">hasEngine</span> = <span class="literal">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bus</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vehicle</span> &#123;</span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="comment">// 不要在调用 super()之前引用 this，否则会抛出 ReferenceError</span></span><br><span class="line"> <span class="variable language_">super</span>(); <span class="comment">// 相当于 super.constructor()</span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Vehicle</span>); <span class="comment">// true</span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// Bus &#123; hasEngine: true &#125;</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Bus</span>();</span><br></pre></td></tr></table></figure>

<p>在静态方法中可以通过super调用父类上定义的静态方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line"> <span class="keyword">static</span> <span class="title function_">identify</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;vehicle&#x27;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bus</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vehicle</span> &#123;</span><br><span class="line"> <span class="keyword">static</span> <span class="title function_">identify</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="variable language_">super</span>.<span class="title function_">identify</span>();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Bus</span>.<span class="title function_">identify</span>(); <span class="comment">// vehicle</span></span><br></pre></td></tr></table></figure>

<p>使用super时要注意几个问题：</p>
<ol>
<li>super只能在派生类构造函数和静态方法中使用；</li>
<li>不能单独使用super关键字，要么super（）调用构造函数，要么super.method()调用静态方法。</li>
<li>super（）调用父类构造函数后会将返回的实例赋值给this。</li>
<li>super（）调用父类构造函数时如果需给父类构造函数传参，需手动传入。</li>
<li>如果派生类（使用了extends继承某类的类就是派生类）中没有定义类构造函数，在实例化时会自动调用super（）并会传入所有传给派生类的参数。</li>
<li>如果派生类中显式定义了构造函数，那么必须在其中调用super（）或者在其中返回一个对象。</li>
</ol>
<h6 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h6><p>有时候需要定义一种专供其他类继承但自身不会被实例化的类，即抽象基类。可以通过new.target来实现，在自身不需要实例化的类中添加如下代码即可：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">new</span>.<span class="property">target</span> === className) &#123; <span class="comment">// new.target会检测所在函数是否是被new调用的，若是将指向该构造函数（类名）</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;className cannot be directly instantiated.&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="继承内置类型"><a href="#继承内置类型" class="headerlink" title="继承内置类型"></a>继承内置类型</h6><p>继承并扩展内置类型。</p>
<h6 id="混用mixin"><a href="#混用mixin" class="headerlink" title="混用mixin"></a>混用mixin</h6><h2 id="代理与反射"><a href="#代理与反射" class="headerlink" title="代理与反射"></a>代理与反射</h2><p>代理可用于拦截底层对象操作并施加自定义行为。</p>
<p>代理的常见应用场景是：</p>
<ol>
<li>实现真正的数据私有化；</li>
<li>保证数据的准确性；</li>
<li>Vue3的双向数据绑定就是使用Proxy来实现的。</li>
</ol>
<h4 id="代理基础"><a href="#代理基础" class="headerlink" title="代理基础"></a>代理基础</h4><p>代理是使用Proxy构造函数创建的，它接收两个对象作为参数：目标对象和处理器对象，两个参数缺一不可。</p>
<p><code>const proxy = new Proxy(target, handler);</code></p>
<p>当处理器对象是个空对象时，在代理对象上执行的任何操作都会应用到目标对象，在操作中可以认为使用代理对象和使用其所代理的目标对象是等价的。</p>
<p>可以用严格相等操作符来区分代理对象和目标对象，它们在比较时会返回false。</p>
<p>另外，虽然代理是用Proxy构造函数构造的，但是在用instanceof操作符检测时会报错，因为Proxy.prototype的值是undefined。</p>
<h4 id="定义捕获器"><a href="#定义捕获器" class="headerlink" title="定义捕获器"></a>定义捕获器</h4><p>使用代理的主要目的是可以定义捕获器（trap）。捕获器就是在处理器对象中定义的“基本操作的拦截器”，是处理器对象中定义的方法。每个处理器对象可以包含零个或多个捕获器，每个捕获器都对应一种可以直接或间接在代理对象上调用的基本操作。每次在代理对象上调用这些基本操作时，代理可以在这些操作传播到目标对象之前先调用捕获器函数，从而拦截并修改相应的行为。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Trapped!&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>get（）捕获器会在对代理对象使用中括号语法、点语法获取属性值的时候被触发，并返回return语句返回的值而不是原来的属性值。</p>
<p>注意，只有在代理对象上执行操作才会触发捕获器，直接对目标对象操作是不会触发捕获器的。</p>
<h4 id="捕获器参数和反射API"><a href="#捕获器参数和反射API" class="headerlink" title="捕获器参数和反射API"></a>捕获器参数和反射API</h4><p>捕获器方法是可以接收参数的，并基于这些参数来重建（重新建立，即自己手动实现）被捕获的原始行为。比如，get() 捕获器会接收到目标对象、要查询的属性和代理对象三个参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">   <span class="attr">id</span>: <span class="string">&#x27;target&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">   <span class="title function_">get</span>(<span class="params">trapTarget, property, receiver</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> trapTarget.<span class="property">property</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">id</span>);</span><br><span class="line"><span class="comment">// target</span></span><br></pre></td></tr></table></figure>

<p>所有捕获器都可以基于自己的参数重建原始操作，但并非所有捕获器行为都像 get()那么简单。因此，通过手动写码如法炮制的想法是不现实的。实际上，开发者并不需要手动重建原始行为，而是可以通过调用全局 Reflect 对象上（封装了原始行为）的同名方法来轻松重建。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">	<span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(...<span class="variable language_">arguments</span>); <span class="comment">// arguments是get（）捕获器在被触发时接收到的参数，Reflect.get方法接收的参数和get（）捕获器是一样的，所以可以直接用...arguments代替</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="常用的捕获器与反射API"><a href="#常用的捕获器与反射API" class="headerlink" title="常用的捕获器与反射API"></a>常用的捕获器与反射API</h5><p>要理解的是捕获器方法中是可以拦截并自定义原始行为的，而反射方法是封装了原始行为的方法，目的是重建原始行为时更方便，是用于直接执行来模拟原始行为的，不是用来自定义原始行为的。</p>
<h6 id="get（）"><a href="#get（）" class="headerlink" title="get（）"></a>get（）</h6><p>get（）捕获器接收三个参数：自身包含或在其原型链上包含要获取的属性的目标对象、要读取的属性的属性键、用作获取函数中的this值的接收者对象（一般为代理对象或继承代理对象的对象）。</p>
<p>get（）捕获器可以用return语句来控制返回的读取的属性值。</p>
<p>get（）捕获器对应的反射方法是Reflect.get()，这个方法也接收三个参数，和get（）捕获器的参数是一样的；这个方法的作用是获取目标对象上的指定属性值并返回它，当接收器对象为目标对象的时候相当于<code>target[propertyKey]</code>（为代理对象时当然就是<code>proxy[propertyKey]</code>了）。</p>
<p>如上所见，Reflect.get()方法在get（）捕获器中使用时可以直接用<code>...arguments</code>来当参数。如果它不在get（）捕获器中使用时，就需要手动来指定那三个参数是哪些变量。</p>
<p>get（）捕获器拦截的操作：</p>
<ol>
<li><code>proxy.property</code></li>
<li><code>proxy[property]</code></li>
<li><code>Object.create(proxy)[property]</code></li>
<li><code>Reflect.get(proxy, property, receiver)</code></li>
</ol>
<p>捕获器不变式：</p>
<blockquote>
<p>捕获器不变式：捕获器几乎可以改变所有基本方法的行为，但也不是没有限制。根据ECMAScript规范，捕获器的行为必须遵循捕获器不变式，防止捕获器定义出现过于反常的行为。</p>
</blockquote>
<p>如果<code>target.property</code>不可写且不可配置，则处理器返回的值必须与它匹配；</p>
<p>如果<code>target.property</code>不可配置且[[Get]]特性为undefined，则处理器返回的值也必须是undefined。</p>
<h6 id="set（）"><a href="#set（）" class="headerlink" title="set（）"></a>set（）</h6><p>set（）捕获器用于将值赋给目标对象上的属性。</p>
<p>set（）捕获器接收四个参数：目标对象、目标对象上的属性键、要赋给属性的值、用作设置函数中的this值的接收器对象。</p>
<p>set（）捕获器对应的反射方法是Reflect.set()。</p>
<p>set（）捕获器如果返回true则表示成功，返回false则表示失败，严格模式下返回false会抛出TypeError。</p>
<p>set（）捕获器拦截的操作：</p>
<ol>
<li><code>proxy.property = value</code></li>
<li><code>proxy[property] = value</code></li>
<li><code>Object.create(proxy)[property] = value</code></li>
<li><code>Reflect.get(proxy, property, value, receiver)</code></li>
</ol>
<p>捕获器不变式：</p>
<p>如果 target.property 不可写且不可配置，则不能修改目标属性的值。 </p>
<p>如果 target.property 不可配置且[[Set]]特性为 undefined，则不能修改目标属性的值。</p>
<h6 id="has（）"><a href="#has（）" class="headerlink" title="has（）"></a>has（）</h6><p>has（）捕获器用于判定属性键是否存在于目标对象上。</p>
<p>has（）捕获器接收两个参数：目标对象和需要判定的属性键。</p>
<p>has（）必须返回表示判定结果的布尔值，如果返回非布尔值会被强制转换为布尔值。</p>
<p>has（）捕获器对应的反射方法是Reflect.has()，相当于<code>propertyKey in target</code>，会返回表示判定结果的布尔值。</p>
<p>has（）捕获器拦截的操作：</p>
<ol>
<li><code>property in proxy</code></li>
<li><code>property in Object.create(proxy)</code></li>
<li><code>with(proxy) &#123;(property);&#125;</code></li>
<li><code>Reflect.has(proxy, property)</code></li>
</ol>
<p>捕获器不变式：</p>
<p>如果 target.property 存在且不可配置，则处理程序必须返回 true。</p>
<p>如果 target.property 存在且目标对象不可扩展，则处理程序必须返回 true。</p>
<h6 id="defineProperty（）"><a href="#defineProperty（）" class="headerlink" title="defineProperty（）"></a>defineProperty（）</h6><p>defineProperty（）捕获器用于向对象上增添属性或修改属性的内部特性。</p>
<p>defineProperty（）捕获器接收三个参数：目标对象、目标对象上的属性键、属性的内部特性描述符。</p>
<p>defineProperty（）捕获器必须返回布尔值，返回非布尔值会被强制转换为布尔值。</p>
<p>defineProperty（）捕获器对应的反射方法是Reflect.defineProperty()。</p>
<p>defineProperty（）捕获器拦截的操作：</p>
<ol>
<li><code>Object.defineProperty(proxy, property, descriptor)</code></li>
<li><code>Reflect.defineProperty(proxy, property, descriptor)</code></li>
</ol>
<p>捕获器不变式：</p>
<p>如果目标对象不可扩展，则无法定义属性。</p>
<p>如果目标对象有一个可配置的属性，则不能添加同名的不可配置属性。</p>
<p>如果目标对象有一个不可配置的属性，则不能添加同名的可配置属性。</p>
<h6 id="getOwnPropertyDescriptor（）"><a href="#getOwnPropertyDescriptor（）" class="headerlink" title="getOwnPropertyDescriptor（）"></a>getOwnPropertyDescriptor（）</h6><p>getOwnPropertyDescriptor（）捕获器用于获得目标对象上的指定自有属性（不是从原型上得来的）的内部特性描述符。</p>
<p>getOwnPropertyDescriptor（）捕获器接收两个参数：目标对象和属性键。</p>
<p>getOwnPropertyDescriptor（）捕获器必须返回包含内部特性描述符的对象，或者属性不存在时返回undefined。</p>
<p>getOwnPropertyDescriptor（）捕获器对应的反射方法为Reflect.getOwnPropertyDescriptor()。</p>
<p>getOwnPropertyDescriptor（）捕获器拦截的操作：</p>
<ol>
<li><code>Object.getOwnPropertyDescriptor(proxy, property)</code></li>
<li><code>Reflect.getOwnPropertyDescriptor(proxy, property)</code></li>
</ol>
<p>捕获器不变式：</p>
<p>如果自有的 target.property 存在且不可配置，则处理程序必须返回一个表示该属性存在的对象。</p>
<p>如果自有的 target.property 存在且可配置，则处理程序必须返回表示该属性可配置的对象。</p>
<p>如果自有的 target.property 存在且 target 不可扩展，则处理程序必须返回一个表示该属性存在的对象。</p>
<p>如果 target.property 不存在且 target 不可扩展，则处理程序必须返回 undefined 表示该属性不存在。</p>
<p>如果 target.property 不存在，则处理程序不能返回表示该属性可配置的对象。</p>
<h6 id="deleteProperty（）"><a href="#deleteProperty（）" class="headerlink" title="deleteProperty（）"></a>deleteProperty（）</h6><p>deleteProperty（）捕获器用于从目标对象上删除指定属性。</p>
<p>deleteProperty（）捕获器接收两个参数：目标对象和要删除的属性。</p>
<p>deleteProperty（）捕获器必须返回布尔值表示删除是否成功，返回非布尔值会被强制转换为布尔值。</p>
<p>deleteProperty（）捕获器对应的反射方法是Reflect.deleteProperty()，相当于<code>delete target[propertyKey]</code>。</p>
<p>deleteProperty（）捕获器拦截的操作：</p>
<ol>
<li><code>delete proxy.property</code></li>
<li><code>delete proxy[property]</code></li>
<li><code>Reflect.deleteProperty(proxy, property)</code></li>
</ol>
<p>捕获器不变式：</p>
<p>如果自有的 target.property 存在且不可配置，则处理程序不能删除这个属性。</p>
<h6 id="ownKeys（）"><a href="#ownKeys（）" class="headerlink" title="ownKeys（）"></a>ownKeys（）</h6><p>ownKeys（）捕获器用于遍历目标对象上自有的（即不是从原型上继承的）字符串键属性和符号键属性。</p>
<p>ownKeys（）捕获器接收一个参数：目标对象。</p>
<p>ownKeys（）捕获器返回一个包含字符串或符号的数组。</p>
<p>ownKeys（）捕获器对应的反射方法是Reflect.ownKeys()。</p>
<p>ownKeys（）捕获器拦截的操作：</p>
<ol>
<li><code>Object.getOwnPropertyNames(proxy)</code></li>
<li><code>Object.getOwnPropertySymbols(proxy)</code></li>
<li><code>Object.keys(proxy)</code></li>
<li><code>Reflect.ownKeys(proxy)</code></li>
</ol>
<p>捕获器不变式：</p>
<p>返回的可枚举对象必须包含 target 的所有不可配置的自有属性。 如果 target 不可扩展，则返回可枚举对象必须准确地包含自有属性键。</p>
<h6 id="getPrototypeOf（）"><a href="#getPrototypeOf（）" class="headerlink" title="getPrototypeOf（）"></a>getPrototypeOf（）</h6><h6 id="setPrototypeOf（）"><a href="#setPrototypeOf（）" class="headerlink" title="setPrototypeOf（）"></a>setPrototypeOf（）</h6><h6 id="isExtensible（）"><a href="#isExtensible（）" class="headerlink" title="isExtensible（）"></a>isExtensible（）</h6><h6 id="preventExtensions（）"><a href="#preventExtensions（）" class="headerlink" title="preventExtensions（）"></a>preventExtensions（）</h6><h6 id="apply（）"><a href="#apply（）" class="headerlink" title="apply（）"></a>apply（）</h6><p>apply（）捕获器用于调用目标函数，并以指定对象作为其this值和以指定数组作为其arguments。</p>
<p>apply（）捕获器接收三个参数：目标函数、this值对象和arguments数组。</p>
<p>apply（）捕获器对应的反射方法是Reflect.apply()。</p>
<p>apply（）捕获器拦截的操作：</p>
<ol>
<li><code>proxy(...argumentsList)</code></li>
<li><code>Function.prototype.apply(thisArg, argumentsList)</code></li>
<li><code>Function.prototype.call(thisArg, ...argumentsList)</code></li>
<li><code>Reflect.apply(target, thisArgument, argumentsList)</code></li>
</ol>
<p>捕获器不变式：</p>
<p>target必须是一个函数对象。</p>
<h6 id="construct（）"><a href="#construct（）" class="headerlink" title="construct（）"></a>construct（）</h6><p>construct（）捕获器用于用指定函数作为构造函数和用指定数组作为参数和指定构造函数作为new.target的值来构造一个对象。</p>
<p>construct（）捕获器接收三个参数：目标函数、指定数组、指定函数。</p>
<p>construct（）捕获器必须返回一个对象。</p>
<p>construct（）捕获器对应的反射方法是Reflect.construct()。</p>
<p>construct（）捕获器拦截的操作：</p>
<ol>
<li><code>new proxy(...argumentsList)</code></li>
<li><code>Reflect.construct(target, argumentsList, newTarget)</code></li>
</ol>
<p>捕获器不变式：</p>
<p>target必须可以用作构造函数。</p>
<h4 id="可撤销代理"><a href="#可撤销代理" class="headerlink" title="可撤销代理"></a>可撤销代理</h4><p>有时候可能需要中断代理对象与目标对象之间的联系。对于使用 new Proxy()创建的普通代理来说，这种联系会在代理对象的生命周期内一直持续存在。</p>
<p>Proxy 也暴露了 revocable()方法，这个方法支持撤销代理对象与目标对象的关联。撤销代理的操作是不可逆的。而且，撤销函数调用多少次的结果都一样。撤销代理之后再调用代理会抛出 TypeError。</p>
<p>撤销函数和代理对象是在实例化时同时生成的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line"> <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line"> <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="string">&#x27;intercepted&#x27;</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> &#123; proxy, revoke &#125; = <span class="title class_">Proxy</span>.<span class="title function_">revocable</span>(target, handler); <span class="comment">// 撤销代理的前提</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">foo</span>); <span class="comment">// intercepted</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">foo</span>); <span class="comment">// bar</span></span><br><span class="line"><span class="title function_">revoke</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">foo</span>); <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure>

<h4 id="代理的问题"><a href="#代理的问题" class="headerlink" title="代理的问题"></a>代理的问题</h4><p>代理与内置引用类型（比如 Array）的实例通常可以很好地协同，但有些 ECMAScript 内置类型可能会依赖代理无法控制的机制，结果导致在代理上调用某些方法会出错。 </p>
<p>一个典型的例子就是 Date 类型。根据 ECMAScript 规范，Date 类型方法的执行依赖 this 值上的内部槽位[[NumberDate]]。代理对象上不存在这个内部槽位，而且这个内部槽位的值也不能通过普通的 get()和 set()操作访问到，于是代理拦截后本应转发给目标对象的方法会抛出 TypeError。</p>
<h4 id="代理可以实现的编程模式"><a href="#代理可以实现的编程模式" class="headerlink" title="代理可以实现的编程模式"></a>代理可以实现的编程模式</h4><h5 id="跟踪属性访问"><a href="#跟踪属性访问" class="headerlink" title="跟踪属性访问"></a>跟踪属性访问</h5><p>即捕获get、set、has等操作，并添加一条打印日志的语句来确定某个属性何时何地被访问过。</p>
<h5 id="隐藏属性"><a href="#隐藏属性" class="headerlink" title="隐藏属性"></a>隐藏属性</h5><p>即捕获对要隐藏的属性的get、has的操作，并返回undefined或false。</p>
<h5 id="属性验证"><a href="#属性验证" class="headerlink" title="属性验证"></a>属性验证</h5><p>在set操作设置属性之前先捕获它，并验证其值是否符合规定，再决定是否允许本次赋值。</p>
<h5 id="函数与构造函数参数验证"><a href="#函数与构造函数参数验证" class="headerlink" title="函数与构造函数参数验证"></a>函数与构造函数参数验证</h5><p>类上，捕获时目标对象写函数名或类名即可。</p>
<h5 id="数据绑定与可观察对象"><a href="#数据绑定与可观察对象" class="headerlink" title="数据绑定与可观察对象"></a>数据绑定与可观察对象</h5><h2 id="期约与异步函数"><a href="#期约与异步函数" class="headerlink" title="期约与异步函数"></a>期约与异步函数</h2><h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4><p>JavaScript中与定时器有关的函数有两个：setTimeout（）用于指定在一定时间后执行某些代码；setInterval（）用于指定每隔一段时间执行某些代码。</p>
<p>setTimeout（）方法通常接收两个参数：第一个参数是一定时间后执行的代码（可以回调函数或代码字符串的方式传入，但是代码字符串的形式只有在网页中有效，如果在node环境下则必须以回调函数方式传入，回调函数可写成函数表达式形式或者箭头函数），第二个参数是等待的毫秒数。实际上这第二个参数只是告诉JavaScript引擎在指定的毫秒数后将任务添加到任务队列，如果队列是空的才会立即执行回调函数，如果队列不是空的，那么代码还得等待前面的任务执行完才能执行。</p>
<p>setTimeout（）也可以接收更多的参数，这些参数都会传入回调函数中作为参数。</p>
<blockquote>
<p>阮一峰JavaScript入门说法：<code>setTimeout</code>和<code>setInterval</code>的运行机制，是将指定的代码移出本轮事件循环，等到下一轮事件循环，再检查是否到了指定时间。如果到了，就执行对应的代码；如果不到，就继续等待。</p>
</blockquote>
<p>setTimeout（）方法会返回表示该超时排期的ID，这个ID是排期任务的唯一标识符，可以传入clearTimeout（）方法作为参数来取消该任务。只要在指定时间到达之前调用clearTimeout（）方法就可以取消成功，若超时再调用就没有效果了。</p>
<p>setInterval（）方法也接收两个参数：第一个参数是每隔一段时间要执行的代码（回调函数或代码字符串形式），第二个参数是把下一次任务添加到要等待的时间。setInterval（）方法定义的定时任务会每隔一段时间进行一次，直到取消循环定时或者页面卸载。</p>
<p>setInterval（）也可以接收更多的参数，这些参数都会传入回调函数中作为参数。</p>
<p>setInterval（）方法也会返回循环定时ID，可以传入clearInterval（）方法作为参数来取消循环定时。</p>
<p>setInterval（）会根据设置的时间定时启动回调函数，但并不在乎这个函数要用时多久来完成，有可能这个函数每次执行时间不同，或者下一次循环到了但这次的回调函数还没执行完，为了让每次回调执行的间隔相同，可以用递归setTimeout()来代替setInterval()：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">myFunction</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">setTimeout</span>(myFunction, interval);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(myFunction, interval);</span><br></pre></td></tr></table></figure>

<p>和setInterval（）有同样的循环效果。</p>
<blockquote>
<p>另外，setTimeout（）方法和setInterval（）方法如果连续调用的话返回的ID是连续的整数，且每次都会+1。连续调用可以是setTimeout（）接着setInterval（），只要是连续的即可。</p>
</blockquote>
<h5 id="setTimeout（f，0）"><a href="#setTimeout（f，0）" class="headerlink" title="setTimeout（f，0）"></a>setTimeout（f，0）</h5><h6 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h6><p><code>setTimeout(f, 0)</code>不会真的在0毫秒之后运行，因为上一节说过，必须要等到当前脚本的同步任务，全部处理完以后，才会执行<code>setTimeout</code>指定的回调函数<code>f</code>。也就是说，<code>setTimeout(f, 0)</code>会在下一轮事件循环一开始就执行。</p>
<p>不同的浏览器有不同的实现。以 Edge 浏览器为例，会等到4毫秒之后运行。如果电脑正在使用电池供电，会等到16毫秒之后运行；如果网页不在当前 Tab 页，会推迟到1000毫秒（1秒）之后运行。这样是为了节省系统资源。</p>
<p>总之，<code>setTimeout(f, 0)</code>这种写法的目的是，尽可能早地执行<code>f</code>，但是并不能保证立刻就执行<code>f</code>。</p>
<h6 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h6><p><code>setTimeout(f, 0)</code>可以用于调整事件发生的顺序。比如，网页开发中，某个事件先发生在子元素，然后冒泡到父元素，即子元素的事件回调函数，会早于父元素的事件回调函数触发。如果想让父元素的事件回调函数先发生，就要用到<code>setTimeout(f, 0)</code>对子元素的回调函数进行延期处理，使得父元素的回调函数先发生。</p>
<h4 id="异步操作概述"><a href="#异步操作概述" class="headerlink" title="异步操作概述"></a>异步操作概述</h4><h5 id="单线程模型"><a href="#单线程模型" class="headerlink" title="单线程模型"></a>单线程模型</h5><p>单线程模型指的是，JavaScript 只在一个线程上运行。也就是说，JavaScript 同时只能执行一个任务，其他任务都必须在后面排队等待。</p>
<p>注意，JavaScript 只在一个线程上运行，不代表 JavaScript 引擎只有一个线程。事实上，JavaScript 引擎有多个线程，单个脚本只能在一个线程上运行（称为主线程），其他线程都是在后台配合。</p>
<p>JavaScript 之所以采用单线程，而不是多线程，跟历史有关系。JavaScript 从诞生起就是单线程，原因是不想让浏览器变得太复杂，因为多线程需要共享资源、且有可能修改彼此的运行结果，对于一种网页脚本语言来说，这就太复杂了。如果 JavaScript 同时有两个线程，一个线程在网页 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？是不是还要有锁机制？所以，为了避免复杂性，JavaScript 一开始就是单线程，这已经成了这门语言的核心特征，将来也不会改变。</p>
<p>这种模式的好处是实现起来比较简单，执行环境相对单纯；坏处是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。常见的浏览器无响应（假死），往往就是因为某一段 JavaScript 代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。JavaScript 语言本身并不慢，慢的是读写外部数据，比如等待 Ajax 请求返回结果。这个时候，如果对方服务器迟迟没有响应，或者网络不通畅，就会导致脚本的长时间停滞。</p>
<p>如果排队是因为计算量大，CPU 忙不过来，倒也算了，但是很多时候 CPU 是闲着的，因为 IO 操作（输入输出）很慢（比如 Ajax 操作从网络读取数据），不得不等着结果出来，再往下执行。JavaScript 语言的设计者意识到，这时 CPU 完全可以不管 IO 操作，挂起处于等待中的任务，先运行排在后面的任务。等到 IO 操作返回了结果，再回过头，把挂起的任务继续执行下去。这种机制就是 JavaScript 内部采用的“事件循环”机制（Event Loop）。</p>
<p>单线程模型虽然对 JavaScript 构成了很大的限制，但也因此使它具备了其他语言不具备的优势。如果用得好，JavaScript 程序是不会出现堵塞的，这就是为什么 Node 可以用很少的资源，应付大流量访问的原因。</p>
<p>为了利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 DOM。所以，这个新标准并没有改变 JavaScript 单线程的本质。</p>
<h5 id="同步任务和异步任务"><a href="#同步任务和异步任务" class="headerlink" title="同步任务和异步任务"></a>同步任务和异步任务</h5><p>程序里面所有的任务，可以分成两类：同步任务（synchronous）和异步任务（asynchronous）。</p>
<p>同步任务是那些没有被引擎挂起、在主线程上排队执行的任务。只有前一个任务执行完毕，才能执行后一个任务。</p>
<p>异步任务是那些被引擎放在一边，不进入主线程、而进入任务队列的任务。只有引擎认为某个异步任务可以执行了（比如 Ajax 操作从服务器得到了结果），该任务（采用回调函数的形式）才会进入主线程执行。而排在异步任务后面的代码，不用等待异步任务结束就可以马上运行，也就是说，异步任务不具有“堵塞”效应。</p>
<h5 id="任务队列和事件循环"><a href="#任务队列和事件循环" class="headerlink" title="任务队列和事件循环"></a>任务队列和事件循环</h5><p>JavaScript 运行时，除了一个正在运行的主线程，引擎还提供一个任务队列（task queue），里面是各种需要当前程序处理的异步任务。（实际上，根据异步任务的类型，存在多个任务队列。为了方便理解，这里假设只存在一个队列。）</p>
<p>首先，主线程会去执行所有的同步任务。等到同步任务全部执行完，就会去看任务队列里面的异步任务。如果满足条件，那么异步任务就重新进入主线程开始执行，这时它就变成同步任务了。等到执行完，下一个异步任务再进入主线程开始执行。一旦任务队列清空，程序就结束执行。</p>
<p>异步任务的写法通常是回调函数。一旦异步任务重新进入主线程，就会执行对应的回调函数。如果一个异步任务没有回调函数，就不会进入任务队列，也就是说，不会重新进入主线程，因为没有用回调函数指定下一步的操作。</p>
<p>JavaScript 引擎怎么知道异步任务有没有结果，能不能进入主线程呢？答案就是引擎在不停地检查，一遍又一遍，只要同步任务执行完了，引擎就会去检查那些挂起来的异步任务，是不是可以进入主线程了。这种循环检查的机制，就叫做事件循环（Event Loop）。维基百科的定义是：“事件循环是一个程序结构，用于等待和发送消息和事件（a programming construct that waits for and dispatches events or messages in a program）”。</p>
<h5 id="异步操作的模式"><a href="#异步操作的模式" class="headerlink" title="异步操作的模式"></a>异步操作的模式</h5><h6 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h6><p>回调函数的优点是简单、容易理解和实现，缺点是不利于代码的阅读和维护，各个部分之间高度耦合（coupling），使得程序结构混乱、流程难以追踪（尤其是多个回调函数嵌套的情况），而且每个任务只能指定一个回调函数。</p>
<h6 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h6><p>事件驱动模式。异步任务的执行不取决于代码的顺序，而取决于某个事件是否发生。</p>
<p>还是以<code>f1</code>和<code>f2</code>为例。首先，为<code>f1</code>绑定一个事件（这里采用的 jQuery 的写法）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f1.<span class="title function_">on</span>(<span class="string">&#x27;done&#x27;</span>, f2);</span><br></pre></td></tr></table></figure>

<p>上面这行代码的意思是，当<code>f1</code>发生<code>done</code>事件，就执行<code>f2</code>。然后，对<code>f1</code>进行改写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    f1.<span class="title function_">trigger</span>(<span class="string">&#x27;done&#x27;</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>f1.trigger(&#39;done&#39;)</code>表示，执行完成后，立即触发<code>done</code>事件，从而开始执行<code>f2</code>。</p>
<p>这种方法的优点是比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以“去耦合”（decoupling），有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。阅读代码的时候，很难看出主流程。</p>
<h6 id="发布-x2F-订阅"><a href="#发布-x2F-订阅" class="headerlink" title="发布&#x2F;订阅"></a>发布&#x2F;订阅</h6><p>事件完全可以理解成“信号”，如果存在一个“信号中心”，某个任务执行完成，就向信号中心“发布”（publish）一个信号，其他任务可以向信号中心“订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”发布&#x2F;订阅模式”（publish-subscribe pattern），又称“观察者模式”（observer pattern）。</p>
<p>这个模式有多种实现，下面采用的是 Ben Alman 的 Tiny Pub&#x2F;Sub，这是 jQuery 的一个插件。</p>
<p>首先，<code>f2</code>向信号中心<code>jQuery</code>订阅<code>done</code>信号。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jQuery.<span class="title function_">subscribe</span>(<span class="string">&#x27;done&#x27;</span>, f2);</span><br></pre></td></tr></table></figure>

<p>然后，<code>f1</code>进行如下改写。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    jQuery.<span class="title function_">publish</span>(<span class="string">&#x27;done&#x27;</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>jQuery.publish(&#39;done&#39;)</code>的意思是，<code>f1</code>执行完成后，向信号中心<code>jQuery</code>发布<code>done</code>信号，从而引发<code>f2</code>的执行。</p>
<p><code>f2</code>完成执行后，可以取消订阅（unsubscribe）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jQuery.<span class="title function_">unsubscribe</span>(<span class="string">&#x27;done&#x27;</span>, f2);</span><br></pre></td></tr></table></figure>

<p>这种方法的性质与“事件监听”类似，但是明显优于后者。因为可以通过查看“消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。</p>
<h5 id="异步操作的流程控制"><a href="#异步操作的流程控制" class="headerlink" title="异步操作的流程控制"></a>异步操作的流程控制</h5><h6 id="串行执行"><a href="#串行执行" class="headerlink" title="串行执行"></a>串行执行</h6><p>即依次执行异步任务，一个做完了才能做下一个。如果有六个耗时一秒的任务串行执行，执行完需要六秒钟。</p>
<h6 id="并行执行"><a href="#并行执行" class="headerlink" title="并行执行"></a>并行执行</h6><p>即所有异步任务同时执行。如果有六个耗时一秒的任务并行执行，执行完只需要一秒钟。并行执行效率较高，但如果并行任务较多很容易耗尽系统资源，拖慢运行速度。</p>
<h6 id="并行与串行结合"><a href="#并行与串行结合" class="headerlink" title="并行与串行结合"></a>并行与串行结合</h6><p>即设置一个门槛，每次最多只能并行执行n个任务，避免过多占用系统资源，达到效率和资源的最佳平衡。</p>
<h4 id="Promise对象"><a href="#Promise对象" class="headerlink" title="Promise对象"></a>Promise对象</h4><h5 id="Promise-的含义"><a href="#Promise-的含义" class="headerlink" title="Promise 的含义"></a>Promise 的含义</h5><p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了<code>Promise</code>对象。</p>
<p>所谓<code>Promise</code>，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p>
<p><code>Promise</code>对象有以下两个特点。</p>
<p>（1）对象的状态不受外界影响。<code>Promise</code>对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是<code>Promise</code>这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</p>
<p>（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。<code>Promise</code>对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对<code>Promise</code>对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p>
<p>注意，为了行文方便，本章后面的<code>resolved</code>统一只指<code>fulfilled</code>状态，不包含<code>rejected</code>状态。</p>
<p>有了<code>Promise</code>对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，<code>Promise</code>对象提供统一的接口，使得控制异步操作更加容易。</p>
<p><code>Promise</code>也有一些缺点。首先，无法取消<code>Promise</code>，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，<code>Promise</code>内部抛出的错误，不会反应到外部。第三，当处于<code>pending</code>状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p>
<h5 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h5><p>ES6 规定，<code>Promise</code>对象是一个构造函数，用来生成<code>Promise</code>实例。</p>
<p>下面代码创造了一个<code>Promise</code>实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="comment">// ... some code</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</span><br><span class="line">    <span class="title function_">resolve</span>(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>Promise</code>构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。</p>
<p><code>resolve</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；<code>reject</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p>
<p><code>Promise</code>实例生成以后，可以用<code>then</code>方法分别指定<code>resolved</code>状态和<code>rejected</code>状态的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">promise.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125;, <span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="comment">// failure</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>then</code>方法可以接受两个回调函数作为参数。第一个回调函数是<code>Promise</code>对象的状态变为<code>resolved</code>时调用，第二个回调函数是<code>Promise</code>对象的状态变为<code>rejected</code>时调用。这两个函数都是可选的，不一定要提供。它们都接受<code>Promise</code>对象传出的值作为参数。</p>
<p>下面是一个<code>Promise</code>对象的简单例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">timeout</span>(<span class="params">ms</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, ms, <span class="string">&#x27;done&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">timeout</span>(<span class="number">100</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>timeout</code>方法返回一个<code>Promise</code>实例，表示一段时间以后才会发生的结果。过了指定的时间（<code>ms</code>参数）以后，<code>Promise</code>实例的状态变为<code>resolved</code>，就会触发<code>then</code>方法绑定的回调函数。</p>
<p>Promise 新建后就会立即执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Promise&#x27;</span>);</span><br><span class="line">  <span class="title function_">resolve</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;resolved.&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hi!&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise</span></span><br><span class="line"><span class="comment">// Hi!</span></span><br><span class="line"><span class="comment">// resolved</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，Promise 新建后立即执行，所以首先输出的是<code>Promise</code>。然后，<code>then</code>方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以<code>resolved</code>最后输出。</p>
<p>下面是异步加载图片的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">loadImageAsync</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> image = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line"></span><br><span class="line">    image.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(image);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    image.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Could not load image at &#x27;</span> + url));</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    image.<span class="property">src</span> = url;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，使用<code>Promise</code>包装了一个图片加载的异步操作。如果加载成功，就调用<code>resolve</code>方法，否则就调用<code>reject</code>方法。</p>
<p>下面是一个用<code>Promise</code>对象实现的 Ajax 操作的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getJSON = <span class="keyword">function</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> handler = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">readyState</span> !== <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="variable language_">this</span>.<span class="property">response</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="variable language_">this</span>.<span class="property">statusText</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> client = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">    client.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, url);</span><br><span class="line">    client.<span class="property">onreadystatechange</span> = handler;</span><br><span class="line">    client.<span class="property">responseType</span> = <span class="string">&quot;json&quot;</span>;</span><br><span class="line">    client.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">    client.<span class="title function_">send</span>();</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getJSON</span>(<span class="string">&quot;/posts.json&quot;</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">json</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Contents: &#x27;</span> + json);</span><br><span class="line">&#125;, <span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;出错了&#x27;</span>, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>getJSON</code>是对 XMLHttpRequest 对象的封装，用于发出一个针对 JSON 数据的 HTTP 请求，并且返回一个<code>Promise</code>对象。需要注意的是，在<code>getJSON</code>内部，<code>resolve</code>函数和<code>reject</code>函数调用时，都带有参数。</p>
<p>如果调用<code>resolve</code>函数和<code>reject</code>函数时带有参数，那么它们的参数会被传递给回调函数。<code>reject</code>函数的参数通常是<code>Error</code>对象的实例，表示抛出的错误；<code>resolve</code>函数的参数除了正常的值以外，还可能是另一个 Promise 实例，比如像下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="title function_">resolve</span>(p1);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>p1</code>和<code>p2</code>都是 Promise 的实例，但是<code>p2</code>的<code>resolve</code>方法将<code>p1</code>作为参数，即一个异步操作的结果是返回另一个异步操作。</p>
<p>注意，这时<code>p1</code>的状态就会传递给<code>p2</code>，也就是说，<code>p1</code>的状态决定了<code>p2</code>的状态。如果<code>p1</code>的状态是<code>pending</code>，那么<code>p2</code>的回调函数就会等待<code>p1</code>的状态改变；如果<code>p1</code>的状态已经是<code>resolved</code>或者<code>rejected</code>，那么<code>p2</code>的回调函数将会立刻执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;fail&#x27;</span>)), <span class="number">3000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(p1), <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p2</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(result))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(error))</span><br><span class="line"><span class="comment">// Error: fail</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>p1</code>是一个 Promise，3 秒之后变为<code>rejected</code>。<code>p2</code>的状态在 1 秒之后改变，<code>resolve</code>方法返回的是<code>p1</code>。由于<code>p2</code>返回的是另一个 Promise，导致<code>p2</code>自己的状态无效了，由<code>p1</code>的状态决定<code>p2</code>的状态。所以，后面的<code>then</code>语句都变成针对后者（<code>p1</code>）。又过了 2 秒，<code>p1</code>变为<code>rejected</code>，导致触发<code>catch</code>方法指定的回调函数。</p>
<p>注意，调用<code>resolve</code>或<code>reject</code>并不会终结 Promise 的参数函数的执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(r);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，调用<code>resolve(1)</code>以后，后面的<code>console.log(2)</code>还是会执行，并且会首先打印出来。这是因为立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。</p>
<p>一般来说，调用<code>resolve</code>或<code>reject</code>以后，Promise 的使命就完成了，后继操作应该放到<code>then</code>方法里面，而不应该直接写在<code>resolve</code>或<code>reject</code>的后面。所以，最好在它们前面加上<code>return</code>语句，这样就不会有意外。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">resolve</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 后面的语句不会执行</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h5><p>Promise 实例具有<code>then</code>方法，也就是说，<code>then</code>方法是定义在原型对象<code>Promise.prototype</code>上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，<code>then</code>方法的第一个参数是<code>resolved</code>状态的回调函数，第二个参数是<code>rejected</code>状态的回调函数，它们都是可选的。</p>
<p><code>then</code>方法返回的是一个新的<code>Promise</code>实例（注意，不是原来那个<code>Promise</code>实例）。因此可以采用链式写法，即<code>then</code>方法后面再调用另一个<code>then</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getJSON</span>(<span class="string">&quot;/posts.json&quot;</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">json</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> json.<span class="property">post</span>;</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">post</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面的代码使用<code>then</code>方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。</p>
<p>采用链式的<code>then</code>，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个<code>Promise</code>对象（即有异步操作），这时后一个回调函数，就会等待该<code>Promise</code>对象的状态发生变化，才会被调用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getJSON</span>(<span class="string">&quot;/post/1.json&quot;</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">post</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">getJSON</span>(post.<span class="property">commentURL</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">comments</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;resolved: &quot;</span>, comments);</span><br><span class="line">&#125;, <span class="keyword">function</span> (<span class="params">err</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;rejected: &quot;</span>, err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，第一个<code>then</code>方法指定的回调函数，返回的是另一个<code>Promise</code>对象。这时，第二个<code>then</code>方法指定的回调函数，就会等待这个新的<code>Promise</code>对象状态发生变化。如果变为<code>resolved</code>，就调用第一个回调函数，如果状态变为<code>rejected</code>，就调用第二个回调函数。</p>
<p>如果采用箭头函数，上面的代码可以写得更简洁。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getJSON</span>(<span class="string">&quot;/post/1.json&quot;</span>).<span class="title function_">then</span>(</span><br><span class="line">  <span class="function"><span class="params">post</span> =&gt;</span> <span class="title function_">getJSON</span>(post.<span class="property">commentURL</span>)</span><br><span class="line">).<span class="title function_">then</span>(</span><br><span class="line">  <span class="function"><span class="params">comments</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;resolved: &quot;</span>, comments),</span><br><span class="line">  <span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;rejected: &quot;</span>, err)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h5 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h5><p><code>Promise.prototype.catch()</code>方法是<code>.then(null, rejection)</code>或<code>.then(undefined, rejection)</code>的别名，用于指定发生错误时的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getJSON</span>(<span class="string">&#x27;/posts.json&#x27;</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">posts</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="comment">// 处理 getJSON 和 前一个回调函数运行时发生的错误</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;发生错误！&#x27;</span>, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>getJSON()</code>方法返回一个 Promise 对象，如果该对象状态变为<code>resolved</code>，则会调用<code>then()</code>方法指定的回调函数；如果异步操作抛出错误，状态就会变为<code>rejected</code>，就会调用<code>catch()</code>方法指定的回调函数，处理这个错误。另外，<code>then()</code>方法指定的回调函数，如果运行中抛出错误，也会被<code>catch()</code>方法捕获。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p.<span class="title function_">then</span>(<span class="function">(<span class="params">val</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fulfilled:&#x27;</span>, val))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;rejected&#x27;</span>, err));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function">(<span class="params">val</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fulfilled:&#x27;</span>, val))</span><br><span class="line">  .<span class="title function_">then</span>(<span class="literal">null</span>, <span class="function">(<span class="params">err</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;rejected:&quot;</span>, err));</span><br></pre></td></tr></table></figure>

<p>下面是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;test&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Error: test</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>promise</code>抛出一个错误，就被<code>catch()</code>方法指定的回调函数捕获。注意，上面的写法与下面两种写法是等价的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;test&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="title function_">reject</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">promise.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;test&#x27;</span>));</span><br><span class="line">&#125;);</span><br><span class="line">promise.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>比较上面两种写法，可以发现<code>reject()</code>方法的作用，等同于抛出错误。</p>
<p>如果 Promise 状态已经变成<code>resolved</code>，再抛出错误是无效的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;ok&#x27;</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;test&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">value</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(value) &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(error) &#125;);</span><br><span class="line"><span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，Promise 在<code>resolve</code>语句后面，再抛出错误，不会被捕获，等于没有抛出。因为 Promise 的状态一旦改变，就永久保持该状态，不会再变了。</p>
<p>Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个<code>catch</code>语句捕获。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getJSON</span>(<span class="string">&#x27;/post/1.json&#x27;</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">post</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">getJSON</span>(post.<span class="property">commentURL</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">comments</span>) &#123;</span><br><span class="line">  <span class="comment">// some code</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="comment">// 处理前面三个Promise产生的错误</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，一共有三个 Promise 对象：一个由<code>getJSON()</code>产生，两个由<code>then()</code>产生。它们之中任何一个抛出的错误，都会被最后一个<code>catch()</code>捕获。</p>
<p>一般来说，不要在<code>then()</code>方法里面定义 Reject 状态的回调函数（即<code>then</code>的第二个参数），总是使用<code>catch</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line">promise</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="comment">// success</span></span><br><span class="line">  &#125;, <span class="keyword">function</span>(<span class="params">err</span>) &#123;</span><br><span class="line">    <span class="comment">// error</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">promise</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">data</span>) &#123; <span class="comment">//cb</span></span><br><span class="line">    <span class="comment">// success</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">err</span>) &#123;</span><br><span class="line">    <span class="comment">// error</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，第二种写法要好于第一种写法，理由是第二种写法可以捕获前面<code>then</code>方法执行中的错误，也更接近同步的写法（<code>try/catch</code>）。因此，建议总是使用<code>catch()</code>方法，而不使用<code>then()</code>方法的第二个参数。</p>
<p>跟传统的<code>try/catch</code>代码块不同的是，如果没有使用<code>catch()</code>方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> someAsyncThing = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="comment">// 下面一行会报错，因为x没有声明</span></span><br><span class="line">    <span class="title function_">resolve</span>(x + <span class="number">2</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">someAsyncThing</span>().<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;everything is great&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">123</span>) &#125;, <span class="number">2000</span>);</span><br><span class="line"><span class="comment">// Uncaught (in promise) ReferenceError: x is not defined</span></span><br><span class="line"><span class="comment">// 123</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>someAsyncThing()</code>函数产生的 Promise 对象，内部有语法错误。浏览器运行到这一行，会打印出错误提示<code>ReferenceError: x is not defined</code>，但是不会退出进程、终止脚本执行，2 秒之后还是会输出<code>123</code>。这就是说，Promise 内部的错误不会影响到 Promise 外部的代码，通俗的说法就是“Promise 会吃掉错误”。</p>
<p>这个脚本放在服务器执行，退出码就是<code>0</code>（即表示执行成功）。不过，Node.js 有一个<code>unhandledRejection</code>事件，专门监听未捕获的<code>reject</code>错误，上面的脚本会触发这个事件的监听函数，可以在监听函数里面抛出错误。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">process.<span class="title function_">on</span>(<span class="string">&#x27;unhandledRejection&#x27;</span>, <span class="keyword">function</span> (<span class="params">err, p</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> err;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>unhandledRejection</code>事件的监听函数有两个参数，第一个是错误对象，第二个是报错的 Promise 实例，它可以用来了解发生错误的环境信息。</p>
<p>注意，Node 有计划在未来废除<code>unhandledRejection</code>事件。如果 Promise 内部有未捕获的错误，会直接终止进程，并且进程的退出码不为 0。</p>
<p>再看下面的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;ok&#x27;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;test&#x27;</span>) &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;);</span><br><span class="line">promise.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">value</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(value) &#125;);</span><br><span class="line"><span class="comment">// ok</span></span><br><span class="line"><span class="comment">// Uncaught Error: test</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，Promise 指定在下一轮“事件循环”再抛出错误。到了那个时候，Promise 的运行已经结束了，所以这个错误是在 Promise 函数体外抛出的，会冒泡到最外层，成了未捕获的错误。</p>
<p>一般总是建议，Promise 对象后面要跟<code>catch()</code>方法，这样可以处理 Promise 内部发生的错误。<code>catch()</code>方法返回的还是一个 Promise 对象，因此后面还可以接着调用<code>then()</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> someAsyncThing = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="comment">// 下面一行会报错，因为x没有声明</span></span><br><span class="line">    <span class="title function_">resolve</span>(x + <span class="number">2</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">someAsyncThing</span>()</span><br><span class="line">.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;oh no&#x27;</span>, error);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;carry on&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// oh no [ReferenceError: x is not defined]</span></span><br><span class="line"><span class="comment">// carry on</span></span><br></pre></td></tr></table></figure>

<p>上面代码运行完<code>catch()</code>方法指定的回调函数，会接着运行后面那个<code>then()</code>方法指定的回调函数。如果没有报错，则会跳过<code>catch()</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;oh no&#x27;</span>, error);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;carry on&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// carry on</span></span><br></pre></td></tr></table></figure>

<p>上面的代码因为没有报错，跳过了<code>catch()</code>方法，直接执行后面的<code>then()</code>方法。此时，要是<code>then()</code>方法里面报错，就与前面的<code>catch()</code>无关了。</p>
<p><code>catch()</code>方法之中，还能再抛出错误。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> someAsyncThing = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="comment">// 下面一行会报错，因为x没有声明</span></span><br><span class="line">    <span class="title function_">resolve</span>(x + <span class="number">2</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">someAsyncThing</span>().<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">someOtherAsyncThing</span>();</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;oh no&#x27;</span>, error);</span><br><span class="line">  <span class="comment">// 下面一行会报错，因为 y 没有声明</span></span><br><span class="line">  y + <span class="number">2</span>;</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;carry on&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// oh no [ReferenceError: x is not defined]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>catch()</code>方法抛出一个错误，因为后面没有别的<code>catch()</code>方法了，导致这个错误不会被捕获，也不会传递到外层。如果改写一下，结果就不一样了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">someAsyncThing</span>().<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">someOtherAsyncThing</span>();</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;oh no&#x27;</span>, error);</span><br><span class="line">  <span class="comment">// 下面一行会报错，因为y没有声明</span></span><br><span class="line">  y + <span class="number">2</span>;</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;carry on&#x27;</span>, error);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// oh no [ReferenceError: x is not defined]</span></span><br><span class="line"><span class="comment">// carry on [ReferenceError: y is not defined]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，第二个<code>catch()</code>方法用来捕获前一个<code>catch()</code>方法抛出的错误。</p>
<h5 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h5><p><code>finally()</code>方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">promise</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">.<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;···&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，不管<code>promise</code>最后的状态，在执行完<code>then</code>或<code>catch</code>指定的回调函数以后，都会执行<code>finally</code>方法指定的回调函数。</p>
<p>下面是一个例子，服务器使用 Promise 处理请求，然后使用<code>finally</code>方法关掉服务器。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server.<span class="title function_">listen</span>(port)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">finally</span>(server.<span class="property">stop</span>);</span><br></pre></td></tr></table></figure>

<p><code>finally</code>方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是<code>fulfilled</code>还是<code>rejected</code>。这表明，<code>finally</code>方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。</p>
<p><code>finally</code>本质上是<code>then</code>方法的特例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">promise</span><br><span class="line">.<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 语句</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">promise</span><br><span class="line">.<span class="title function_">then</span>(</span><br><span class="line">  <span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 语句</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 语句</span></span><br><span class="line">    <span class="keyword">throw</span> error;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>上面代码中，如果不使用<code>finally</code>方法，同样的语句需要为成功和失败两种情况各写一次。有了<code>finally</code>方法，则只需要写一次。</p>
<p>它的实现也很简单。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">finally</span> = <span class="keyword">function</span> (<span class="params">callback</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> P = <span class="variable language_">this</span>.<span class="property">constructor</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">then</span>(</span><br><span class="line">    <span class="function"><span class="params">value</span>  =&gt;</span> P.<span class="title function_">resolve</span>(<span class="title function_">callback</span>()).<span class="title function_">then</span>(<span class="function">() =&gt;</span> value),</span><br><span class="line">    <span class="function"><span class="params">reason</span> =&gt;</span> P.<span class="title function_">resolve</span>(<span class="title function_">callback</span>()).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123; <span class="keyword">throw</span> reason &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码中，不管前面的 Promise 是<code>fulfilled</code>还是<code>rejected</code>，都会执行回调函数<code>callback</code>。</p>
<p>从上面的实现还可以看到，<code>finally</code>方法总是会返回原来的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// resolve 的值是 undefined</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">2</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;&#125;, <span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// resolve 的值是 2</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">2</span>).<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// reject 的值是 undefined</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">3</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;&#125;, <span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// reject 的值是 3</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">3</span>).<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h5><p><code>Promise.all()</code>方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2, p3]);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Promise.all()</code>方法接受一个数组作为参数，<code>p1</code>、<code>p2</code>、<code>p3</code>都是 Promise 实例，如果不是，就会先调用下面讲到的<code>Promise.resolve</code>方法，将参数转为 Promise 实例，再进一步处理。另外，<code>Promise.all()</code>方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。</p>
<p><code>p</code>的状态由<code>p1</code>、<code>p2</code>、<code>p3</code>决定，分成两种情况。</p>
<p>（1）只有<code>p1</code>、<code>p2</code>、<code>p3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>，此时<code>p1</code>、<code>p2</code>、<code>p3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数。</p>
<p>（2）只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数。</p>
<p>下面是一个具体的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成一个Promise对象的数组</span></span><br><span class="line"><span class="keyword">const</span> promises = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>].<span class="title function_">map</span>(<span class="keyword">function</span> (<span class="params">id</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">getJSON</span>(<span class="string">&#x27;/post/&#x27;</span> + id + <span class="string">&quot;.json&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>(promises).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">posts</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">reason</span>)&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>promises</code>是包含 6 个 Promise 实例的数组，只有这 6 个实例的状态都变成<code>fulfilled</code>，或者其中有一个变为<code>rejected</code>，才会调用<code>Promise.all</code>方法后面的回调函数。</p>
<p>下面是另一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> databasePromise = <span class="title function_">connectDatabase</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> booksPromise = databasePromise</span><br><span class="line">  .<span class="title function_">then</span>(findAllBooks);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> userPromise = databasePromise</span><br><span class="line">  .<span class="title function_">then</span>(getCurrentUser);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([</span><br><span class="line">  booksPromise,</span><br><span class="line">  userPromise</span><br><span class="line">])</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">[books, user]</span>) =&gt;</span> <span class="title function_">pickTopRecommendations</span>(books, user));</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>booksPromise</code>和<code>userPromise</code>是两个异步操作，只有等到它们的结果都返回了，才会触发<code>pickTopRecommendations</code>这个回调函数。</p>
<p>注意，如果作为参数的 Promise 实例，自己定义了<code>catch</code>方法，那么它一旦被<code>rejected</code>，并不会触发<code>Promise.all()</code>的<code>catch</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> result)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> e);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;报错了&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> result)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> e);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2])</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(result))</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(e));</span><br><span class="line"><span class="comment">// [&quot;hello&quot;, Error: 报错了]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>p1</code>会<code>resolved</code>，<code>p2</code>首先会<code>rejected</code>，但是<code>p2</code>有自己的<code>catch</code>方法，该方法返回的是一个新的 Promise 实例，<code>p2</code>指向的实际上是这个实例。该实例执行完<code>catch</code>方法后，也会变成<code>resolved</code>，导致<code>Promise.all()</code>方法参数里面的两个实例都会<code>resolved</code>，因此会调用<code>then</code>方法指定的回调函数，而不会调用<code>catch</code>方法指定的回调函数。</p>
<p>如果<code>p2</code>没有自己的<code>catch</code>方法，就会调用<code>Promise.all()</code>的<code>catch</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> result);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;报错了&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> result);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2])</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(result))</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(e));</span><br><span class="line"><span class="comment">// Error: 报错了</span></span><br></pre></td></tr></table></figure>

<h5 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h5><p><code>Promise.race()</code>方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">race</span>([p1, p2, p3]);</span><br></pre></td></tr></table></figure>

<p>上面代码中，只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个实例率先改变状态，<code>p</code>的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给<code>p</code>的回调函数。</p>
<p><code>Promise.race()</code>方法的参数与<code>Promise.all()</code>方法一样，如果不是 Promise 实例，就会先调用下面讲到的<code>Promise.resolve()</code>方法，将参数转为 Promise 实例，再进一步处理。</p>
<p>下面是一个例子，如果指定时间内没有获得结果，就将 Promise 的状态变为<code>reject</code>，否则变为<code>resolve</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">race</span>([</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&#x27;/resource-that-may-take-a-while&#x27;</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;request timeout&#x27;</span>)), <span class="number">5000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">p</span><br><span class="line">.<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="variable language_">console</span>.<span class="property">error</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码中，如果 5 秒之内<code>fetch</code>方法无法返回结果，变量<code>p</code>的状态就会变为<code>rejected</code>，从而触发<code>catch</code>方法指定的回调函数。</p>
<h5 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled()"></a>Promise.allSettled()</h5><p>有时候，我们希望等到一组异步操作都结束了，不管每一个操作是成功还是失败，再进行下一步操作。但是，现有的 Promise 方法很难实现这个要求。</p>
<p><code>Promise.all()</code>方法只适合所有异步操作都成功的情况，如果有一个操作失败，就无法满足要求。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> urls = [url_1, url_2, url_3];</span><br><span class="line"><span class="keyword">const</span> requests = urls.<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> <span class="title function_">fetch</span>(x));</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(requests);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;所有请求都成功。&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;至少一个请求失败，其他请求可能还没结束。&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>Promise.all()</code>可以确定所有请求都成功了，但是只要有一个请求失败，它就会报错，而不管另外的请求是否结束。</p>
<p>为了解决这个问题，<a target="_blank" rel="noopener" href="https://github.com/tc39/proposal-promise-allSettled">ES2020</a> 引入了<code>Promise.allSettled()</code>方法，用来确定一组异步操作是否都结束了（不管成功或失败）。所以，它的名字叫做”Settled“，包含了”fulfilled“和”rejected“两种情况。</p>
<p><code>Promise.allSettled()</code>方法接受一个数组作为参数，数组的每个成员都是一个 Promise 对象，并返回一个新的 Promise 对象。只有等到参数数组的所有 Promise 对象都发生状态变更（不管是<code>fulfilled</code>还是<code>rejected</code>），返回的 Promise 对象才会发生状态变更。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promises = [</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&#x27;/api-1&#x27;</span>),</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&#x27;/api-2&#x27;</span>),</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&#x27;/api-3&#x27;</span>),</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">allSettled</span>(promises);</span><br><span class="line"><span class="title function_">removeLoadingIndicator</span>();</span><br></pre></td></tr></table></figure>

<p>上面示例中，数组<code>promises</code>包含了三个请求，只有等到这三个请求都结束了（不管请求成功还是失败），<code>removeLoadingIndicator()</code>才会执行。</p>
<p>该方法返回的新的 Promise 实例，一旦发生状态变更，状态总是<code>fulfilled</code>，不会变成<code>rejected</code>。状态变成<code>fulfilled</code>后，它的回调函数会接收到一个数组作为参数，该数组的每个成员对应前面数组的每个 Promise 对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resolved = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">42</span>);</span><br><span class="line"><span class="keyword">const</span> rejected = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> allSettledPromise = <span class="title class_">Promise</span>.<span class="title function_">allSettled</span>([resolved, rejected]);</span><br><span class="line"></span><br><span class="line">allSettledPromise.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">results</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(results);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">//    &#123; status: &#x27;fulfilled&#x27;, value: 42 &#125;,</span></span><br><span class="line"><span class="comment">//    &#123; status: &#x27;rejected&#x27;, reason: -1 &#125;</span></span><br><span class="line"><span class="comment">// ]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Promise.allSettled()</code>的返回值<code>allSettledPromise</code>，状态只可能变成<code>fulfilled</code>。它的回调函数接收到的参数是数组<code>results</code>。该数组的每个成员都是一个对象，对应传入<code>Promise.allSettled()</code>的数组里面的两个 Promise 对象。</p>
<p><code>results</code>的每个成员是一个对象，对象的格式是固定的，对应异步操作的结果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步操作成功时</span></span><br><span class="line">&#123;<span class="attr">status</span>: <span class="string">&#x27;fulfilled&#x27;</span>, <span class="attr">value</span>: value&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步操作失败时</span></span><br><span class="line">&#123;<span class="attr">status</span>: <span class="string">&#x27;rejected&#x27;</span>, <span class="attr">reason</span>: reason&#125;</span><br></pre></td></tr></table></figure>

<p>成员对象的<code>status</code>属性的值只可能是字符串<code>fulfilled</code>或字符串<code>rejected</code>，用来区分异步操作是成功还是失败。如果是成功（<code>fulfilled</code>），对象会有<code>value</code>属性，如果是失败（<code>rejected</code>），会有<code>reason</code>属性，对应两种状态时前面异步操作的返回值。</p>
<p>下面是返回值的用法例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promises = [ <span class="title function_">fetch</span>(<span class="string">&#x27;index.html&#x27;</span>), <span class="title function_">fetch</span>(<span class="string">&#x27;https://does-not-exist/&#x27;</span>) ];</span><br><span class="line"><span class="keyword">const</span> results = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">allSettled</span>(promises);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过滤出成功的请求</span></span><br><span class="line"><span class="keyword">const</span> successfulPromises = results.<span class="title function_">filter</span>(<span class="function"><span class="params">p</span> =&gt;</span> p.<span class="property">status</span> === <span class="string">&#x27;fulfilled&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过滤出失败的请求，并输出原因</span></span><br><span class="line"><span class="keyword">const</span> errors = results</span><br><span class="line">  .<span class="title function_">filter</span>(<span class="function"><span class="params">p</span> =&gt;</span> p.<span class="property">status</span> === <span class="string">&#x27;rejected&#x27;</span>)</span><br><span class="line">  .<span class="title function_">map</span>(<span class="function"><span class="params">p</span> =&gt;</span> p.<span class="property">reason</span>);</span><br></pre></td></tr></table></figure>

<h5 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any()"></a>Promise.any()</h5><p>ES2021 引入了<a target="_blank" rel="noopener" href="https://github.com/tc39/proposal-promise-any"><code>Promise.any()</code>方法</a>。该方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例返回。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">any</span>([</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&#x27;https://v8.dev/&#x27;</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="string">&#x27;home&#x27;</span>),</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&#x27;https://v8.dev/blog&#x27;</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="string">&#x27;blog&#x27;</span>),</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&#x27;https://v8.dev/docs&#x27;</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="string">&#x27;docs&#x27;</span>)</span><br><span class="line">]).<span class="title function_">then</span>(<span class="function">(<span class="params">first</span>) =&gt;</span> &#123;  <span class="comment">// 只要有一个 fetch() 请求成功</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(first);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123; <span class="comment">// 所有三个 fetch() 全部请求失败</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>只要参数实例有一个变成<code>fulfilled</code>状态，包装实例就会变成<code>fulfilled</code>状态；如果所有参数实例都变成<code>rejected</code>状态，包装实例就会变成<code>rejected</code>状态。</p>
<p><code>Promise.any()</code>跟<code>Promise.race()</code>方法很像，只有一点不同，就是<code>Promise.any()</code>不会因为某个 Promise 变成<code>rejected</code>状态而结束，必须等到所有参数 Promise 变成<code>rejected</code>状态才会结束。</p>
<p>下面是<code>Promise()</code>与<code>await</code>命令结合使用的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promises = [</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&#x27;/endpoint-a&#x27;</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="string">&#x27;a&#x27;</span>),</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&#x27;/endpoint-b&#x27;</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="string">&#x27;b&#x27;</span>),</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&#x27;/endpoint-c&#x27;</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="string">&#x27;c&#x27;</span>),</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> first = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">any</span>(promises);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(first);</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Promise.any()</code>方法的参数数组包含三个 Promise 操作。其中只要有一个变成<code>fulfilled</code>，<code>Promise.any()</code>返回的 Promise 对象就变成<code>fulfilled</code>。如果所有三个操作都变成<code>rejected</code>，那么<code>await</code>命令就会抛出错误。</p>
<p><code>Promise.any()</code>抛出的错误，不是一个一般的 Error 错误对象，而是一个 AggregateError 实例。它相当于一个数组，每个成员对应一个被<code>rejected</code>的操作所抛出的错误。下面是 AggregateError 的实现示例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new AggregateError() extends Array</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> err = <span class="keyword">new</span> <span class="title class_">AggregateError</span>();</span><br><span class="line">err.<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;first error&quot;</span>));</span><br><span class="line">err.<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;second error&quot;</span>));</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">throw</span> err;</span><br></pre></td></tr></table></figure>

<p>下面是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> resolved = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">42</span>);</span><br><span class="line"><span class="keyword">var</span> rejected = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(-<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> alsoRejected = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="title class_">Infinity</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">any</span>([resolved, rejected, alsoRejected]).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">result</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 42</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">any</span>([rejected, alsoRejected]).<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">results</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(results); <span class="comment">// [-1, Infinity]</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h5><p>有时需要将现有对象转为 Promise 对象，<code>Promise.resolve()</code>方法就起到这个作用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> jsPromise = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>($.<span class="title function_">ajax</span>(<span class="string">&#x27;/whatever.json&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>上面代码将 jQuery 生成的<code>deferred</code>对象，转为一个新的 Promise 对象。</p>
<p><code>Promise.resolve()</code>等价于下面的写法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="title function_">resolve</span>(<span class="string">&#x27;foo&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p><code>Promise.resolve()</code>方法的参数分成四种情况。</p>
<p><strong>（1）参数是一个 Promise 实例</strong></p>
<p>如果参数是 Promise 实例，那么<code>Promise.resolve</code>将不做任何修改、原封不动地返回这个实例。</p>
<p><strong>（2）参数是一个<code>thenable</code>对象</strong></p>
<p><code>thenable</code>对象指的是具有<code>then</code>方法的对象，比如下面这个对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> thenable = &#123;</span><br><span class="line">  <span class="attr">then</span>: <span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">42</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>Promise.resolve()</code>方法会将这个对象转为 Promise 对象，然后就立即执行<code>thenable</code>对象的<code>then()</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> thenable = &#123;</span><br><span class="line">  <span class="attr">then</span>: <span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">42</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(thenable);</span><br><span class="line">p1.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);  <span class="comment">// 42</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>thenable</code>对象的<code>then()</code>方法执行后，对象<code>p1</code>的状态就变为<code>resolved</code>，从而立即执行最后那个<code>then()</code>方法指定的回调函数，输出42。</p>
<p><strong>（3）参数不是具有<code>then()</code>方法的对象，或根本就不是对象</strong></p>
<p>如果参数是一个原始值，或者是一个不具有<code>then()</code>方法的对象，则<code>Promise.resolve()</code>方法返回一个新的 Promise 对象，状态为<code>resolved</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(s)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Hello</span></span><br></pre></td></tr></table></figure>

<p>上面代码生成一个新的 Promise 对象的实例<code>p</code>。由于字符串<code>Hello</code>不属于异步操作（判断方法是字符串对象不具有 then 方法），返回 Promise 实例的状态从一生成就是<code>resolved</code>，所以回调函数会立即执行。<code>Promise.resolve()</code>方法的参数，会同时传给回调函数。</p>
<p><strong>（4）不带有任何参数</strong></p>
<p><code>Promise.resolve()</code>方法允许调用时不带参数，直接返回一个<code>resolved</code>状态的 Promise 对象。</p>
<p>所以，如果希望得到一个 Promise 对象，比较方便的方法就是直接调用<code>Promise.resolve()</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>();</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码的变量<code>p</code>就是一个 Promise 对象。</p>
<p>需要注意的是，立即<code>resolve()</code>的 Promise 对象，是在本轮“事件循环”（event loop）的结束时执行，而不是在下一轮“事件循环”的开始时。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;three&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;two&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;one&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// one</span></span><br><span class="line"><span class="comment">// two</span></span><br><span class="line"><span class="comment">// three</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>setTimeout(fn, 0)</code>在下一轮“事件循环”开始时执行，<code>Promise.resolve()</code>在本轮“事件循环”结束时执行，<code>console.log(&#39;one&#39;)</code>则是立即执行，因此最先输出。</p>
<h5 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h5><p><code>Promise.reject(reason)</code>方法也会返回一个新的 Promise 实例，该实例的状态为<code>rejected</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="title function_">reject</span>(<span class="string">&#x27;出错了&#x27;</span>))</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="literal">null</span>, <span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(s)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 出错了</span></span><br></pre></td></tr></table></figure>

<p>上面代码生成一个 Promise 对象的实例<code>p</code>，状态为<code>rejected</code>，回调函数会立即执行。</p>
<p><code>Promise.reject()</code>方法的参数，会原封不动地作为<code>reject</code>的理由，变成后续方法的参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;出错了&#x27;</span>)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e === <span class="string">&#x27;出错了&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Promise.reject()</code>方法的参数是一个字符串，后面<code>catch()</code>方法的参数<code>e</code>就是这个字符串。</p>
<h5 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h5><h5 id="加载图片"><a href="#加载图片" class="headerlink" title="加载图片"></a>加载图片</h5><p>我们可以将图片的加载写成一个<code>Promise</code>，一旦加载完成，<code>Promise</code>的状态就发生变化。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> preloadImage = <span class="keyword">function</span> (<span class="params">path</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> image = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line">    image.<span class="property">onload</span>  = resolve;</span><br><span class="line">    image.<span class="property">onerror</span> = reject;</span><br><span class="line">    image.<span class="property">src</span> = path;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="Generator-函数与-Promise-的结合"><a href="#Generator-函数与-Promise-的结合" class="headerlink" title="Generator 函数与 Promise 的结合"></a>Generator 函数与 Promise 的结合</h5><p>使用 Generator 函数管理流程，遇到异步操作的时候，通常返回一个<code>Promise</code>对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getFoo</span> () &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>)&#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> g = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> foo = <span class="keyword">yield</span> <span class="title function_">getFoo</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(foo);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">run</span> (generator) &#123;</span><br><span class="line">  <span class="keyword">const</span> it = <span class="title function_">generator</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">go</span>(<span class="params">result</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (result.<span class="property">done</span>) <span class="keyword">return</span> result.<span class="property">value</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result.<span class="property">value</span>.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">go</span>(it.<span class="title function_">next</span>(value));</span><br><span class="line">    &#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">go</span>(it.<span class="keyword">throw</span>(error));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">go</span>(it.<span class="title function_">next</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">run</span>(g);</span><br></pre></td></tr></table></figure>

<p>上面代码的 Generator 函数<code>g</code>之中，有一个异步操作<code>getFoo</code>，它返回的就是一个<code>Promise</code>对象。函数<code>run</code>用来处理这个<code>Promise</code>对象，并调用下一个<code>next</code>方法。</p>
<h5 id="Promise-try"><a href="#Promise-try" class="headerlink" title="Promise.try()"></a>Promise.try()</h5><p>实际开发中，经常遇到一种情况：不知道或者不想区分，函数<code>f</code>是同步函数还是异步操作，但是想用 Promise 来处理它。因为这样就可以不管<code>f</code>是否包含异步操作，都用<code>then</code>方法指定下一步流程，用<code>catch</code>方法处理<code>f</code>抛出的错误。一般就会采用下面的写法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(f)</span><br></pre></td></tr></table></figure>

<p>上面的写法有一个缺点，就是如果<code>f</code>是同步函数，那么它会在本轮事件循环的末尾执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">f</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;now&#x27;</span>);</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(f);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;next&#x27;</span>);</span><br><span class="line"><span class="comment">// next</span></span><br><span class="line"><span class="comment">// now</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，函数<code>f</code>是同步的，但是用 Promise 包装了以后，就变成异步执行了。</p>
<p>那么有没有一种方法，让同步函数同步执行，异步函数异步执行，并且让它们具有统一的 API 呢？回答是可以的，并且还有两种写法。第一种写法是用<code>async</code>函数来写。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">f</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;now&#x27;</span>);</span><br><span class="line">(<span class="keyword">async</span> () =&gt; <span class="title function_">f</span>())();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;next&#x27;</span>);</span><br><span class="line"><span class="comment">// now</span></span><br><span class="line"><span class="comment">// next</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，第二行是一个立即执行的匿名函数，会立即执行里面的<code>async</code>函数，因此如果<code>f</code>是同步的，就会得到同步的结果；如果<code>f</code>是异步的，就可以用<code>then</code>指定下一步，就像下面的写法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; <span class="title function_">f</span>())()</span><br><span class="line">.<span class="title function_">then</span>(...)</span><br></pre></td></tr></table></figure>

<p>需要注意的是，<code>async () =&gt; f()</code>会吃掉<code>f()</code>抛出的错误。所以，如果想捕获错误，要使用<code>promise.catch</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; <span class="title function_">f</span>())()</span><br><span class="line">.<span class="title function_">then</span>(...)</span><br><span class="line">.<span class="title function_">catch</span>(...)</span><br></pre></td></tr></table></figure>

<p>第二种写法是使用<code>new Promise()</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">f</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;now&#x27;</span>);</span><br><span class="line">(</span><br><span class="line">  <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(</span><br><span class="line">    <span class="function"><span class="params">resolve</span> =&gt;</span> <span class="title function_">resolve</span>(<span class="title function_">f</span>())</span><br><span class="line">  )</span><br><span class="line">)();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;next&#x27;</span>);</span><br><span class="line"><span class="comment">// now</span></span><br><span class="line"><span class="comment">// next</span></span><br></pre></td></tr></table></figure>

<p>上面代码也是使用立即执行的匿名函数，执行<code>new Promise()</code>。这种情况下，同步函数也是同步执行的。</p>
<p>鉴于这是一个很常见的需求，所以现在有一个<a target="_blank" rel="noopener" href="https://github.com/ljharb/proposal-promise-try">提案</a>，提供<code>Promise.try</code>方法替代上面的写法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">f</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;now&#x27;</span>);</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">try</span>(f);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;next&#x27;</span>);</span><br><span class="line"><span class="comment">// now</span></span><br><span class="line"><span class="comment">// next</span></span><br></pre></td></tr></table></figure>

<p>事实上，<code>Promise.try</code>存在已久，Promise 库<a target="_blank" rel="noopener" href="http://bluebirdjs.com/docs/api/promise.try.html"><code>Bluebird</code></a>、<a target="_blank" rel="noopener" href="https://github.com/kriskowal/q/wiki/API-Reference#promisefcallargs"><code>Q</code></a>和<a target="_blank" rel="noopener" href="https://github.com/cujojs/when/blob/master/docs/api.md#whentry"><code>when</code></a>，早就提供了这个方法。</p>
<p>由于<code>Promise.try</code>为所有操作提供了统一的处理机制，所以如果想用<code>then</code>方法管理流程，最好都用<code>Promise.try</code>包装一下。这样有<a target="_blank" rel="noopener" href="http://cryto.net/~joepie91/blog/2016/05/11/what-is-promise-try-and-why-does-it-matter/">许多好处</a>，其中一点就是可以更好地管理异常。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getUsername</span>(<span class="params">userId</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> database.<span class="property">users</span>.<span class="title function_">get</span>(&#123;<span class="attr">id</span>: userId&#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">user</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> user.<span class="property">name</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>database.users.get()</code>返回一个 Promise 对象，如果抛出异步错误，可以用<code>catch</code>方法捕获，就像下面这样写。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">database.<span class="property">users</span>.<span class="title function_">get</span>(&#123;<span class="attr">id</span>: userId&#125;)</span><br><span class="line">.<span class="title function_">then</span>(...)</span><br><span class="line">.<span class="title function_">catch</span>(...)</span><br></pre></td></tr></table></figure>

<p>但是<code>database.users.get()</code>可能还会抛出同步错误（比如数据库连接错误，具体要看实现方法），这时你就不得不用<code>try...catch</code>去捕获。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  database.<span class="property">users</span>.<span class="title function_">get</span>(&#123;<span class="attr">id</span>: userId&#125;)</span><br><span class="line">  .<span class="title function_">then</span>(...)</span><br><span class="line">  .<span class="title function_">catch</span>(...)</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这样的写法就很笨拙了，这时就可以统一用<code>promise.catch()</code>捕获所有同步和异步的错误。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">try</span>(<span class="function">() =&gt;</span> database.<span class="property">users</span>.<span class="title function_">get</span>(&#123;<span class="attr">id</span>: userId&#125;))</span><br><span class="line">  .<span class="title function_">then</span>(...)</span><br><span class="line">  .<span class="title function_">catch</span>(...)</span><br></pre></td></tr></table></figure>

<p>事实上，<code>Promise.try</code>就是模拟<code>try</code>代码块，就像<code>promise.catch</code>模拟的是<code>catch</code>代码块。</p>
<h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>浏览器与服务器之间，采用 HTTP 协议通信。用户在浏览器地址栏键入一个网址，或者通过网页表单向服务器提交内容，这时浏览器就会向服务器发出 HTTP 请求。</p>
<p>1999年，微软公司发布 IE 浏览器5.0版，第一次引入新功能：允许 JavaScript 脚本向服务器发起 HTTP 请求。这个功能当时并没有引起注意，直到2004年 Gmail 发布和2005年 Google Map 发布，才引起广泛重视。2005年2月，AJAX 这个词第一次正式提出，它是 Asynchronous JavaScript and XML 的缩写，指的是通过 JavaScript 的异步通信，从服务器获取 XML 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。后来，AJAX 这个词就成为 JavaScript 脚本发起 HTTP 通信的代名词，也就是说，只要用脚本发起通信，就可以叫做 AJAX 通信。W3C 也在2006年发布了它的国际标准。</p>
<p>具体来说，AJAX 包括以下几个步骤。</p>
<ol>
<li>创建 XMLHttpRequest 实例</li>
<li>发出 HTTP 请求</li>
<li>接收服务器传回的数据</li>
<li>更新网页数据</li>
</ol>
<p>概括起来，就是一句话，AJAX 通过原生的<code>XMLHttpRequest</code>对象发出 HTTP 请求，得到服务器返回的数据后，再进行处理。现在，服务器返回的都是 JSON 格式的数据，XML 格式已经过时了，但是 AJAX 这个名字已经成了一个通用名词，字面含义已经消失了。</p>
<p><code>XMLHttpRequest</code>对象是 AJAX 的主要接口，用于浏览器与服务器之间的通信。尽管名字里面有<code>XML</code>和<code>Http</code>，它实际上可以使用多种协议（比如<code>file</code>或<code>ftp</code>），发送任何格式的数据（包括字符串和二进制）。</p>
<p><code>XMLHttpRequest</code>本身是一个构造函数，可以使用<code>new</code>命令生成实例。它没有任何参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br></pre></td></tr></table></figure>

<p>一旦新建实例，就可以使用<code>open()</code>方法指定建立 HTTP 连接的一些细节。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;http://www.example.com/page.php&#x27;</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码指定使用 GET 方法，跟指定的服务器网址建立连接。第三个参数<code>true</code>，表示请求是异步的。</p>
<p>然后，指定回调函数，监听通信状态（<code>readyState</code>属性）的变化。一般会监听当readyState为4时（表示成功发送请求并接收到响应）的事件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="property">onreadystatechange</span> = handleStateChange;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleStateChange</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，一旦<code>XMLHttpRequest</code>实例的状态发生变化，就会调用监听函数<code>handleStateChange</code></p>
<p>最后使用<code>send()</code>方法，实际发出请求。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>send()</code>的参数为<code>null</code>，表示发送请求的时候，不带有数据体。如果发送的是 POST 请求，这里就需要指定数据体。</p>
<p>一旦拿到服务器返回的数据，AJAX 不会刷新整个网页，而是只更新网页里面的相关部分，从而不打断用户正在做的事情。</p>
<p>注意，AJAX 只能向同源网址（协议、域名、端口都相同）发出 HTTP 请求，如果发出跨域请求，就会报错（详见《同源政策》和《CORS 通信》两章）。</p>
<p>下面是<code>XMLHttpRequest</code>对象简单用法的完整例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"></span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">// 通信成功时，状态值为4</span></span><br><span class="line">  <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.<span class="property">status</span> === <span class="number">200</span>)&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">responseText</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(xhr.<span class="property">statusText</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(xhr.<span class="property">statusText</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;/endpoint&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<h3 id="XMLHttpRequest-的实例属性"><a href="#XMLHttpRequest-的实例属性" class="headerlink" title="XMLHttpRequest 的实例属性"></a>XMLHttpRequest 的实例属性</h3><h3 id="XMLHttpRequest-readyState"><a href="#XMLHttpRequest-readyState" class="headerlink" title="XMLHttpRequest.readyState"></a>XMLHttpRequest.readyState</h3><p><code>XMLHttpRequest.readyState</code>返回一个整数，表示实例对象的当前状态。该属性只读。它可能返回以下值。</p>
<ul>
<li>0，表示 XMLHttpRequest 实例已经生成，但是实例的<code>open()</code>方法还没有被调用。</li>
<li>1，表示<code>open()</code>方法已经调用，但是实例的<code>send()</code>方法还没有调用，仍然可以使用实例的<code>setRequestHeader()</code>方法，设定 HTTP 请求的头信息。</li>
<li>2，表示实例的<code>send()</code>方法已经调用，并且服务器返回的头信息和状态码已经收到。</li>
<li>3，表示正在接收服务器传来的数据体（body 部分）。这时，如果实例的<code>responseType</code>属性等于<code>text</code>或者空字符串，<code>responseText</code>属性就会包含已经收到的部分信息。</li>
<li>4，表示服务器返回的数据已经完全接收，或者本次接收已经失败。</li>
</ul>
<p>通信过程中，每当实例对象发生状态变化，它的<code>readyState</code>属性的值就会改变。这个值每一次变化，都会触发<code>readyStateChange</code>事件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span><br><span class="line">  <span class="comment">// 请求结束，处理服务器返回的数据</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 显示提示“加载中……”</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>xhr.readyState</code>等于<code>4</code>时，表明脚本发出的 HTTP 请求已经完成。其他情况，都表示 HTTP 请求还在进行中。</p>
<h3 id="XMLHttpRequest-onreadystatechange"><a href="#XMLHttpRequest-onreadystatechange" class="headerlink" title="XMLHttpRequest.onreadystatechange"></a>XMLHttpRequest.onreadystatechange</h3><p><code>XMLHttpRequest.onreadystatechange</code>属性指向一个监听函数。<code>readystatechange</code>事件发生时（实例的<code>readyState</code>属性变化），就会执行这个属性。</p>
<p>另外，如果使用实例的<code>abort()</code>方法，终止 XMLHttpRequest 请求，也会造成<code>readyState</code>属性变化，导致调用<code>XMLHttpRequest.onreadystatechange</code>属性。</p>
<p>下面是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_">open</span>( <span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;http://example.com&#x27;</span> , <span class="literal">true</span> );</span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.<span class="property">readyState</span> !== <span class="number">4</span> || xhr.<span class="property">status</span> !== <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">responseText</span>);</span><br><span class="line">&#125;;</span><br><span class="line">xhr.<span class="title function_">send</span>();</span><br></pre></td></tr></table></figure>

<h3 id="XMLHttpRequest-response"><a href="#XMLHttpRequest-response" class="headerlink" title="XMLHttpRequest.response"></a>XMLHttpRequest.response</h3><p><code>XMLHttpRequest.response</code>属性表示服务器返回的数据体（即 HTTP 回应的 body 部分）。它可能是任何数据类型，比如字符串、对象、二进制对象等等，具体的类型由<code>XMLHttpRequest.responseType</code>属性决定。该属性只读。</p>
<p>如果本次请求没有成功或者数据不完整，该属性等于<code>null</code>。但是，如果<code>responseType</code>属性等于<code>text</code>或空字符串，在请求没有结束之前（<code>readyState</code>等于3的阶段），<code>response</code>属性包含服务器已经返回的部分数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"></span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="title function_">handler</span>(xhr.<span class="property">response</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="XMLHttpRequest-responseType"><a href="#XMLHttpRequest-responseType" class="headerlink" title="XMLHttpRequest.responseType"></a>XMLHttpRequest.responseType</h3><p><code>XMLHttpRequest.responseType</code>属性是一个字符串，表示服务器返回数据的类型。这个属性是可写的，可以在调用<code>open()</code>方法之后、调用<code>send()</code>方法之前，设置这个属性的值，告诉浏览器如何解读返回的数据。如果<code>responseType</code>设为空字符串，就等同于默认值<code>text</code>。</p>
<p><code>XMLHttpRequest.responseType</code>属性可以等于以下值。</p>
<ul>
<li>“”（空字符串）：等同于<code>text</code>，表示服务器返回文本数据。</li>
<li>“arraybuffer”：ArrayBuffer 对象，表示服务器返回二进制数组。</li>
<li>“blob”：Blob 对象，表示服务器返回二进制对象。</li>
<li>“document”：Document 对象，表示服务器返回一个文档对象。</li>
<li>“json”：JSON 对象。</li>
<li>“text”：字符串。</li>
</ul>
<p>上面几种类型之中，<code>text</code>类型适合大多数情况，而且直接处理文本也比较方便。<code>document</code>类型适合返回 HTML &#x2F; XML 文档的情况，这意味着，对于那些打开 CORS 的网站，可以直接用 Ajax 抓取网页，然后不用解析 HTML 字符串，直接对抓取回来的数据进行 DOM 操作。<code>blob</code>类型适合读取二进制数据，比如图片文件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;/path/to/image.png&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.<span class="property">responseType</span> = <span class="string">&#x27;blob&#x27;</span>;</span><br><span class="line"></span><br><span class="line">xhr.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> blob = <span class="keyword">new</span> <span class="title class_">Blob</span>([xhr.<span class="property">response</span>], &#123;<span class="attr">type</span>: <span class="string">&#x27;image/png&#x27;</span>&#125;);</span><br><span class="line">    <span class="comment">// 或者</span></span><br><span class="line">    <span class="keyword">var</span> blob = xhr.<span class="property">response</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.<span class="title function_">send</span>();</span><br></pre></td></tr></table></figure>

<p>如果将这个属性设为<code>ArrayBuffer</code>，就可以按照数组的方式处理二进制数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;/path/to/image.png&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.<span class="property">responseType</span> = <span class="string">&#x27;arraybuffer&#x27;</span>;</span><br><span class="line"></span><br><span class="line">xhr.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> uInt8Array = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(<span class="variable language_">this</span>.<span class="property">response</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = uInt8Array.<span class="property">length</span>; i &lt; len; ++i) &#123;</span><br><span class="line">    <span class="comment">// var byte = uInt8Array[i];</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.<span class="title function_">send</span>();</span><br></pre></td></tr></table></figure>

<p>如果将这个属性设为<code>json</code>，浏览器就会自动对返回数据调用<code>JSON.parse()</code>方法。也就是说，从<code>xhr.response</code>属性（注意，不是<code>xhr.responseText</code>属性）得到的不是文本，而是一个 JSON 对象。</p>
<h3 id="XMLHttpRequest-responseText"><a href="#XMLHttpRequest-responseText" class="headerlink" title="XMLHttpRequest.responseText"></a>XMLHttpRequest.responseText</h3><p><code>XMLHttpRequest.responseText</code>属性返回从服务器接收到的字符串，该属性为只读。只有 HTTP 请求完成接收以后，该属性才会包含完整的数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;/server&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">xhr.<span class="property">responseType</span> = <span class="string">&#x27;text&#x27;</span>;</span><br><span class="line">xhr.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span> &amp;&amp; xhr.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">responseText</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<h3 id="XMLHttpRequest-responseXML"><a href="#XMLHttpRequest-responseXML" class="headerlink" title="XMLHttpRequest.responseXML"></a>XMLHttpRequest.responseXML</h3><p><code>XMLHttpRequest.responseXML</code>属性返回从服务器接收到的 HTML 或 XML 文档对象，该属性为只读。如果本次请求没有成功，或者收到的数据不能被解析为 XML 或 HTML，该属性等于<code>null</code>。</p>
<p>该属性生效的前提是 HTTP 回应的<code>Content-Type</code>头信息等于<code>text/xml</code>或<code>application/xml</code>。这要求在发送请求前，<code>XMLHttpRequest.responseType</code>属性要设为<code>document</code>。如果 HTTP 回应的<code>Content-Type</code>头信息不等于<code>text/xml</code>和<code>application/xml</code>，但是想从<code>responseXML</code>拿到数据（即把数据按照 DOM 格式解析），那么需要手动调用<code>XMLHttpRequest.overrideMimeType()</code>方法，强制进行 XML 解析。</p>
<p>该属性得到的数据，是直接解析后的文档 DOM 树。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;/server&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">xhr.<span class="property">responseType</span> = <span class="string">&#x27;document&#x27;</span>;</span><br><span class="line">xhr.<span class="title function_">overrideMimeType</span>(<span class="string">&#x27;text/xml&#x27;</span>);</span><br><span class="line"></span><br><span class="line">xhr.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span> &amp;&amp; xhr.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">responseXML</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<h3 id="XMLHttpRequest-responseURL"><a href="#XMLHttpRequest-responseURL" class="headerlink" title="XMLHttpRequest.responseURL"></a>XMLHttpRequest.responseURL</h3><p><code>XMLHttpRequest.responseURL</code>属性是字符串，表示发送数据的服务器的网址。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;http://example.com/test&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 返回 http://example.com/test</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">responseURL</span>);</span><br><span class="line">&#125;;</span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p>注意，这个属性的值与<code>open()</code>方法指定的请求网址不一定相同。如果服务器端发生跳转，这个属性返回最后实际返回数据的网址。另外，如果原始 URL 包括锚点（fragment），该属性会把锚点剥离。</p>
<h3 id="XMLHttpRequest-status，XMLHttpRequest-statusText"><a href="#XMLHttpRequest-status，XMLHttpRequest-statusText" class="headerlink" title="XMLHttpRequest.status，XMLHttpRequest.statusText"></a>XMLHttpRequest.status，XMLHttpRequest.statusText</h3><p><code>XMLHttpRequest.status</code>属性返回一个整数，表示服务器回应的 HTTP 状态码。一般来说，如果通信成功的话，这个状态码是200；如果服务器没有返回状态码，那么这个属性默认是200。请求发出之前，该属性为<code>0</code>。该属性只读。</p>
<ul>
<li>200, OK，访问正常</li>
<li>301, Moved Permanently，永久移动</li>
<li>302, Moved temporarily，暂时移动</li>
<li>304, Not Modified，未修改</li>
<li>307, Temporary Redirect，暂时重定向</li>
<li>401, Unauthorized，未授权</li>
<li>403, Forbidden，禁止访问</li>
<li>404, Not Found，未发现指定网址</li>
<li>500, Internal Server Error，服务器发生错误</li>
</ul>
<p>基本上，只有2xx和304的状态码，表示服务器返回是正常状态。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> ( (xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>)</span><br><span class="line">    || (xhr.<span class="property">status</span> === <span class="number">304</span>) ) &#123;</span><br><span class="line">    <span class="comment">// 处理服务器的返回数据</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 出错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>XMLHttpRequest.statusText</code>属性返回一个字符串，表示服务器发送的状态提示。不同于<code>status</code>属性，该属性包含整个状态信息，比如“OK”和“Not Found”。在请求发送之前（即调用<code>open()</code>方法之前），该属性的值是空字符串；如果服务器没有返回状态提示，该属性的值默认为“OK”。该属性为只读属性。</p>
<h3 id="XMLHttpRequest-timeout，XMLHttpRequestEventTarget-ontimeout"><a href="#XMLHttpRequest-timeout，XMLHttpRequestEventTarget-ontimeout" class="headerlink" title="XMLHttpRequest.timeout，XMLHttpRequestEventTarget.ontimeout"></a>XMLHttpRequest.timeout，XMLHttpRequestEventTarget.ontimeout</h3><p><code>XMLHttpRequest.timeout</code>属性返回一个整数，表示多少毫秒后，如果请求仍然没有得到结果，就会自动终止。如果该属性等于0，就表示没有时间限制。</p>
<p><code>XMLHttpRequestEventTarget.ontimeout</code>属性用于设置一个监听函数，如果发生 timeout 事件，就会执行这个监听函数。</p>
<p>下面是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"><span class="keyword">var</span> url = <span class="string">&#x27;/server&#x27;</span>;</span><br><span class="line"></span><br><span class="line">xhr.<span class="property">ontimeout</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;The request for &#x27;</span> + url + <span class="string">&#x27; timed out.&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="comment">// 处理服务器返回的数据</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(xhr.<span class="property">statusText</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, url, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 指定 10 秒钟超时</span></span><br><span class="line">xhr.<span class="property">timeout</span> = <span class="number">10</span> * <span class="number">1000</span>;</span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<h3 id="事件监听属性"><a href="#事件监听属性" class="headerlink" title="事件监听属性"></a>事件监听属性</h3><p>XMLHttpRequest 对象可以对以下事件指定监听函数。</p>
<ul>
<li>XMLHttpRequest.onloadstart：loadstart 事件（HTTP 请求发出）的监听函数</li>
<li>XMLHttpRequest.onprogress：progress事件（正在发送和加载数据）的监听函数</li>
<li>XMLHttpRequest.onabort：abort 事件（请求中止，比如用户调用了<code>abort()</code>方法）的监听函数</li>
<li>XMLHttpRequest.onerror：error 事件（请求失败）的监听函数</li>
<li>XMLHttpRequest.onload：load 事件（请求成功完成）的监听函数</li>
<li>XMLHttpRequest.ontimeout：timeout 事件（用户指定的时限超过了，请求还未完成）的监听函数</li>
<li>XMLHttpRequest.onloadend：loadend 事件（请求完成，不管成功或失败）的监听函数</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">var</span> responseText = xhr.<span class="property">responseText</span>;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(responseText);</span><br><span class="line"> <span class="comment">// process the response.</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.<span class="property">onabort</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;The request was aborted&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.<span class="property">onprogress</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">loaded</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">total</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;There was an error!&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>progress</code>事件的监听函数有一个事件对象参数，该对象有三个属性：<code>loaded</code>属性返回已经传输的数据量，<code>total</code>属性返回总的数据量，<code>lengthComputable</code>属性返回一个布尔值，表示加载的进度是否可以计算。所有这些监听函数里面，只有<code>progress</code>事件的监听函数有参数，其他函数都没有参数。</p>
<p>注意，如果发生网络错误（比如服务器无法连通），<code>onerror</code>事件无法获取报错信息。也就是说，可能没有错误对象，所以这样只能显示报错的提示。</p>
<h3 id="XMLHttpRequest-withCredentials"><a href="#XMLHttpRequest-withCredentials" class="headerlink" title="XMLHttpRequest.withCredentials"></a>XMLHttpRequest.withCredentials</h3><p><code>XMLHttpRequest.withCredentials</code>属性是一个布尔值，表示跨域请求时，用户信息（比如 Cookie 和认证的 HTTP 头信息）是否会包含在请求之中，默认为<code>false</code>，即向<code>example.com</code>发出跨域请求时，不会发送<code>example.com</code>设置在本机上的 Cookie（如果有的话）。</p>
<p>如果需要跨域 AJAX 请求发送 Cookie，需要<code>withCredentials</code>属性设为<code>true</code>。注意，同源的请求不需要设置这个属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;http://example.com/&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.<span class="property">withCredentials</span> = <span class="literal">true</span>;</span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p>为了让这个属性生效，服务器必须显式返回<code>Access-Control-Allow-Credentials</code>这个头信息。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Credentials</span>: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><code>withCredentials</code>属性打开的话，跨域请求不仅会发送 Cookie，还会设置远程主机指定的 Cookie。反之也成立，如果<code>withCredentials</code>属性没有打开，那么跨域的 AJAX 请求即使明确要求浏览器设置 Cookie，浏览器也会忽略。</p>
<p>注意，脚本总是遵守同源政策，无法从<code>document.cookie</code>或者 HTTP 回应的头信息之中，读取跨域的 Cookie，<code>withCredentials</code>属性不影响这一点。</p>
<h3 id="XMLHttpRequest-upload"><a href="#XMLHttpRequest-upload" class="headerlink" title="XMLHttpRequest.upload"></a>XMLHttpRequest.upload</h3><p>XMLHttpRequest 不仅可以发送请求，还可以发送文件，这就是 AJAX 文件上传。发送文件以后，通过<code>XMLHttpRequest.upload</code>属性可以得到一个对象，通过观察这个对象，可以得知上传的进展。主要方法就是监听这个对象的各种事件：loadstart、loadend、load、abort、error、progress、timeout。</p>
<p>假定网页上有一个<code>&lt;progress&gt;</code>元素。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;progress min=&quot;0&quot; max=&quot;100&quot; value=&quot;0&quot;&gt;0% complete&lt;/progress&gt;</span><br></pre></td></tr></table></figure>

<p>文件上传时，对<code>upload</code>属性指定<code>progress</code>事件的监听函数，即可获得上传的进度。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">upload</span>(<span class="params">blobOrFile</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">  xhr.<span class="title function_">open</span>(<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;/server&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">  xhr.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params">e</span>) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> progressBar = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;progress&#x27;</span>);</span><br><span class="line">  xhr.<span class="property">upload</span>.<span class="property">onprogress</span> = <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e.<span class="property">lengthComputable</span>) &#123;</span><br><span class="line">      progressBar.<span class="property">value</span> = (e.<span class="property">loaded</span> / e.<span class="property">total</span>) * <span class="number">100</span>;</span><br><span class="line">      <span class="comment">// 兼容不支持 &lt;progress&gt; 元素的老式浏览器</span></span><br><span class="line">      progressBar.<span class="property">textContent</span> = progressBar.<span class="property">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  xhr.<span class="title function_">send</span>(blobOrFile);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">upload</span>(<span class="keyword">new</span> <span class="title class_">Blob</span>([<span class="string">&#x27;hello world&#x27;</span>], &#123;<span class="attr">type</span>: <span class="string">&#x27;text/plain&#x27;</span>&#125;));</span><br></pre></td></tr></table></figure>

<h3 id="XMLHttpRequest-的实例方法"><a href="#XMLHttpRequest-的实例方法" class="headerlink" title="XMLHttpRequest 的实例方法"></a>XMLHttpRequest 的实例方法</h3><h3 id="XMLHttpRequest-open"><a href="#XMLHttpRequest-open" class="headerlink" title="XMLHttpRequest.open()"></a>XMLHttpRequest.open()</h3><p><code>XMLHttpRequest.open()</code>方法用于指定 HTTP 请求的参数，或者说初始化 XMLHttpRequest 实例对象。它一共可以接受五个参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">open</span>(</span><br><span class="line">   string method,</span><br><span class="line">   string url,</span><br><span class="line">   optional boolean <span class="keyword">async</span>,</span><br><span class="line">   optional string user,</span><br><span class="line">   optional string password</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>method</code>：表示 HTTP 动词方法，比如<code>GET</code>、<code>POST</code>、<code>PUT</code>、<code>DELETE</code>、<code>HEAD</code>等。</li>
<li><code>url</code>: 表示请求发送目标 URL。</li>
<li><code>async</code>: 布尔值，表示请求是否为异步，默认为<code>true</code>。如果设为<code>false</code>，则<code>send()</code>方法只有等到收到服务器返回了结果，才会进行下一步操作。该参数可选。由于同步 AJAX 请求会造成浏览器失去响应，许多浏览器已经禁止在主线程使用，只允许 Worker 里面使用。所以，这个参数轻易不应该设为<code>false</code>。</li>
<li><code>user</code>：表示用于认证的用户名，默认为空字符串。该参数可选。</li>
<li><code>password</code>：表示用于认证的密码，默认为空字符串。该参数可选。</li>
</ul>
<p>注意，如果对使用过<code>open()</code>方法的 AJAX 请求，再次使用这个方法，等同于调用<code>abort()</code>，即终止请求。</p>
<p>下面发送 POST 请求的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;POST&#x27;</span>, <span class="built_in">encodeURI</span>(<span class="string">&#x27;someURL&#x27;</span>));</span><br></pre></td></tr></table></figure>

<h3 id="XMLHttpRequest-send"><a href="#XMLHttpRequest-send" class="headerlink" title="XMLHttpRequest.send()"></a>XMLHttpRequest.send()</h3><p><code>XMLHttpRequest.send()</code>方法用于实际发出 HTTP 请求。它的参数是可选的，如果不带参数，就表示 HTTP 请求只有一个 URL，没有数据体，典型例子就是 GET 请求；如果带有参数，就表示除了头信息，还带有包含具体数据的信息体，典型例子就是 POST 请求。</p>
<p>下面是 GET 请求的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;http://www.example.com/?id=&#x27;</span> + <span class="built_in">encodeURIComponent</span>(id),</span><br><span class="line">  <span class="literal">true</span></span><br><span class="line">);</span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>GET</code>请求的参数，作为查询字符串附加在 URL 后面。</p>
<p>下面是发送 POST 请求的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"><span class="keyword">var</span> data = <span class="string">&#x27;email=&#x27;</span></span><br><span class="line">  + <span class="built_in">encodeURIComponent</span>(email)</span><br><span class="line">  + <span class="string">&#x27;&amp;password=&#x27;</span></span><br><span class="line">  + <span class="built_in">encodeURIComponent</span>(password);</span><br><span class="line"></span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;http://www.example.com&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>);</span><br><span class="line">xhr.<span class="title function_">send</span>(data);</span><br></pre></td></tr></table></figure>

<p>注意，所有 XMLHttpRequest 的监听事件，都必须在<code>send()</code>方法调用之前设定。</p>
<p><code>send</code>方法的参数就是发送的数据。多种格式的数据，都可以作为它的参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">send</span>();</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">send</span>(<span class="title class_">ArrayBufferView</span> data);</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">send</span>(<span class="title class_">Blob</span> data);</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">send</span>(<span class="title class_">Document</span> data);</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">send</span>(<span class="title class_">String</span> data);</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">send</span>(<span class="title class_">FormData</span> data);</span><br></pre></td></tr></table></figure>

<p>如果<code>send()</code>发送 DOM 对象，在发送之前，数据会先被串行化。如果发送二进制数据，最好是发送<code>ArrayBufferView</code>或<code>Blob</code>对象，这使得通过 Ajax 上传文件成为可能。</p>
<p>下面是发送表单数据的例子。<code>FormData</code>对象可以用于构造表单数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> formData = <span class="keyword">new</span> <span class="title class_">FormData</span>();</span><br><span class="line"></span><br><span class="line">formData.<span class="title function_">append</span>(<span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;张三&#x27;</span>);</span><br><span class="line">formData.<span class="title function_">append</span>(<span class="string">&#x27;email&#x27;</span>, <span class="string">&#x27;zhangsan@example.com&#x27;</span>);</span><br><span class="line">formData.<span class="title function_">append</span>(<span class="string">&#x27;birthDate&#x27;</span>, <span class="number">1940</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;/register&#x27;</span>);</span><br><span class="line">xhr.<span class="title function_">send</span>(formData);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>FormData</code>对象构造了表单数据，然后使用<code>send()</code>方法发送。它的效果与发送下面的表单数据是一样的。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&#x27;registration&#x27;</span> <span class="attr">name</span>=<span class="string">&#x27;registration&#x27;</span> <span class="attr">action</span>=<span class="string">&#x27;/register&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#x27;text&#x27;</span> <span class="attr">name</span>=<span class="string">&#x27;username&#x27;</span> <span class="attr">value</span>=<span class="string">&#x27;张三&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#x27;email&#x27;</span> <span class="attr">name</span>=<span class="string">&#x27;email&#x27;</span> <span class="attr">value</span>=<span class="string">&#x27;zhangsan@example.com&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#x27;number&#x27;</span> <span class="attr">name</span>=<span class="string">&#x27;birthDate&#x27;</span> <span class="attr">value</span>=<span class="string">&#x27;1940&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#x27;submit&#x27;</span> <span class="attr">onclick</span>=<span class="string">&#x27;return sendForm(this.form);&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>下面的例子是使用<code>FormData</code>对象加工表单数据，然后再发送。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sendForm</span>(<span class="params">form</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> formData = <span class="keyword">new</span> <span class="title class_">FormData</span>(form);</span><br><span class="line">  formData.<span class="title function_">append</span>(<span class="string">&#x27;csrf&#x27;</span>, <span class="string">&#x27;e69a18d7db1286040586e6da1950128c&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">  xhr.<span class="title function_">open</span>(<span class="string">&#x27;POST&#x27;</span>, form.<span class="property">action</span>, <span class="literal">true</span>);</span><br><span class="line">  xhr.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;;</span><br><span class="line">  xhr.<span class="title function_">send</span>(formData);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> form = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#registration&#x27;</span>);</span><br><span class="line"><span class="title function_">sendForm</span>(form);</span><br></pre></td></tr></table></figure>

<h3 id="XMLHttpRequest-setRequestHeader"><a href="#XMLHttpRequest-setRequestHeader" class="headerlink" title="XMLHttpRequest.setRequestHeader()"></a>XMLHttpRequest.setRequestHeader()</h3><p><code>XMLHttpRequest.setRequestHeader()</code>方法用于设置浏览器发送的 HTTP 请求的头信息。该方法必须在<code>open()</code>之后、<code>send()</code>之前调用。如果该方法多次调用，设定同一个字段，则每一次调用的值会被合并成一个单一的值发送。</p>
<p>该方法接受两个参数。第一个参数是字符串，表示头信息的字段名，第二个参数是字段值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;application/json&#x27;</span>);</span><br><span class="line">xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;Content-Length&#x27;</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data).<span class="property">length</span>);</span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data));</span><br></pre></td></tr></table></figure>

<p>上面代码首先设置头信息<code>Content-Type</code>，表示发送 JSON 格式的数据；然后设置<code>Content-Length</code>，表示数据长度；最后发送 JSON 数据。</p>
<h3 id="XMLHttpRequest-overrideMimeType"><a href="#XMLHttpRequest-overrideMimeType" class="headerlink" title="XMLHttpRequest.overrideMimeType()"></a>XMLHttpRequest.overrideMimeType()</h3><p><code>XMLHttpRequest.overrideMimeType()</code>方法用来指定 MIME 类型，覆盖服务器返回的真正的 MIME 类型，从而让浏览器进行不一样的处理。举例来说，服务器返回的数据类型是<code>text/xml</code>，由于种种原因浏览器解析不成功报错，这时就拿不到数据了。为了拿到原始数据，我们可以把 MIME 类型改成<code>text/plain</code>，这样浏览器就不会去自动解析，从而我们就可以拿到原始文本了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="title function_">overrideMimeType</span>(<span class="string">&#x27;text/plain&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>注意，该方法必须在<code>send()</code>方法之前调用。</p>
<p>修改服务器返回的数据类型，不是正常情况下应该采取的方法。如果希望服务器返回指定的数据类型，可以用<code>responseType</code>属性告诉服务器，就像下面的例子。只有在服务器无法返回某种数据类型时，才使用<code>overrideMimeType()</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> arraybuffer = xhr.<span class="property">response</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, url);</span><br><span class="line">xhr.<span class="property">responseType</span> = <span class="string">&#x27;arraybuffer&#x27;</span>;</span><br><span class="line">xhr.<span class="title function_">send</span>();</span><br></pre></td></tr></table></figure>

<h3 id="XMLHttpRequest-getResponseHeader"><a href="#XMLHttpRequest-getResponseHeader" class="headerlink" title="XMLHttpRequest.getResponseHeader()"></a>XMLHttpRequest.getResponseHeader()</h3><p><code>XMLHttpRequest.getResponseHeader()</code>方法返回 HTTP 头信息指定字段的值，如果还没有收到服务器回应或者指定字段不存在，返回<code>null</code>。该方法的参数不区分大小写。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getHeaderTime</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="title function_">getResponseHeader</span>(<span class="string">&quot;Last-Modified&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;HEAD&#x27;</span>, <span class="string">&#x27;yourpage.html&#x27;</span>);</span><br><span class="line">xhr.<span class="property">onload</span> = getHeaderTime;</span><br><span class="line">xhr.<span class="title function_">send</span>();</span><br></pre></td></tr></table></figure>

<p>如果有多个字段同名，它们的值会被连接为一个字符串，每个字段之间使用“逗号+空格”分隔。</p>
<h3 id="XMLHttpRequest-getAllResponseHeaders"><a href="#XMLHttpRequest-getAllResponseHeaders" class="headerlink" title="XMLHttpRequest.getAllResponseHeaders()"></a>XMLHttpRequest.getAllResponseHeaders()</h3><p><code>XMLHttpRequest.getAllResponseHeaders()</code>方法返回一个字符串，表示服务器发来的所有 HTTP 头信息。格式为字符串，每个头信息之间使用<code>CRLF</code>分隔（回车+换行），如果没有收到服务器回应，该属性为<code>null</code>。如果发生网络错误，该属性为空字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;foo.txt&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.<span class="title function_">send</span>();</span><br><span class="line"></span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> headers = xhr.<span class="title function_">getAllResponseHeaders</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码用于获取服务器返回的所有头信息。它可能是下面这样的字符串。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">date</span><span class="punctuation">: </span>Fri, 08 Dec 2017 21:04:30 GMT\r\n</span><br><span class="line"><span class="attribute">content-encoding</span><span class="punctuation">: </span>gzip\r\n</span><br><span class="line"><span class="attribute">x-content-type-options</span><span class="punctuation">: </span>nosniff\r\n</span><br><span class="line"><span class="attribute">server</span><span class="punctuation">: </span>meinheld/0.6.1\r\n</span><br><span class="line"><span class="attribute">x-frame-options</span><span class="punctuation">: </span>DENY\r\n</span><br><span class="line"><span class="attribute">content-type</span><span class="punctuation">: </span>text/html; charset=utf-8\r\n</span><br><span class="line"><span class="attribute">connection</span><span class="punctuation">: </span>keep-alive\r\n</span><br><span class="line"><span class="attribute">strict-transport-security</span><span class="punctuation">: </span>max-age=63072000\r\n</span><br><span class="line"><span class="attribute">vary</span><span class="punctuation">: </span>Cookie, Accept-Encoding\r\n</span><br><span class="line"><span class="attribute">content-length</span><span class="punctuation">: </span>6502\r\n</span><br><span class="line"><span class="attribute">x-xss-protection</span><span class="punctuation">: </span>1; mode=block\r\n</span><br></pre></td></tr></table></figure>

<p>然后，对这个字符串进行处理。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = headers.<span class="title function_">trim</span>().<span class="title function_">split</span>(<span class="regexp">/[\r\n]+/</span>);</span><br><span class="line"><span class="keyword">var</span> headerMap = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">arr.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">line</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> parts = line.<span class="title function_">split</span>(<span class="string">&#x27;: &#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> header = parts.<span class="title function_">shift</span>();</span><br><span class="line">  <span class="keyword">var</span> value = parts.<span class="title function_">join</span>(<span class="string">&#x27;: &#x27;</span>);</span><br><span class="line">  headerMap[header] = value;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">headerMap[<span class="string">&#x27;content-length&#x27;</span>] <span class="comment">// &quot;6502&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="XMLHttpRequest-abort"><a href="#XMLHttpRequest-abort" class="headerlink" title="XMLHttpRequest.abort()"></a>XMLHttpRequest.abort()</h3><p><code>XMLHttpRequest.abort()</code>方法用来终止已经发出的 HTTP 请求。调用这个方法以后，<code>readyState</code>属性变为<code>4</code>，<code>status</code>属性变为<code>0</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;http://www.example.com/page.php&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr) &#123;</span><br><span class="line">    xhr.<span class="title function_">abort</span>();</span><br><span class="line">    xhr = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="number">5000</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码在发出5秒之后，终止一个 AJAX 请求。</p>
<h3 id="XMLHttpRequest-实例的事件"><a href="#XMLHttpRequest-实例的事件" class="headerlink" title="XMLHttpRequest 实例的事件"></a>XMLHttpRequest 实例的事件</h3><h3 id="readyStateChange-事件"><a href="#readyStateChange-事件" class="headerlink" title="readyStateChange 事件"></a>readyStateChange 事件</h3><p><code>readyState</code>属性的值发生改变，就会触发 readyStateChange 事件。</p>
<p>我们可以通过<code>onReadyStateChange</code>属性，指定这个事件的监听函数，对不同状态进行不同处理。尤其是当状态变为<code>4</code>的时候，表示通信成功，这时回调函数就可以处理服务器传送回来的数据。</p>
<h3 id="progress-事件"><a href="#progress-事件" class="headerlink" title="progress 事件"></a>progress 事件</h3><p>上传文件时，XMLHttpRequest 实例对象本身和实例的<code>upload</code>属性，都有一个<code>progress</code>事件，会不断返回上传的进度。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">updateProgress</span> (oEvent) &#123;</span><br><span class="line">  <span class="keyword">if</span> (oEvent.<span class="property">lengthComputable</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> percentComplete = oEvent.<span class="property">loaded</span> / oEvent.<span class="property">total</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;无法计算进展&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">xhr.<span class="title function_">addEventListener</span>(<span class="string">&#x27;progress&#x27;</span>, updateProgress);</span><br><span class="line"></span><br><span class="line">xhr.<span class="title function_">open</span>();</span><br></pre></td></tr></table></figure>

<h3 id="load-事件、error-事件、abort-事件"><a href="#load-事件、error-事件、abort-事件" class="headerlink" title="load 事件、error 事件、abort 事件"></a>load 事件、error 事件、abort 事件</h3><p>load 事件表示服务器传来的数据接收完毕，error 事件表示请求出错，abort 事件表示请求被中断（比如用户取消请求）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"></span><br><span class="line">xhr.<span class="title function_">addEventListener</span>(<span class="string">&#x27;load&#x27;</span>, transferComplete);</span><br><span class="line">xhr.<span class="title function_">addEventListener</span>(<span class="string">&#x27;error&#x27;</span>, transferFailed);</span><br><span class="line">xhr.<span class="title function_">addEventListener</span>(<span class="string">&#x27;abort&#x27;</span>, transferCanceled);</span><br><span class="line"></span><br><span class="line">xhr.<span class="title function_">open</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">transferComplete</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;数据接收完毕&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">transferFailed</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;数据接收出错&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">transferCanceled</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;用户取消接收&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="loadend-事件"><a href="#loadend-事件" class="headerlink" title="loadend 事件"></a>loadend 事件</h3><p><code>abort</code>、<code>load</code>和<code>error</code>这三个事件，会伴随一个<code>loadend</code>事件，表示请求结束，但不知道其是否成功。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="title function_">addEventListener</span>(<span class="string">&#x27;loadend&#x27;</span>, loadEnd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">loadEnd</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求结束，状态未知&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="timeout-事件"><a href="#timeout-事件" class="headerlink" title="timeout 事件"></a>timeout 事件</h3><p>服务器超过指定时间还没有返回结果，就会触发 timeout 事件，具体的例子参见<code>timeout</code>属性一节。</p>
<h3 id="Navigator-sendBeacon"><a href="#Navigator-sendBeacon" class="headerlink" title="Navigator.sendBeacon()"></a>Navigator.sendBeacon()</h3><p>用户卸载网页的时候，有时需要向服务器发一些数据。很自然的做法是在<code>unload</code>事件或<code>beforeunload</code>事件的监听函数里面，使用<code>XMLHttpRequest</code>对象发送数据。但是，这样做不是很可靠，因为<code>XMLHttpRequest</code>对象是异步发送，很可能在它即将发送的时候，页面已经卸载了，从而导致发送取消或者发送失败。</p>
<p>解决方法就是<code>unload</code>事件里面，加一些很耗时的同步操作。这样就能留出足够的时间，保证异步 AJAX 能够发送成功。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">log</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">  xhr.<span class="title function_">open</span>(<span class="string">&#x27;post&#x27;</span>, <span class="string">&#x27;/log&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">  xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>);</span><br><span class="line">  xhr.<span class="title function_">send</span>(<span class="string">&#x27;foo=bar&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;unload&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="title function_">log</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// a time-consuming operation</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> m = <span class="number">1</span>; m &lt; <span class="number">10000</span>; m++) &#123; <span class="keyword">continue</span>; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，强制执行了一次双重循环，拖长了<code>unload</code>事件的执行时间，导致异步 AJAX 能够发送成功。</p>
<p>类似的还可以使用<code>setTimeout</code>。下面是追踪用户点击的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;a id=&quot;target&quot; href=&quot;https://baidu.com&quot;&gt;click&lt;/a&gt;</span></span><br><span class="line"><span class="keyword">const</span> clickTime = <span class="number">350</span>;</span><br><span class="line"><span class="keyword">const</span> theLink = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;target&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">log</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">  xhr.<span class="title function_">open</span>(<span class="string">&#x27;post&#x27;</span>, <span class="string">&#x27;/log&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">  xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>);</span><br><span class="line">  xhr.<span class="title function_">send</span>(<span class="string">&#x27;foo=bar&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">theLink.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  event.<span class="title function_">preventDefault</span>();</span><br><span class="line">  <span class="title function_">log</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span> = theLink.<span class="title function_">getAttribute</span>(<span class="string">&#x27;href&#x27;</span>);</span><br><span class="line">  &#125;, clickTime);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码使用<code>setTimeout</code>，拖延了350毫秒，才让页面跳转，因此使得异步 AJAX 有时间发出。</p>
<p>这些做法的共同问题是，卸载的时间被硬生生拖长了，后面页面的加载被推迟了，用户体验不好。</p>
<p>为了解决这个问题，浏览器引入了<code>Navigator.sendBeacon()</code>方法。这个方法还是异步发出请求，但是请求与当前页面线程脱钩，作为浏览器进程的任务，因此可以保证会把数据发出去，不拖延卸载流程。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;unload&#x27;</span>, logData, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">logData</span>(<span class="params"></span>) &#123;</span><br><span class="line">  navigator.<span class="title function_">sendBeacon</span>(<span class="string">&#x27;/log&#x27;</span>, analyticsData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Navigator.sendBeacon</code>方法接受两个参数，第一个参数是目标服务器的 URL，第二个参数是所要发送的数据（可选），可以是任意类型（字符串、表单对象、二进制对象等等）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">navigator.<span class="title function_">sendBeacon</span>(url, data)</span><br></pre></td></tr></table></figure>

<p>这个方法的返回值是一个布尔值，成功发送数据为<code>true</code>，否则为<code>false</code>。</p>
<p>该方法发送数据的 HTTP 方法是 POST，可以跨域，类似于表单提交数据。它不能指定回调函数。</p>
<p>下面是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;body onload=&quot;analytics(&#x27;start&#x27;)&quot; onunload=&quot;analytics(&#x27;end&#x27;)&quot;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">analytics</span>(<span class="params">state</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!navigator.<span class="property">sendBeacon</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> <span class="variable constant_">URL</span> = <span class="string">&#x27;http://example.com/analytics&#x27;</span>;</span><br><span class="line">  <span class="keyword">var</span> data = <span class="string">&#x27;state=&#x27;</span> + state + <span class="string">&#x27;&amp;location=&#x27;</span> + <span class="variable language_">window</span>.<span class="property">location</span>;</span><br><span class="line">  navigator.<span class="title function_">sendBeacon</span>(<span class="variable constant_">URL</span>, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="模块-Module"><a href="#模块-Module" class="headerlink" title="模块(Module)"></a>模块(Module)</h2><p>ES6之前js的模块方案主要有CommonJS和AMD两种，前者是Nodejs专用，用于服务器，后者用于浏览器。ES6实现了自己的模块功能，成为浏览器和服务器通用的模块解决方案。</p>
<p>ES6模块与CommonJS模块的差异：</p>
<table>
<thead>
<tr>
<th></th>
<th>CommonJS（ require() ）</th>
<th>ES6 Module（import from）</th>
</tr>
</thead>
<tbody><tr>
<td>输出</td>
<td>值的拷贝（可重新赋值也可以用代码更新）</td>
<td>值的引用（不可重新赋值但可用代码更新）</td>
</tr>
<tr>
<td>加载时机</td>
<td>运行时加载（输出的是module.exports对象，脚本运行完才会生成）</td>
<td>编译时加载（早于运行时）</td>
</tr>
<tr>
<td>加载方式</td>
<td>同步加载（下面的代码必须等加载完再执行）</td>
<td>异步加载（下面的代码可以在加载完前执行）</td>
</tr>
</tbody></table>
<h3 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h3><p>简称cjs，使用<code>require()</code>和<code>module.exports</code>。</p>
<p>使用方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func3</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;func3&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 要导出的变量和函数写在module.exports对象中即可</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;value&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: <span class="string">&#x27;data&#x27;</span>,</span><br><span class="line">    <span class="title function_">func1</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;func1&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">func2</span>: <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;func2&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">func3</span>: func3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">let</span> md = <span class="built_in">require</span>(<span class="string">&#x27;./module.js&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(md.<span class="property">value</span>, md.<span class="property">data</span>)</span><br><span class="line">md.<span class="title function_">func1</span>()</span><br><span class="line">md.<span class="title function_">func2</span>()</span><br><span class="line">md.<span class="title function_">func3</span>()</span><br></pre></td></tr></table></figure>

<h3 id="ES6模块"><a href="#ES6模块" class="headerlink" title="ES6模块"></a>ES6模块</h3><p>简称esm，使用<code>import</code>和<code>export</code>。ES6模块将默认启用严格模式。</p>
<h4 id="导出变量或函数"><a href="#导出变量或函数" class="headerlink" title="导出变量或函数"></a>导出变量或函数</h4><p>使用方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// profile.js</span></span><br><span class="line"><span class="keyword">var</span> firstName = <span class="string">&#x27;Michael&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> lastName = <span class="string">&#x27;Jackson&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> year = <span class="number">1958</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; firstName, lastName, year &#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码在<code>export</code>命令后面，使用大括号指定所要输出的一组变量。应该优先考虑使用这种写法，因为这样就可以在脚本尾部，一眼看清楚输出了哪些变量。</p>
<p><code>export</code>命令除了输出变量，还可以输出函数或类（class）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">multiply</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">multiply</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;multiply&#125;;</span><br></pre></td></tr></table></figure>

<p>错误用法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">export</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> m;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">export</span> f;</span><br></pre></td></tr></table></figure>

<p><code>export</code> 后面的变量一定要加大括号。</p>
<p>另外<code>export</code>和<code>import</code>关键字一定要处在模块的顶层作用域内，不能在块级作用域中，否则报错。</p>
<p>还可以使用<code>as</code>关键字给导出的变量或函数重命名，同一个变量可以指定多个别名：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">v1</span>(<span class="params"></span>) &#123; ... &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">v2</span>(<span class="params"></span>) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  v1 <span class="keyword">as</span> streamV1,</span><br><span class="line">  v2 <span class="keyword">as</span> streamV2,</span><br><span class="line">  v2 <span class="keyword">as</span> streamLatestVersion</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码使用<code>as</code>关键字，重命名了函数<code>v1</code>和<code>v2</code>的对外接口。重命名后，<code>v2</code>可以用不同的名字输出两次。</p>
<p><code>export from</code></p>
<h4 id="导入模块中的变量或函数"><a href="#导入模块中的变量或函数" class="headerlink" title="导入模块中的变量或函数"></a>导入模块中的变量或函数</h4><p>使用方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; firstName, lastName, year &#125; <span class="keyword">from</span> <span class="string">&#x27;./profile.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setName</span>(<span class="params">element</span>) &#123;</span><br><span class="line">  element.<span class="property">textContent</span> = firstName + <span class="string">&#x27; &#x27;</span> + lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>import</code>命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（<code>profile.js</code>）对外接口的名称相同。</p>
<p>如果想为输入的变量重新取一个名字，<code>import</code>命令要使用<code>as</code>关键字，将输入的变量重命名。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; lastName <span class="keyword">as</span> surname &#125; <span class="keyword">from</span> <span class="string">&#x27;./profile.js&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><code>import</code>命令输入的变量都是只读的，但是，如果<code>a</code>是一个对象，改写<code>a</code>的属性是允许的（不过，这种写法很难查错，<strong>建议凡是输入的变量，都当作完全只读，不要轻易改变它的属性</strong>。）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;a&#125; <span class="keyword">from</span> <span class="string">&#x27;./xxx.js&#x27;</span></span><br><span class="line"></span><br><span class="line">a = &#123;&#125;; <span class="comment">// Syntax Error : &#x27;a&#x27; is read-only;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，脚本加载了变量<code>a</code>，对其重新赋值就会报错，因为<code>a</code>是一个只读的接口。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;a&#125; <span class="keyword">from</span> <span class="string">&#x27;./xxx.js&#x27;</span></span><br><span class="line"></span><br><span class="line">a.<span class="property">foo</span> = <span class="string">&#x27;hello&#x27;</span>; <span class="comment">// 合法操作</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>a</code>的属性可以成功改写，并且其他模块也可以读到改写后的值。</p>
<p><code>import</code>命令具有提升效果，会提升到整个模块的头部，首先执行。这种行为的本质是，<code>import</code>命令是编译阶段执行的，在代码运行之前。另外由于<code>import</code>是静态执行，所以不能使用表达式和变量这些只有在运行时才能得到结果的语法结构。</p>
<p>最后，<code>import</code>语句会执行所加载的模块，因此可以有下面的写法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;lodash&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>上面代码仅仅执行<code>lodash</code>模块，但是不输入任何值。</p>
<p>如果多次重复执行同一句<code>import</code>语句，那么只会执行一次，而不会执行多次。</p>
<p><code>from</code>指定模块文件的位置，可以是相对路径，也可以是绝对路径。如果不带有路径，只是一个模块名，那么必须有配置文件，告诉 JavaScript 引擎该模块的位置。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; myMethod &#125; <span class="keyword">from</span> <span class="string">&#x27;util&#x27;</span>;</span><br></pre></td></tr></table></figure>



<p>除了指定加载某个输出值，还可以使用整体加载，即用星号（<code>*</code>）指定一个对象，所有输出值都加载在这个对象上面。</p>
<p>下面是一个<code>circle.js</code>文件，它输出两个方法<code>area</code>和<code>circumference</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// circle.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">area</span>(<span class="params">radius</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="property">PI</span> * radius * radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">circumference</span>(<span class="params">radius</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span> * <span class="title class_">Math</span>.<span class="property">PI</span> * radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整体加载的写法如下，<code>*</code>号不需要加大括号：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> circle <span class="keyword">from</span> <span class="string">&#x27;./circle&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;圆面积：&#x27;</span> + circle.<span class="title function_">area</span>(<span class="number">4</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;圆周长：&#x27;</span> + circle.<span class="title function_">circumference</span>(<span class="number">14</span>));</span><br></pre></td></tr></table></figure>

<p>注意，模块整体加载所在的那个对象（上例是<code>circle</code>），应该是可以静态分析的，所以不允许运行时改变。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> circle <span class="keyword">from</span> <span class="string">&#x27;./circle&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面两行都是不允许的</span></span><br><span class="line">circle.<span class="property">foo</span> = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">circle.<span class="property">area</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="浏览器加载-ES6-模块"><a href="#浏览器加载-ES6-模块" class="headerlink" title="浏览器加载 ES6 模块"></a>浏览器加载 ES6 模块</h4><p>也使用<code>&lt;script&gt;</code>标签，但是要加入<code>type=&quot;module&quot;</code>属性。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./foo.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面代码在网页中插入一个模块<code>foo.js</code>，由于<code>type</code>属性设为<code>module</code>，所以浏览器知道这是一个 ES6 模块。</p>
<p>浏览器对于带有<code>type=&quot;module&quot;</code>的<code>&lt;script&gt;</code>，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了<code>&lt;script&gt;</code>标签的<code>defer</code>属性。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./foo.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 等同于 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./foo.js&quot;</span> <span class="attr">defer</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果网页有多个<code>&lt;script type=&quot;module&quot;&gt;</code>，它们会按照在页面出现的顺序依次执行。</p>
<p><code>&lt;script&gt;</code>标签的<code>async</code>属性也可以打开，这时只要加载完成，渲染引擎就会中断渲染立即执行。执行完成后，再恢复渲染。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./foo.js&quot;</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>一旦使用了<code>async</code>属性，<code>&lt;script type=&quot;module&quot;&gt;</code>就不会按照在页面出现的顺序执行，而是只要该模块加载完成，就执行该模块。</p>
<p>ES6 模块也允许内嵌在网页中，语法行为与加载外部脚本完全一致。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> utils <span class="keyword">from</span> <span class="string">&quot;./utils.js&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// other code</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>举例来说，jQuery 就支持模块加载。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">&quot;./jquery/src/jquery.js&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">  $(<span class="string">&#x27;#message&#x27;</span>).<span class="title function_">text</span>(<span class="string">&#x27;Hi from jQuery!&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>对于外部的模块脚本（上例是<code>foo.js</code>），有几点需要注意。</p>
<ul>
<li>代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。</li>
<li>模块脚本自动采用严格模式，不管有没有声明<code>use strict</code>。</li>
<li>模块之中，可以使用<code>import</code>命令加载其他模块（<code>.js</code>后缀不可省略，需要提供绝对 URL 或相对 URL），也可以使用<code>export</code>命令输出对外接口。</li>
<li>模块之中，顶层的<code>this</code>关键字返回<code>undefined</code>，而不是指向<code>window</code>。也就是说，在模块顶层使用<code>this</code>关键字，是无意义的。</li>
<li>同一个模块如果加载多次，将只执行一次。</li>
</ul>
<p>下面是一个示例模块。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> utils <span class="keyword">from</span> <span class="string">&#x27;https://example.com/js/utils.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x === <span class="variable language_">window</span>.<span class="property">x</span>); <span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === <span class="literal">undefined</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>利用顶层的<code>this</code>等于<code>undefined</code>这个语法点，可以侦测当前代码是否在 ES6 模块之中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isNotModuleScript = <span class="variable language_">this</span> !== <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure>
<!-- flag of hidden posts --></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://blog.elzzach.top">Elzzach</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://blog.elzzach.top/article/ec234b8c270a.html">https://blog.elzzach.top/article/ec234b8c270a.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.elzzach.top" target="_blank">暮紫天地</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.elzzach.top/global-img/avatar.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Elzzach</div><div class="author-info__description">一个爱好视觉效果的(想花里胡哨却花不起来的)入门小前端</div></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/legend-cpu" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:el-zzach@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到暮紫天地！🎉<br/>博主去知识的海洋里遨游了，更新随缘哦~<br/><strong>主站点</strong>：<a href="https://blog.elzzach.top/" target="_blank">blog.elzzach.top</a><br/><strong>镜像站</strong>：<a href="https://legend-cpu.github.io/" target="_blank">Github镜像站</a><br/>作者才疏学浅，读者若发现文章有错误之处，请不吝指出！<br/><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog.elzzach.top/global-img/202202241714592.gif" alt="可爱"/></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98"><span class="toc-number">1.</span> <span class="toc-text">变量、作用域与内存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%A7%8B%E5%80%BC%E4%B8%8E%E5%BC%95%E7%94%A8%E5%80%BC"><span class="toc-number">1.1.</span> <span class="toc-text">原始值与引用值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%B1%9E%E6%80%A7"><span class="toc-number">1.1.1.</span> <span class="toc-text">动态属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E5%80%BC"><span class="toc-number">1.1.2.</span> <span class="toc-text">复制值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0"><span class="toc-number">1.1.3.</span> <span class="toc-text">传递参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AE%E5%AE%9A%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.4.</span> <span class="toc-text">确定类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.2.</span> <span class="toc-text">执行上下文与作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.2.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%A2%9E%E5%BC%BA"><span class="toc-number">1.2.2.</span> <span class="toc-text">作用域链增强</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E"><span class="toc-number">1.2.3.</span> <span class="toc-text">变量声明</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8var%E7%9A%84%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%A3%B0%E6%98%8E"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">1.使用var的函数作用域声明</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8let%E7%9A%84%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%A3%B0%E6%98%8E"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">2.使用let的块级作用域声明</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8const%E7%9A%84%E5%B8%B8%E9%87%8F%E5%A3%B0%E6%98%8E"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">3.使用const的常量声明</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E6%A0%87%E8%AF%86%E7%AC%A6%E6%9F%A5%E6%89%BE"><span class="toc-number">1.2.3.4.</span> <span class="toc-text">4.标识符查找</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">1.3.</span> <span class="toc-text">垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-1"><span class="toc-number">1.3.0.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E6%B8%85%E7%90%86"><span class="toc-number">1.3.0.2.</span> <span class="toc-text">标记清理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0"><span class="toc-number">1.3.0.3.</span> <span class="toc-text">引用计数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%88%E5%BE%85%E4%BA%8C%E5%88%B7%EF%BC%89"><span class="toc-number">1.3.0.4.</span> <span class="toc-text">内存管理（待二刷）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E9%80%9A%E8%BF%87let%E5%92%8Cconst%E5%A3%B0%E6%98%8E%E6%8F%90%E5%8D%87%E6%80%A7%E8%83%BD"><span class="toc-number">1.3.0.4.1.</span> <span class="toc-text">1.通过let和const声明提升性能</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E9%9A%90%E8%97%8F%E7%B1%BB%E5%92%8C%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-number">1.3.0.4.2.</span> <span class="toc-text">2.隐藏类和删除操作</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">1.3.0.4.3.</span> <span class="toc-text">3.内存泄漏</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-%E9%9D%99%E6%80%81%E5%88%86%E9%85%8D%E4%B8%8E%E5%AF%B9%E8%B1%A1%E6%B1%A0"><span class="toc-number">1.3.0.4.4.</span> <span class="toc-text">4.静态分配与对象池</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.</span> <span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.1.</span> <span class="toc-text">对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95"><span class="toc-number">2.1.1.</span> <span class="toc-text">基本属性和方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%93%AA%E4%B8%AA%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA%E7%9A%84"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">查看当前对象是哪个构造函数创建的</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%BD%93%E5%89%8D%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B-%E4%B8%8D%E6%98%AF%E5%8E%9F%E5%9E%8B-%E4%B8%8A%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E7%BB%99%E5%AE%9A%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">判断当前对象实例(不是原型)上是否存在给定的属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%BD%93%E5%89%8D%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E4%B8%BA%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8E%9F%E5%9E%8B"><span class="toc-number">2.1.1.3.</span> <span class="toc-text">判断当前对象是否为另一个对象的原型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E7%BB%99%E5%AE%9A%E7%9A%84%E5%B1%9E%E6%80%A7%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8for-in%E8%AF%AD%E5%8F%A5%E6%9E%9A%E4%B8%BE"><span class="toc-number">2.1.1.4.</span> <span class="toc-text">判断给定的属性是否可以使用for-in语句枚举</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A1%A8%E7%A4%BA"><span class="toc-number">2.1.1.5.</span> <span class="toc-text">返回对象的字符串表示</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E5%AF%B9%E5%BA%94%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E6%95%B0%E5%80%BC%E6%88%96%E5%B8%83%E5%B0%94%E5%80%BC%E8%A1%A8%E7%A4%BA"><span class="toc-number">2.1.1.6.</span> <span class="toc-text">返回对象对应的字符串、数值或布尔值表示</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">2.1.2.</span> <span class="toc-text">对象的基本操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%E5%92%8C%E5%A4%8D%E5%88%B6"><span class="toc-number">2.1.3.</span> <span class="toc-text">对象引用和复制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">2.1.3.1.</span> <span class="toc-text">浅拷贝</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-number">2.1.3.2.</span> <span class="toc-text">深拷贝</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%85%B6%E5%86%85%E9%83%A8%E7%89%B9%E6%80%A7"><span class="toc-number">2.1.4.</span> <span class="toc-text">属性类型及其内部特性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%B1%9E%E6%80%A7"><span class="toc-number">2.1.4.1.</span> <span class="toc-text">数据属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%99%A8%E5%B1%9E%E6%80%A7"><span class="toc-number">2.1.4.2.</span> <span class="toc-text">访问器属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8C%E6%97%B6%E4%BF%AE%E6%94%B9%E5%A4%9A%E4%B8%AA%E5%B1%9E%E6%80%A7%E7%9A%84%E5%86%85%E9%83%A8%E7%89%B9%E6%80%A7"><span class="toc-number">2.1.4.3.</span> <span class="toc-text">同时修改多个属性的内部特性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E5%B1%9E%E6%80%A7%E7%9A%84%E5%86%85%E9%83%A8%E7%89%B9%E6%80%A7"><span class="toc-number">2.1.4.4.</span> <span class="toc-text">读取属性的内部特性</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Mixin%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8E%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%89%E5%85%B3%EF%BC%8C%E5%AD%A6%E5%AE%8C%E7%B1%BB%E7%BB%A7%E6%89%BF%E5%86%8D%E6%9D%A5%E7%9C%8B%EF%BC%89"><span class="toc-number">2.1.5.</span> <span class="toc-text">Mixin模式（与多重继承和设计模式有关，学完类继承再来看）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9B%B8%E7%AD%89%E5%88%A4%E5%AE%9A"><span class="toc-number">2.1.6.</span> <span class="toc-text">对象相等判定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A2%9E%E5%BC%BA%E7%9A%84%E5%AF%B9%E8%B1%A1%E8%AF%AD%E6%B3%95"><span class="toc-number">2.1.7.</span> <span class="toc-text">增强的对象语法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E5%80%BC%E7%AE%80%E5%86%99"><span class="toc-number">2.1.7.1.</span> <span class="toc-text">属性值简写</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7"><span class="toc-number">2.1.7.2.</span> <span class="toc-text">可计算属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%80%E5%86%99%E6%96%B9%E6%B3%95%E5%90%8D"><span class="toc-number">2.1.7.3.</span> <span class="toc-text">简写方法名</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.1.8.</span> <span class="toc-text">创建对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E6%9C%B4%E7%B4%A0%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">2.1.8.1.</span> <span class="toc-text">最朴素的方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.1.8.2.</span> <span class="toc-text">工厂模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.1.8.3.</span> <span class="toc-text">构造函数模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.1.8.4.</span> <span class="toc-text">原型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%E5%8E%9F%E5%9E%8B"><span class="toc-number">2.1.8.4.1.</span> <span class="toc-text">理解原型</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E5%B1%82%E7%BA%A7"><span class="toc-number">2.1.8.4.2.</span> <span class="toc-text">原型层级</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%8E%9F%E5%9E%8B%E8%AF%AD%E6%B3%95"><span class="toc-number">2.1.8.4.3.</span> <span class="toc-text">其他原型语法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E7%9A%84%E5%8A%A8%E6%80%81%E6%80%A7"><span class="toc-number">2.1.8.4.4.</span> <span class="toc-text">原型的动态性</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">2.1.8.4.5.</span> <span class="toc-text">原型模式存在的问题</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E5%92%8Cin%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">2.1.8.4.6.</span> <span class="toc-text">原型和in操作符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">2.1.9.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF"><span class="toc-number">2.1.9.1.</span> <span class="toc-text">原型链继承</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%8E%9F%E5%9E%8B"><span class="toc-number">2.1.9.1.1.</span> <span class="toc-text">默认原型</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8A%80%E5%B7%A7%EF%BC%9A%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E6%9F%A5%E6%89%BE%E5%85%B6%E7%88%B6%E7%B1%BB%E3%80%81%E7%88%B6%E7%B1%BB%E7%9A%84%E7%88%B6%E7%B1%BB%E3%80%81%E7%88%B6%E7%B1%BB%E7%9A%84%E7%88%B6%E7%B1%BB%E7%9A%84%E7%88%B6%E7%B1%BB%E2%80%A6%EF%BC%9F"><span class="toc-number">2.1.9.1.2.</span> <span class="toc-text">技巧：给定一个对象，如何快速查找其父类、父类的父类、父类的父类的父类…？</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E7%9A%84%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB"><span class="toc-number">2.1.9.1.3.</span> <span class="toc-text">实例的继承关系</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E6%96%B9%E6%B3%95"><span class="toc-number">2.1.9.1.4.</span> <span class="toc-text">关于方法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">2.1.9.1.5.</span> <span class="toc-text">原型链的问题</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%97%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%BB%A7%E6%89%BF%EF%BC%88%E5%8F%88%E7%A7%B0%E5%AF%B9%E8%B1%A1%E4%BC%AA%E8%A3%85%EF%BC%89"><span class="toc-number">2.1.9.2.</span> <span class="toc-text">盗用构造函数继承（又称对象伪装）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF%EF%BC%88%E6%9C%80%E7%BB%88%E6%96%B9%E5%BC%8F%EF%BC%89"><span class="toc-number">2.1.9.3.</span> <span class="toc-text">组合继承（最终方式）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8D%E9%9C%80%E8%A6%81%E5%8D%95%E7%8B%AC%E5%BB%BA%E7%AB%8B%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%97%B6%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F"><span class="toc-number">2.1.9.4.</span> <span class="toc-text">不需要单独建立构造函数时的两种继承方式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ES6%E7%B1%BB"><span class="toc-number">2.1.10.</span> <span class="toc-text">ES6类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E5%AE%9A%E4%B9%89"><span class="toc-number">2.1.10.1.</span> <span class="toc-text">类定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E6%9E%84%E6%88%90"><span class="toc-number">2.1.10.2.</span> <span class="toc-text">类的构成</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.10.3.</span> <span class="toc-text">类构造函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E6%98%AF%E4%B8%80%E7%A7%8D%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.10.4.</span> <span class="toc-text">类是一种特殊函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF-1"><span class="toc-number">2.1.10.5.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#super%EF%BC%88%EF%BC%89"><span class="toc-number">2.1.10.5.1.</span> <span class="toc-text">super（）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB"><span class="toc-number">2.1.10.5.2.</span> <span class="toc-text">抽象基类</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.1.10.5.3.</span> <span class="toc-text">继承内置类型</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B7%B7%E7%94%A8mixin"><span class="toc-number">2.1.10.5.4.</span> <span class="toc-text">混用mixin</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%B0%84"><span class="toc-number">3.</span> <span class="toc-text">代理与反射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E5%9F%BA%E7%A1%80"><span class="toc-number">3.0.1.</span> <span class="toc-text">代理基础</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%8D%95%E8%8E%B7%E5%99%A8"><span class="toc-number">3.0.2.</span> <span class="toc-text">定义捕获器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8D%95%E8%8E%B7%E5%99%A8%E5%8F%82%E6%95%B0%E5%92%8C%E5%8F%8D%E5%B0%84API"><span class="toc-number">3.0.3.</span> <span class="toc-text">捕获器参数和反射API</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8D%95%E8%8E%B7%E5%99%A8%E4%B8%8E%E5%8F%8D%E5%B0%84API"><span class="toc-number">3.0.3.1.</span> <span class="toc-text">常用的捕获器与反射API</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#get%EF%BC%88%EF%BC%89"><span class="toc-number">3.0.3.1.1.</span> <span class="toc-text">get（）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#set%EF%BC%88%EF%BC%89"><span class="toc-number">3.0.3.1.2.</span> <span class="toc-text">set（）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#has%EF%BC%88%EF%BC%89"><span class="toc-number">3.0.3.1.3.</span> <span class="toc-text">has（）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#defineProperty%EF%BC%88%EF%BC%89"><span class="toc-number">3.0.3.1.4.</span> <span class="toc-text">defineProperty（）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#getOwnPropertyDescriptor%EF%BC%88%EF%BC%89"><span class="toc-number">3.0.3.1.5.</span> <span class="toc-text">getOwnPropertyDescriptor（）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#deleteProperty%EF%BC%88%EF%BC%89"><span class="toc-number">3.0.3.1.6.</span> <span class="toc-text">deleteProperty（）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#ownKeys%EF%BC%88%EF%BC%89"><span class="toc-number">3.0.3.1.7.</span> <span class="toc-text">ownKeys（）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#getPrototypeOf%EF%BC%88%EF%BC%89"><span class="toc-number">3.0.3.1.8.</span> <span class="toc-text">getPrototypeOf（）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#setPrototypeOf%EF%BC%88%EF%BC%89"><span class="toc-number">3.0.3.1.9.</span> <span class="toc-text">setPrototypeOf（）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#isExtensible%EF%BC%88%EF%BC%89"><span class="toc-number">3.0.3.1.10.</span> <span class="toc-text">isExtensible（）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#preventExtensions%EF%BC%88%EF%BC%89"><span class="toc-number">3.0.3.1.11.</span> <span class="toc-text">preventExtensions（）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#apply%EF%BC%88%EF%BC%89"><span class="toc-number">3.0.3.1.12.</span> <span class="toc-text">apply（）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#construct%EF%BC%88%EF%BC%89"><span class="toc-number">3.0.3.1.13.</span> <span class="toc-text">construct（）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E6%92%A4%E9%94%80%E4%BB%A3%E7%90%86"><span class="toc-number">3.0.4.</span> <span class="toc-text">可撤销代理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">3.0.5.</span> <span class="toc-text">代理的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.0.6.</span> <span class="toc-text">代理可以实现的编程模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B7%9F%E8%B8%AA%E5%B1%9E%E6%80%A7%E8%AE%BF%E9%97%AE"><span class="toc-number">3.0.6.1.</span> <span class="toc-text">跟踪属性访问</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9A%90%E8%97%8F%E5%B1%9E%E6%80%A7"><span class="toc-number">3.0.6.2.</span> <span class="toc-text">隐藏属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E9%AA%8C%E8%AF%81"><span class="toc-number">3.0.6.3.</span> <span class="toc-text">属性验证</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E9%AA%8C%E8%AF%81"><span class="toc-number">3.0.6.4.</span> <span class="toc-text">函数与构造函数参数验证</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E4%B8%8E%E5%8F%AF%E8%A7%82%E5%AF%9F%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.0.6.5.</span> <span class="toc-text">数据绑定与可观察对象</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%9F%E7%BA%A6%E4%B8%8E%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0"><span class="toc-number">4.</span> <span class="toc-text">期约与异步函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">4.0.1.</span> <span class="toc-text">定时器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#setTimeout%EF%BC%88f%EF%BC%8C0%EF%BC%89"><span class="toc-number">4.0.1.1.</span> <span class="toc-text">setTimeout（f，0）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%90%86%E8%A7%A3"><span class="toc-number">4.0.1.1.1.</span> <span class="toc-text">理解</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BA%94%E7%94%A8"><span class="toc-number">4.0.1.1.2.</span> <span class="toc-text">应用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%E6%A6%82%E8%BF%B0"><span class="toc-number">4.0.2.</span> <span class="toc-text">异步操作概述</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.0.2.1.</span> <span class="toc-text">单线程模型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1"><span class="toc-number">4.0.2.2.</span> <span class="toc-text">同步任务和异步任务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="toc-number">4.0.2.3.</span> <span class="toc-text">任务队列和事件循环</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%E7%9A%84%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.0.2.4.</span> <span class="toc-text">异步操作的模式</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-number">4.0.2.4.1.</span> <span class="toc-text">回调函数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC"><span class="toc-number">4.0.2.4.2.</span> <span class="toc-text">事件监听</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8F%91%E5%B8%83-x2F-%E8%AE%A2%E9%98%85"><span class="toc-number">4.0.2.4.3.</span> <span class="toc-text">发布&#x2F;订阅</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%E7%9A%84%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">4.0.2.5.</span> <span class="toc-text">异步操作的流程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%B2%E8%A1%8C%E6%89%A7%E8%A1%8C"><span class="toc-number">4.0.2.5.1.</span> <span class="toc-text">串行执行</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E6%89%A7%E8%A1%8C"><span class="toc-number">4.0.2.5.2.</span> <span class="toc-text">并行执行</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E4%B8%8E%E4%B8%B2%E8%A1%8C%E7%BB%93%E5%90%88"><span class="toc-number">4.0.2.5.3.</span> <span class="toc-text">并行与串行结合</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Promise%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.0.3.</span> <span class="toc-text">Promise对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Promise-%E7%9A%84%E5%90%AB%E4%B9%89"><span class="toc-number">4.0.3.1.</span> <span class="toc-text">Promise 的含义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">4.0.3.2.</span> <span class="toc-text">基本用法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Promise-prototype-then"><span class="toc-number">4.0.3.3.</span> <span class="toc-text">Promise.prototype.then()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Promise-prototype-catch"><span class="toc-number">4.0.3.4.</span> <span class="toc-text">Promise.prototype.catch()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Promise-prototype-finally"><span class="toc-number">4.0.3.5.</span> <span class="toc-text">Promise.prototype.finally()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Promise-all"><span class="toc-number">4.0.3.6.</span> <span class="toc-text">Promise.all()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Promise-race"><span class="toc-number">4.0.3.7.</span> <span class="toc-text">Promise.race()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Promise-allSettled"><span class="toc-number">4.0.3.8.</span> <span class="toc-text">Promise.allSettled()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Promise-any"><span class="toc-number">4.0.3.9.</span> <span class="toc-text">Promise.any()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Promise-resolve"><span class="toc-number">4.0.3.10.</span> <span class="toc-text">Promise.resolve()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Promise-reject"><span class="toc-number">4.0.3.11.</span> <span class="toc-text">Promise.reject()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%94%E7%94%A8-1"><span class="toc-number">4.0.3.12.</span> <span class="toc-text">应用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E5%9B%BE%E7%89%87"><span class="toc-number">4.0.3.13.</span> <span class="toc-text">加载图片</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Generator-%E5%87%BD%E6%95%B0%E4%B8%8E-Promise-%E7%9A%84%E7%BB%93%E5%90%88"><span class="toc-number">4.0.3.14.</span> <span class="toc-text">Generator 函数与 Promise 的结合</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Promise-try"><span class="toc-number">4.0.3.15.</span> <span class="toc-text">Promise.try()</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AJAX"><span class="toc-number">5.</span> <span class="toc-text">AJAX</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-2"><span class="toc-number">5.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XMLHttpRequest-%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7"><span class="toc-number">5.2.</span> <span class="toc-text">XMLHttpRequest 的实例属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XMLHttpRequest-readyState"><span class="toc-number">5.3.</span> <span class="toc-text">XMLHttpRequest.readyState</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XMLHttpRequest-onreadystatechange"><span class="toc-number">5.4.</span> <span class="toc-text">XMLHttpRequest.onreadystatechange</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XMLHttpRequest-response"><span class="toc-number">5.5.</span> <span class="toc-text">XMLHttpRequest.response</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XMLHttpRequest-responseType"><span class="toc-number">5.6.</span> <span class="toc-text">XMLHttpRequest.responseType</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XMLHttpRequest-responseText"><span class="toc-number">5.7.</span> <span class="toc-text">XMLHttpRequest.responseText</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XMLHttpRequest-responseXML"><span class="toc-number">5.8.</span> <span class="toc-text">XMLHttpRequest.responseXML</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XMLHttpRequest-responseURL"><span class="toc-number">5.9.</span> <span class="toc-text">XMLHttpRequest.responseURL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XMLHttpRequest-status%EF%BC%8CXMLHttpRequest-statusText"><span class="toc-number">5.10.</span> <span class="toc-text">XMLHttpRequest.status，XMLHttpRequest.statusText</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XMLHttpRequest-timeout%EF%BC%8CXMLHttpRequestEventTarget-ontimeout"><span class="toc-number">5.11.</span> <span class="toc-text">XMLHttpRequest.timeout，XMLHttpRequestEventTarget.ontimeout</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E5%B1%9E%E6%80%A7"><span class="toc-number">5.12.</span> <span class="toc-text">事件监听属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XMLHttpRequest-withCredentials"><span class="toc-number">5.13.</span> <span class="toc-text">XMLHttpRequest.withCredentials</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XMLHttpRequest-upload"><span class="toc-number">5.14.</span> <span class="toc-text">XMLHttpRequest.upload</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XMLHttpRequest-%E7%9A%84%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="toc-number">5.15.</span> <span class="toc-text">XMLHttpRequest 的实例方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XMLHttpRequest-open"><span class="toc-number">5.16.</span> <span class="toc-text">XMLHttpRequest.open()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XMLHttpRequest-send"><span class="toc-number">5.17.</span> <span class="toc-text">XMLHttpRequest.send()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XMLHttpRequest-setRequestHeader"><span class="toc-number">5.18.</span> <span class="toc-text">XMLHttpRequest.setRequestHeader()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XMLHttpRequest-overrideMimeType"><span class="toc-number">5.19.</span> <span class="toc-text">XMLHttpRequest.overrideMimeType()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XMLHttpRequest-getResponseHeader"><span class="toc-number">5.20.</span> <span class="toc-text">XMLHttpRequest.getResponseHeader()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XMLHttpRequest-getAllResponseHeaders"><span class="toc-number">5.21.</span> <span class="toc-text">XMLHttpRequest.getAllResponseHeaders()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XMLHttpRequest-abort"><span class="toc-number">5.22.</span> <span class="toc-text">XMLHttpRequest.abort()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XMLHttpRequest-%E5%AE%9E%E4%BE%8B%E7%9A%84%E4%BA%8B%E4%BB%B6"><span class="toc-number">5.23.</span> <span class="toc-text">XMLHttpRequest 实例的事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#readyStateChange-%E4%BA%8B%E4%BB%B6"><span class="toc-number">5.24.</span> <span class="toc-text">readyStateChange 事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#progress-%E4%BA%8B%E4%BB%B6"><span class="toc-number">5.25.</span> <span class="toc-text">progress 事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#load-%E4%BA%8B%E4%BB%B6%E3%80%81error-%E4%BA%8B%E4%BB%B6%E3%80%81abort-%E4%BA%8B%E4%BB%B6"><span class="toc-number">5.26.</span> <span class="toc-text">load 事件、error 事件、abort 事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#loadend-%E4%BA%8B%E4%BB%B6"><span class="toc-number">5.27.</span> <span class="toc-text">loadend 事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#timeout-%E4%BA%8B%E4%BB%B6"><span class="toc-number">5.28.</span> <span class="toc-text">timeout 事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Navigator-sendBeacon"><span class="toc-number">5.29.</span> <span class="toc-text">Navigator.sendBeacon()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97-Module"><span class="toc-number">6.</span> <span class="toc-text">模块(Module)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CommonJS"><span class="toc-number">6.1.</span> <span class="toc-text">CommonJS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ES6%E6%A8%A1%E5%9D%97"><span class="toc-number">6.2.</span> <span class="toc-text">ES6模块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%BC%E5%87%BA%E5%8F%98%E9%87%8F%E6%88%96%E5%87%BD%E6%95%B0"><span class="toc-number">6.2.1.</span> <span class="toc-text">导出变量或函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E6%A8%A1%E5%9D%97%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%E6%88%96%E5%87%BD%E6%95%B0"><span class="toc-number">6.2.2.</span> <span class="toc-text">导入模块中的变量或函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8A%A0%E8%BD%BD-ES6-%E6%A8%A1%E5%9D%97"><span class="toc-number">6.2.3.</span> <span class="toc-text">浏览器加载 ES6 模块</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background: rgba(255, 255, 255, 0.8)"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By Elzzach</div><div class="footer_custom_text"><div class="footer_custom_text"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a><span class="footer-separator">|</span><span>备案 </span><a href="https://beian.miit.gov.cn" target="_blank">皖ICP备2022000051号</a></div></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://npm.elemecdn.com/medium-zoom@latest/dist/medium-zoom.min.js"></script><script src="https://npm.elemecdn.com/vanilla-lazyload@latest/dist/lazyload.iife.min.js"></script><script src="https://npm.elemecdn.com/node-snackbar@latest/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://npm.elemecdn.com/pangu@latest/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script src="https://npm.elemecdn.com/ezsttcfs@latest/live2d-widget/autoload.js"></script><script src="/ext/ez.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://npm.elemecdn.com/butterfly-extsrc@latest/dist/fireworks.min.js"></script><script src="https://npm.elemecdn.com/butterfly-extsrc@latest/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script></div></body></html>